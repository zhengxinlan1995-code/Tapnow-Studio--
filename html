<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tapnow Studio</title>
    
    <!-- 1. Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- 2. React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    
    <!-- 3. Babel for compiling JSX in browser -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- 4. Lucide Icons (Vanilla) -->
    <script src="https://unpkg.com/lucide@latest"></script>

    <!-- 5. Marked for Markdown rendering in Chat -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>

    <style>
        body { margin: 0; padding: 0; background-color: #09090b; }
        /* Prevent selection during drag - applied to canvas only mostly */
        .select-none { user-select: none; }
        /* Allow selection in chat */
        .select-text { user-select: text; }
        
        /* Loader animation fallback */
        @keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
        .animate-spin { animation: spin 1s linear infinite; }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel" data-presets="env,react">
        const { useState, useRef, useEffect, useCallback, useMemo, memo } = React;

        // --- ICON SYSTEM ADAPTER ---
        const IconWrapper = ({ name, size = 24, className = "", ...props }) => {
            const iconData = lucide.icons[name];
            if (!iconData) return null;
            
            return React.createElement('svg', {
                xmlns: "http://www.w3.org/2000/svg",
                width: size,
                height: size,
                viewBox: "0 0 24 24",
                fill: "none",
                stroke: "currentColor",
                strokeWidth: 2,
                strokeLinecap: "round",
                strokeLinejoin: "round",
                className: `lucide lucide-${name} ${className}`,
                ...props
            }, ...iconData.map(([tag, attrs]) => React.createElement(tag, attrs)));
        };

        const Plus = (p) => <IconWrapper name="Plus" {...p} />;
        const ImageIcon = (p) => <IconWrapper name="Image" {...p} />;
        const Video = (p) => <IconWrapper name="Video" {...p} />;
        const Settings = (p) => <IconWrapper name="Settings" {...p} />;
        const X = (p) => <IconWrapper name="X" {...p} />;
        const Play = (p) => <IconWrapper name="Play" {...p} />;
        const Layers = (p) => <IconWrapper name="Layers" {...p} />;
        const MousePointer2 = (p) => <IconWrapper name="MousePointer2" {...p} />;
        const Wand2 = (p) => <IconWrapper name="Wand2" {...p} />;
        const Loader2 = (p) => <IconWrapper name="Loader2" {...p} />;
        const LinkIcon = (p) => <IconWrapper name="Link" {...p} />;
        const History = (p) => <IconWrapper name="History" {...p} />;
        const ImagePlus = (p) => <IconWrapper name="ImagePlus" {...p} />;
        const Trash2 = (p) => <IconWrapper name="Trash2" {...p} />;
        const CheckCircle2 = (p) => <IconWrapper name="CheckCircle2" {...p} />;
        const Unlink = (p) => <IconWrapper name="Unlink" {...p} />;
        const CopyPlus = (p) => <IconWrapper name="CopyPlus" {...p} />;
        const ArrowRightSquare = (p) => <IconWrapper name="ArrowRightSquare" {...p} />;
        const MessageSquare = (p) => <IconWrapper name="MessageSquare" {...p} />;
        const Send = (p) => <IconWrapper name="Send" {...p} />;
        const Paperclip = (p) => <IconWrapper name="Paperclip" {...p} />;
        const FileText = (p) => <IconWrapper name="FileText" {...p} />;
        const FileAudio = (p) => <IconWrapper name="FileAudio" {...p} />;
        const FileVideo = (p) => <IconWrapper name="FileVideo" {...p} />;
        const FileImage = (p) => <IconWrapper name="FileImage" {...p} />;
        const ChevronRight = (p) => <IconWrapper name="ChevronRight" {...p} />;
        const ChevronLeft = (p) => <IconWrapper name="ChevronLeft" {...p} />;
        const MoreHorizontal = (p) => <IconWrapper name="MoreHorizontal" {...p} />;
        const Bot = (p) => <IconWrapper name="Bot" {...p} />;
        const User = (p) => <IconWrapper name="User" {...p} />;
        const GripVertical = (p) => <IconWrapper name="GripVertical" {...p} />;
        const Forward = (p) => <IconWrapper name="Forward" {...p} />;
        const RefreshCw = (p) => <IconWrapper name="RefreshCw" {...p} />;
        const Split = (p) => <IconWrapper name="Split" {...p} />;
        const Maximize2 = (p) => <IconWrapper name="Maximize2" {...p} />;
        const Sun = (p) => <IconWrapper name="Sun" {...p} />;
        const Moon = (p) => <IconWrapper name="Moon" {...p} />;
        const FileSearch = (p) => <IconWrapper name="FileSearch" {...p} />;
        const Sparkles = (p) => <IconWrapper name="Sparkles" {...p} />;
        const Mic = (p) => <IconWrapper name="Mic" {...p} />;
        const Mic2 = (p) => <IconWrapper name="Mic2" {...p} />;
        const Camera = (p) => <IconWrapper name="Camera" {...p} />;
        const Code = (p) => <IconWrapper name="Code" {...p} />;
        const ClipboardCopy = (p) => <IconWrapper name="ClipboardCopy" {...p} />;
        const Edit = (p) => <IconWrapper name="Edit" {...p} />;
        const LayoutGrid = (p) => <IconWrapper name="LayoutGrid" {...p} />;
        const Check = (p) => <IconWrapper name="Check" {...p} />;
        const CheckSquare = (p) => <IconWrapper name="CheckSquare" {...p} />;

        // --- 自定义样式 ---
        const styles = `
        /* 全局字体渲染优化 */
        * {
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            text-rendering: optimizeLegibility;
        }
        
        /* 画布容器渲染优化 */
        #canvas-bg {
            transform: translateZ(0);
            backface-visibility: hidden;
            perspective: 1000px;
        }
        
        /* 画布内容容器优化 */
        #canvas-bg > div[style*="transform"] {
            transform: translateZ(0);
            will-change: transform;
        }
        
        /* 节点容器优化 */
        .node-wrapper {
            transform: translateZ(0);
            backface-visibility: hidden;
        }
        
        /* 节点内图片渲染优化 - 使用高质量渲染 */
        .node-wrapper img,
        .node-wrapper video {
            image-rendering: auto;
            image-rendering: -webkit-optimize-contrast;
            transform: translateZ(0);
            backface-visibility: hidden;
            -webkit-backface-visibility: hidden;
        }
        
        /* 连接线优化 */
        svg {
            shape-rendering: geometricPrecision;
            text-rendering: optimizeLegibility;
        }
        
        .custom-scrollbar::-webkit-scrollbar { width: 4px; height: 4px; }
        .custom-scrollbar::-webkit-scrollbar-track { background: transparent; }
        .custom-scrollbar::-webkit-scrollbar-thumb { background: #3f3f46; border-radius: 2px; }
        .custom-scrollbar::-webkit-scrollbar-thumb:hover { background: #52525b; }
        .resize-handle { cursor: nwse-resize; opacity: 0; transition: opacity 0.2s; }
        .node-wrapper:hover .resize-handle { opacity: 1; }
        
        /* 连接点样式 */
        .connector { position: absolute; top: 50%; transform: translateY(-50%); width: 0.9rem; height: 0.9rem; background-color: #27272a; border: 1px solid #71717a; color: #a1a1aa; border-radius: 50%; display: flex; align-items: center; justify-content: center; cursor: crosshair; transition: all 0.2s; z-index: 30; opacity: 0; pointer-events: auto; }
        .node-wrapper:hover .connector { opacity: 1; }
        .connector:hover, .connector.active { background-color: #d4d4d8; border-color: #fff; transform: translateY(-50%) scale(1.2); opacity: 1; color: #000; }
        .connector-right { right: -0.45rem; }
        
        /* 输入点样式 */
        .input-point { position: absolute; top: 50%; transform: translateY(-50%); left: -0.25rem; width: 0.5rem; height: 0.5rem; background-color: #52525b; border-radius: 50%; border: 1px solid #18181b; transition: all 0.2s; z-index: 20; cursor: crosshair; }
        .node-wrapper:hover .input-point { background-color: #a1a1aa; }
        .input-point.connected { background-color: #60a5fa; box-shadow: 0 0 6px #60a5fa; }
        .input-point.active { background-color: #60a5fa; border-color: #fff; transform: translateY(-50%) scale(1.3); box-shadow: 0 0 8px #60a5fa; }

        /* Lightbox & Overlay */
        .lightbox-overlay { background-color: rgba(0, 0, 0, 0.95); backdrop-filter: blur(5px); }
        
        /* Stack Items */
        .thumb-stack-item {
             transition: transform 0.2s, z-index 0.2s;
        }
        .thumb-stack-item:hover {
            transform: scale(1.1) translateY(-2px);
            z-index: 10 !important;
            border-color: #60a5fa;
        }

        /* 连接线删除按钮 */
        .connection-delete {
            opacity: 0;
            transition: opacity 0.2s;
            pointer-events: auto; /* 关键：确保鼠标能交互 */
        }
        /* 当鼠标悬停在整个连接组（包含粗透明线）时显示 */
        .connection-group:hover .connection-delete {
            opacity: 1;
        }

        /* 拖放区域样式 */
        .drop-zone {
            border: 2px dashed transparent;
            transition: all 0.3s;
        }
        .drop-zone.drag-over {
            border-color: #60a5fa;
            background-color: rgba(96, 165, 250, 0.1);
        }

        /* Markdown Styles for Chat */
        .markdown-body { font-size: 13px; line-height: 1.5; color: #e4e4e7; word-wrap: break-word; }
        .markdown-body pre { background: #27272a; padding: 10px; border-radius: 6px; overflow-x: auto; margin: 8px 0; white-space: pre-wrap; word-wrap: break-word; }
        .markdown-body code { font-family: monospace; background: #3f3f46; padding: 2px 4px; border-radius: 4px; font-size: 12px; }
        .markdown-body pre code { background: transparent; padding: 0; color: #a1a1aa; }
        .markdown-body p { margin-bottom: 8px; }
        .markdown-body ul, .markdown-body ol { margin-left: 20px; margin-bottom: 8px; list-style: disc; }
        .markdown-body video { max-width: 100%; border-radius: 0.5rem; margin-top: 0.5rem; }
        .theme-light .markdown-body { color: #18181b; }
        .theme-light .markdown-body pre { background: #f4f4f5; color: #18181b; }
        .theme-light .markdown-body code { background: #e4e4e7; color: #18181b; }
        .theme-light .markdown-body pre code { color: #18181b; }
        `;

        // --- 虚拟画布尺寸 ---
        const VIRTUAL_CANVAS_WIDTH = 4000;
        const VIRTUAL_CANVAS_HEIGHT = 4000;

        // --- 默认配置 ---
        const DEFAULT_BASE_URL = 'https://ai.comfly.chat';
        
        // 即梦API配置（代理地址，默认本地5100端口）
        const JIMENG_API_BASE_URL = 'http://localhost:5100';
        const JIMENG_SESSION_ID = '7a16459fbd65d9c87b4ea44d3318f5fa';

        const DEFAULT_API_CONFIGS = [
            // Chat Models
            { id: 'gemini-3-pro', provider: 'Gemini 3 Pro', modelName: 'gemini-3-pro-preview', type: 'Chat', key: '', url: DEFAULT_BASE_URL },
            { id: 'gpt-5-1', provider: 'GPT 5.1', modelName: 'gpt-5.1', type: 'Chat', key: '', url: DEFAULT_BASE_URL },
            { id: 'deepseek-v3', provider: 'DeepSeek V3', modelName: 'deepseek-v3-1-250821', type: 'Chat', key: '', url: DEFAULT_BASE_URL },
            { id: 'gpt-4o', provider: 'GPT-4o', modelName: 'gpt-4o', type: 'Chat', key: '', url: DEFAULT_BASE_URL },
            
            // Image Models
            { id: 'nano-banana', provider: 'Nano Banana', modelName: 'nano-banana', type: 'Image', key: '', url: DEFAULT_BASE_URL },
            { id: 'nano-banana-2', provider: 'Nano Banana 2', modelName: 'nano-banana-2', type: 'Image', key: '', url: DEFAULT_BASE_URL },
            { id: 'gpt-image', provider: 'GPT-4o Image', modelName: 'gpt-4o-image', type: 'Image', key: '', url: DEFAULT_BASE_URL },
            { id: 'gemini-image', provider: 'Gemini Image', modelName: 'gemini-2.5-flash-image', type: 'Image', key: '', url: DEFAULT_BASE_URL },
            { id: 'qwen-image', provider: 'Qwen Image', modelName: 'qwen-image', type: 'Image', key: '', url: DEFAULT_BASE_URL },
            { id: 'doubao-seedream', provider: 'Doubao Seedream', modelName: 'doubao-seedream-3-0-t2i-250415', type: 'Image', key: '', url: DEFAULT_BASE_URL },
            { id: 'flux-kontext', provider: 'Flux Kontext', modelName: 'flux-kontext-pro', type: 'Image', key: '', url: DEFAULT_BASE_URL },
            { id: 'mj-v6', provider: 'Midjourney', modelName: 'MJ V6', type: 'Image', key: '', url: 'https://api.midjourney.com' },
            // 即梦模型（使用sessionid作为key，首次打开时为空，需要用户输入）
            { id: 'jimeng-4.5', provider: 'Jimeng 4.5', modelName: 'jimeng-4.5', type: 'Image', key: '', url: JIMENG_API_BASE_URL },
            { id: 'jimeng-4.1', provider: 'Jimeng 4.1', modelName: 'jimeng-4.1', type: 'Image', key: '', url: JIMENG_API_BASE_URL },
            { id: 'jimeng-3.1', provider: 'Jimeng 3.1', modelName: 'jimeng-3.1', type: 'Image', key: '', url: JIMENG_API_BASE_URL },
            
            // Video Models
            { id: 'sora-2', provider: 'Sora 2', modelName: 'sora-2', type: 'Video', key: '', url: DEFAULT_BASE_URL, durations: ['5s', '10s', '15s'] },
            { id: 'google-veo3', provider: 'Google Veo 3', modelName: 'veo3.1-components', type: 'Video', key: '', url: 'https://ai.t8star.cn', durations: ['8s'] },
            { id: 'grok-3', provider: 'Grok3 Video', modelName: 'grok-video-3', type: 'Video', key: '', url: 'https://ai.t8star.cn', durations: ['8s', '5s'] },
            { id: 'jimeng', provider: 'Jimeng', modelName: 'Jimeng-Video', type: 'Video', key: '', url: DEFAULT_BASE_URL, durations: ['5s', '10s'] },
            { id: 'hailuo-02', provider: 'Hailuo AI', modelName: 'MiniMax-Hailuo-02', type: 'Video', key: '', url: 'https://api.hailuo.ai', durations: ['6s'] },
            { id: 'kling-v1-6', provider: 'Kling v1.6', modelName: 'kling-v1-6', type: 'Video', key: '', url: DEFAULT_BASE_URL, durations: ['5s', '10s'] },
            { id: 'wan-2.5', provider: 'Wan Models', modelName: 'Wan 2.5', type: 'Video', key: '', url: 'https://api.wan.ai', durations: ['5s'] },
        ];

        const RATIOS = ['Auto', '1:1', '16:9', '9:16', '4:3', '3:4', '21:9', '3:2', '2:3'];
        const GROK_VIDEO_RATIOS = ['3:2', '2:3', '1:1'];
        const VIDEO_RES_OPTIONS = ['1080P', '720P'];

        const getRatiosForModel = (modelId) => {
            if (!modelId) return RATIOS;
            if (modelId.includes('grok')) return GROK_VIDEO_RATIOS;
            return RATIOS;
        };
        const RESOLUTIONS = ['Auto', '1K', '2K', '4K']; 
        // Midjourney版本列表
        const MJ_VERSIONS = [
            { label: 'MJ V7', value: '--v 7' },
            { label: 'MJ V6.1', value: '--v 6.1' },
            { label: 'MJ V6', value: '--v 6' },
            { label: 'MJ V5.2', value: '--v 5.2' },
            { label: 'MJ V5.1', value: '--v 5.1' },
            { label: 'Niji V6', value: '--niji 6' },
            { label: 'Niji V5', value: '--niji 5' },
            { label: 'Niji V4', value: '--niji 4' }
        ]; 

        // --- 辅助：计算真实分辨率 ---
        const calculateResolution = (ratio, baseResolution) => {
            let baseW = 1024;
            let baseH = 1024;
            
            if (baseResolution === '1080P') { baseW = 1920; baseH = 1080; }
            else if (baseResolution === '720P') { baseW = 1280; baseH = 720; }
            else if (baseResolution === '2K') { baseW = 2048; baseH = 2048; }
            else if (baseResolution === '4K') { baseW = 3840; baseH = 2160; }

            if (ratio === 'Auto') {
                return { str: `${baseW}x${baseH}`, w: baseW, h: baseH };
            }

            const [rW, rH] = ratio.split(':').map(Number);
            if (!rW || !rH) return { str: '1024x1024', w: 1024, h: 1024 };

            let targetW;
            let targetH;

            if (Math.abs(rW - rH) < 0.1) {
                targetW = baseW; targetH = baseH;
            } else if (rW > rH) {
                targetW = (baseResolution === 'Auto' || baseResolution === '1K') ? 1280 : baseW;
                targetH = Math.round(targetW * (rH / rW));
            } else {
                targetH = (baseResolution === 'Auto' || baseResolution === '1K') ? 1280 : baseW;
                targetW = Math.round(targetH * (rW / rH));
            }

            targetW = Math.round(targetW / 16) * 16;
            targetH = Math.round(targetH / 16) * 16;

            return { str: `${targetW}x${targetH}`, w: targetW, h: targetH };
        };

        const getModelParams = (modelId, ratio, resolution) => {
            const { str, w, h } = calculateResolution(ratio, resolution);
            if (modelId.includes('hailuo') || modelId.includes('minimax')) {
                return { sizeStr: resolution === '4K' ? '1080p' : '720p', w, h };
            }
            if (modelId.includes('jimeng') || modelId.includes('kling') || modelId.includes('veo')) {
                return { sizeStr: ratio, w, h };
            }
            if (modelId.includes('grok')) {
                // Grok 接口需要传 aspect_ratio，size 传比例字符串即可
                return { sizeStr: ratio, w, h };
            }
            return { sizeStr: str, w, h };
        };

        // --- Helper: Get Image Dimensions ---
        const getImageDimensions = (src) => {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = () => resolve({ w: img.naturalWidth, h: img.naturalHeight });
                img.onerror = () => reject(new Error("Failed to load image"));
                img.src = src;
            });
        };
        
        // --- Helper: Check if URL is video ---
        const isVideoUrl = (url) => {
            if (!url) return false;
            if (url.startsWith('data:video')) return true;
            if (url.includes('force_video_display=true')) return true;
            const ext = url.split('.').pop().split('?')[0].toLowerCase();
            return ['mp4', 'webm', 'ogg', 'mov'].includes(ext);
        };

        // --- Helper: Load Video Metadata ---
        const getVideoMetadata = (src) => {
            return new Promise((resolve, reject) => {
                const video = document.createElement('video');
                video.preload = 'metadata';
                video.muted = true;
                video.playsInline = true;
                video.onloadedmetadata = () => {
                    resolve({
                        duration: Number(video.duration) || 0,
                        w: video.videoWidth || 0,
                        h: video.videoHeight || 0,
                    });
                };
                video.onerror = () => reject(new Error('视频加载失败'));
                video.src = src;
            });
        };

        // --- Helper: Extract Key Frames from video using <video> + <canvas> ---
        const extractKeyFrames = (src, { fps = 2 } = {}) => {
            return new Promise((resolve, reject) => {
                const video = document.createElement('video');
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                video.muted = true;
                video.playsInline = true;
                video.crossOrigin = 'anonymous';
                video.src = src;
                const frames = [];

                const handleError = () => reject(new Error('视频抽帧失败'));
                video.onerror = handleError;

                video.onloadedmetadata = () => {
                    const duration = Number(video.duration) || 0;
                    if (!duration || !isFinite(duration)) {
                        reject(new Error('无法读取视频时长'));
                        return;
                    }
                    canvas.width = video.videoWidth || 1280;
                    canvas.height = video.videoHeight || 720;
                    const interval = 1 / Math.max(0.1, fps);
                    let current = 0;

                    const captureFrame = () => {
                        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                        frames.push({
                            time: Number(current.toFixed(2)),
                            url: canvas.toDataURL('image/jpeg', 0.82),
                        });
                        current += interval;
                        if (current <= duration) {
                            video.currentTime = Math.min(current, duration);
                        } else {
                            resolve(frames);
                        }
                    };

                    video.onseeked = captureFrame;
                    // 启动首次抽帧
                    video.currentTime = 0;
                };
            });
        };

        // --- Component: ImageCompareView (Beautified & Optimized) ---
        const ImageCompareView = ({ img1, img2 }) => {
            const [pos, setPos] = useState(50);
            const containerRef = useRef(null);
            const [isHovering, setIsHovering] = useState(false);

            const handleMove = (e) => {
                if (!containerRef.current) return;
                const rect = containerRef.current.getBoundingClientRect();
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const x = Math.max(0, Math.min(clientX - rect.left, rect.width));
                setPos((x / rect.width) * 100);
            };

            const displayImg1 = img1;
            const displayImg2 = img2 || img1; 

            if (!displayImg1) return (
                <div className="w-full h-full flex flex-col items-center justify-center text-zinc-500 bg-zinc-900/50 rounded-lg border border-zinc-800 border-dashed pointer-events-none">
                    <Split size={24} className="mb-2 opacity-50" />
                    <span className="text-xs font-medium">连接图片以对比</span>
                </div>
            );

            return (
                <div 
                    ref={containerRef}
                    className="relative w-full h-full cursor-col-resize overflow-hidden group rounded-lg select-none shadow-2xl border border-zinc-800 bg-[#09090b]"
                    onMouseMove={handleMove}
                    onTouchMove={handleMove}
                    onMouseEnter={() => setIsHovering(true)}
                    onMouseLeave={() => setIsHovering(false)}
                >
                    {/* Checkered Background */}
                    <div className="absolute inset-0 opacity-20 pointer-events-none" 
                         style={{ 
                             backgroundImage: 'conic-gradient(#333 90deg, transparent 90deg), conic-gradient(transparent 90deg, #333 90deg)', 
                             backgroundSize: '20px 20px', 
                             backgroundPosition: '0 0, 10px 10px' 
                         }} 
                    />
                    <img src={displayImg1} className="absolute inset-0 w-full h-full object-contain pointer-events-none select-none" draggable={false} />
                    <div 
                        className="absolute inset-0 w-full h-full overflow-hidden pointer-events-none select-none"
                        style={{ clipPath: `inset(0 0 0 ${pos}%)` }} 
                    >
                        <img src={displayImg2} className="absolute inset-0 w-full h-full object-contain" draggable={false} />
                    </div>
                    <div 
                        className="absolute top-0 bottom-0 w-0.5 bg-white/80 shadow-[0_0_10px_rgba(0,0,0,0.5)] pointer-events-none"
                        style={{ left: `${pos}%` }}
                    >
                        <div className="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 w-6 h-6 bg-white rounded-full shadow-lg flex items-center justify-center text-black">
                            <Split size={12} className="rotate-90" />
                        </div>
                    </div>
                    <div className={`absolute bottom-2 left-2 bg-black/70 text-white text-[10px] font-medium px-2 py-0.5 rounded border border-white/10 transition-opacity duration-200 pointer-events-none ${isHovering ? 'opacity-100' : 'opacity-60'}`}>
                        原始
                    </div>
                    <div className={`absolute bottom-2 right-2 bg-blue-600/80 text-white text-[10px] font-medium px-2 py-0.5 rounded border border-white/10 transition-opacity duration-200 pointer-events-none ${isHovering ? 'opacity-100' : 'opacity-60'}`}>
                        生成
                    </div>
                </div>
            );
        };

        // --- 辅助组件 ---
        const Button = ({ children, onClick, className = '', variant = 'primary', icon: Icon, disabled = false, title = '' }) => {
            const baseStyle = 'flex items-center justify-center px-3 py-1.5 rounded-lg transition-all duration-200 font-medium text-xs select-none disabled:opacity-50 disabled:cursor-not-allowed';
            const variants = {
                primary: 'bg-blue-600 hover:bg-blue-500 text-white shadow-lg shadow-blue-900/20 active:scale-95',
                secondary: 'bg-zinc-800 hover:bg-zinc-700 text-zinc-300 border border-zinc-700 active:scale-95',
                ghost: 'bg-transparent hover:bg-zinc-800 text-zinc-400 hover:text-white',
                danger: 'bg-red-900/30 hover:bg-red-800 text-red-200 border border-red-800 active:scale-95',
            };
            return (
                <button onClick={onClick} disabled={disabled} className={`${baseStyle} ${variants[variant]} ${className}`} title={title}>
                    {Icon && <Icon size={14} className={children ? 'mr-1.5' : ''} />}
                    {children}
                </button>
            );
        };

        // --- 性能优化工具函数 ---
        const debounce = (func, wait) => {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        };

        const Modal = ({ isOpen, onClose, title, children, theme = 'dark' }) => {
            if (!isOpen) return null;
            const isDark = theme === 'dark';
            return (
                <div className="fixed inset-0 z-[100] flex items-center justify-center bg-black/60 backdrop-blur-sm" onClick={onClose}>
                    <div
                        className={`rounded-xl shadow-2xl w-[680px] max-w-[90vw] overflow-hidden animate-in fade-in zoom-in-95 duration-200 flex flex-col max-h-[85vh] border ${
                            isDark ? 'bg-[#09090b] border-zinc-800' : 'bg-white border-zinc-200'
                        }`}
                        onClick={(e) => e.stopPropagation()}
                    >
                        <div
                            className={`flex items-center justify-between p-5 border-b shrink-0 ${
                                isDark ? 'border-zinc-800/50' : 'border-zinc-200'
                            }`}
                        >
                            <h3 className={`font-bold text-lg ${isDark ? 'text-white' : 'text-zinc-900'}`}>{title}</h3>
                            <button
                                onClick={onClose}
                                className={isDark ? 'text-zinc-500 hover:text-white' : 'text-zinc-500 hover:text-zinc-900'}
                            >
                                <X size={20} />
                            </button>
                        </div>
                        <div className={`p-0 overflow-y-auto custom-scrollbar flex-1 ${isDark ? 'bg-[#09090b]' : 'bg-white'}`}>
                            {children}
                        </div>
                    </div>
                </div>
            );
        };

        const Lightbox = ({ item, onClose, onNavigate }) => {
            if (!item) return null;
            
            // 使用ref存储最新的item值，避免闭包问题
            const itemRef = useRef(item);
            useEffect(() => {
                itemRef.current = item;
            }, [item]);
            
            // 键盘事件处理：左右方向键切换图片
            useEffect(() => {
                if (!item) return;
                
                const handleKeyDown = (e) => {
                    // 使用ref获取最新的item值
                    const currentItem = itemRef.current;
                    if (!currentItem) return;
                    
                    // 只在有多张图片时响应方向键
                    if (!currentItem.mjImages || currentItem.mjImages.length <= 1) return;
                    
                    // 防止在输入框中触发
                    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
                    
                    if (e.key === 'ArrowLeft' || e.key === 'Left') {
                        e.preventDefault();
                        e.stopPropagation();
                        // 切换到上一张（只在当前item的mjImages范围内）
                        const currentIndex = currentItem.selectedMjImageIndex !== undefined ? currentItem.selectedMjImageIndex : 0;
                        const prevIndex = currentIndex > 0 ? currentIndex - 1 : currentItem.mjImages.length - 1;
                        // 确保索引在有效范围内，并且只操作当前item的mjImages
                        if (prevIndex >= 0 && prevIndex < currentItem.mjImages.length && onNavigate) {
                            onNavigate(prevIndex);
                        }
                    } else if (e.key === 'ArrowRight' || e.key === 'Right') {
                        e.preventDefault();
                        e.stopPropagation();
                        // 切换到下一张（只在当前item的mjImages范围内）
                        const currentIndex = currentItem.selectedMjImageIndex !== undefined ? currentItem.selectedMjImageIndex : 0;
                        const nextIndex = currentIndex < currentItem.mjImages.length - 1 ? currentIndex + 1 : 0;
                        // 确保索引在有效范围内，并且只操作当前item的mjImages
                        if (nextIndex >= 0 && nextIndex < currentItem.mjImages.length && onNavigate) {
                            onNavigate(nextIndex);
                        }
                    }
                };
                
                window.addEventListener('keydown', handleKeyDown);
                return () => {
                    window.removeEventListener('keydown', handleKeyDown);
                };
            }, [item, onNavigate]);
            
            return (
                <div className="fixed inset-0 z-[200] lightbox-overlay flex flex-col items-center justify-center animate-in fade-in duration-200" onClick={onClose}>
                    <button className="absolute top-4 right-4 text-white/70 hover:text-white p-2 bg-black/50 rounded-full transition-colors" onClick={onClose}><X size={24} /></button>
                    <div className="max-w-[90vw] max-h-[85vh] relative" onClick={(e) => e.stopPropagation()}>
                        {item.type === 'image' ? (
                            <img src={item.url} alt={item.prompt} className="max-w-full max-h-[85vh] rounded-lg shadow-2xl object-contain" />
                        ) : (
                            <video src={item.url} controls autoPlay className="max-w-full max-h-[85vh] rounded-lg shadow-2xl" />
                        )}
                        <div className="absolute bottom-8 left-1/2 -translate-x-1/2 bg-black/60 backdrop-blur-md px-6 py-3 rounded-full text-white text-sm font-medium border border-white/10 text-center shadow-2xl">
                            <div className="line-clamp-1 max-w-xl">{item.prompt}</div>
                            <div className="text-[10px] text-zinc-400 mt-1">
                                {item.width}x{item.height} • {item.modelName}
                                {item.mjImages && item.mjImages.length > 1 && (
                                    <span className="ml-2">({(item.selectedMjImageIndex !== undefined ? item.selectedMjImageIndex : 0) + 1}/{item.mjImages.length})</span>
                                )}
                            </div>
                        </div>
                        {/* 左右切换提示 */}
                        {item.mjImages && item.mjImages.length > 1 && (
                            <>
                                <button
                                    className="absolute left-4 top-1/2 -translate-y-1/2 text-white/70 hover:text-white p-3 bg-black/50 rounded-full transition-colors"
                                    onClick={(e) => {
                                        e.stopPropagation();
                                        const currentIndex = item.selectedMjImageIndex !== undefined ? item.selectedMjImageIndex : 0;
                                        const prevIndex = currentIndex > 0 ? currentIndex - 1 : item.mjImages.length - 1;
                                        if (onNavigate) onNavigate(prevIndex);
                                    }}
                                    title="上一张 (←)"
                                >
                                    <ChevronLeft size={24} />
                                </button>
                                <button
                                    className="absolute right-4 top-1/2 -translate-y-1/2 text-white/70 hover:text-white p-3 bg-black/50 rounded-full transition-colors"
                                    onClick={(e) => {
                                        e.stopPropagation();
                                        const currentIndex = item.selectedMjImageIndex !== undefined ? item.selectedMjImageIndex : 0;
                                        const nextIndex = currentIndex < item.mjImages.length - 1 ? currentIndex + 1 : 0;
                                        if (onNavigate) onNavigate(nextIndex);
                                    }}
                                    title="下一张 (→)"
                                >
                                    <ChevronRight size={24} />
                                </button>
                            </>
                        )}
                    </div>
                </div>
            );
        };

        function TapnowApp() {
            const [theme, setTheme] = useState(() => {
                try {
                    return localStorage.getItem('tapnow_theme') || 'dark';
                } catch (e) {
                    return 'dark';
                }
            });

            useEffect(() => {
                const styleSheet = document.createElement('style');
                styleSheet.innerText = styles;
                document.head.appendChild(styleSheet);
                return () => { document.head.removeChild(styleSheet); };
            }, []);

            useEffect(() => {
                try {
                    localStorage.setItem('tapnow_theme', theme);
                } catch (e) {}
                const root = document.documentElement;
                if (theme === 'dark') {
                    root.classList.add('theme-dark');
                    root.classList.remove('theme-light');
                    document.body.style.backgroundColor = '#09090b';
                } else {
                    root.classList.add('theme-light');
                    root.classList.remove('theme-dark');
                    document.body.style.backgroundColor = '#f4f4f5';
                }
            }, [theme]);

            const [nodes, setNodes] = useState([]);
            const [connections, setConnections] = useState([]);
            const [view, setView] = useState({ x: 0, y: 0, zoom: 1 });
            const [selectedNodeId, setSelectedNodeId] = useState(null);

            const [apiConfigs, setApiConfigs] = useState(() => {
                const saved = localStorage.getItem('tapnow_api_configs');
                let configs = saved ? JSON.parse(saved) : DEFAULT_API_CONFIGS;
                
                // 过滤掉jimeng-4.5配置（如果存在）
                configs = configs.filter(c => c.id !== 'jimeng-4.5');
                
                // 从localStorage读取保存的Session ID
                // 第一次打开时如果没有保存的Session ID，使用空字符串（需要用户输入）
                // 如果有保存的Session ID，则使用保存的值
                const savedSessionId = localStorage.getItem('tapnow_jimeng_session_id');
                const sessionIdToUse = savedSessionId || ''; // 如果没有保存的，使用空字符串，让用户输入
                
                // 确保即梦模型存在（如果不存在则添加）
                const hasJimeng45 = configs.some(c => c.id === 'jimeng-4.5');
                const hasJimeng41 = configs.some(c => c.id === 'jimeng-4.1');
                const hasJimeng31 = configs.some(c => c.id === 'jimeng-3.1');
                
                if (!hasJimeng45 || !hasJimeng41 || !hasJimeng31) {
                    // 找到即梦模型在默认配置中的位置（在Midjourney之后）
                    const mjIndex = configs.findIndex(c => c.id === 'mj-v6');
                    const insertIndex = mjIndex >= 0 ? mjIndex + 1 : configs.length;
                    
                    if (!hasJimeng45) {
                        configs.splice(insertIndex, 0, { id: 'jimeng-4.5', provider: 'Jimeng 4.5', modelName: 'jimeng-4.5', type: 'Image', key: sessionIdToUse, url: JIMENG_API_BASE_URL });
                    }
                    if (!hasJimeng41) {
                        const jimeng45Index = configs.findIndex(c => c.id === 'jimeng-4.5');
                        const nextIndex = jimeng45Index >= 0 ? jimeng45Index + 1 : insertIndex;
                        configs.splice(nextIndex, 0, { id: 'jimeng-4.1', provider: 'Jimeng 4.1', modelName: 'jimeng-4.1', type: 'Image', key: sessionIdToUse, url: JIMENG_API_BASE_URL });
                    }
                    if (!hasJimeng31) {
                        const jimeng41Index = configs.findIndex(c => c.id === 'jimeng-4.1');
                        const nextIndex = jimeng41Index >= 0 ? jimeng41Index + 1 : insertIndex + 1;
                        configs.splice(nextIndex, 0, { id: 'jimeng-3.1', provider: 'Jimeng 3.1', modelName: 'jimeng-3.1', type: 'Image', key: sessionIdToUse, url: JIMENG_API_BASE_URL });
                    }
                } else {
                    // 如果模型已存在，更新所有jimeng模型的Session ID
                    // 如果有保存的Session ID，使用保存的值；如果没有，使用空字符串（让用户输入）
                    configs = configs.map(c => 
                        (c.id.includes('jimeng') || c.provider?.includes('Jimeng'))
                            ? { ...c, key: sessionIdToUse }
                            : c
                    );
                }
                
                // 确保 Grok-3 Video 模型存在（兼容旧的本地存储配置）
                const hasGrok3 = configs.some(c => c.id === 'grok-3');
                if (!hasGrok3) {
                    const firstVideoIndex = configs.findIndex(c => c.type === 'Video');
                    const insertIndex = firstVideoIndex >= 0 ? firstVideoIndex : configs.length;
                    configs.splice(insertIndex, 0, { id: 'grok-3', provider: 'Grok3 Video', modelName: 'grok-video-3', type: 'Video', key: '', url: 'https://ai.t8star.cn', durations: ['8s', '5s'] });
                }
                
                return configs;
            });
            const [globalApiKey, setGlobalApiKey] = useState(() => localStorage.getItem('tapnow_global_key') || '');
            
            // 即梦图生图使用本地文件设置（默认true，强制使用本地文件而不是URL）
            const [jimengUseLocalFile, setJimengUseLocalFile] = useState(() => {
                const saved = localStorage.getItem('tapnow_jimeng_use_local_file');
                return saved !== null ? saved === 'true' : true; // 默认true
            });

            const [history, setHistory] = useState(() => {
                try {
                const saved = localStorage.getItem('tapnow_history');
                    if (!saved) return [];
                    const parsed = JSON.parse(saved);
                    // 检查是否有需要重新切割的Midjourney图片
                    return parsed.map(item => {
                        if (item.mjNeedsSplit && item.mjOriginalUrl && item.apiConfig?.modelId?.includes('mj')) {
                            // 标记需要重新切割，但不立即切割（避免阻塞初始化）
                            return { ...item, url: item.mjOriginalUrl, mjImages: null, mjNeedsSplit: true };
                        }
                        return item;
                    });
                } catch (e) {
                    console.error('加载历史记录失败:', e);
                    return [];
                }
            });
            
            const [chatSessions, setChatSessions] = useState(() => {
                try {
                    const saved = localStorage.getItem('tapnow_chat_sessions');
                    return saved ? JSON.parse(saved) : [{ id: 'default', title: '新对话', messages: [] }];
                } catch (e) {
                    return [{ id: 'default', title: '新对话', messages: [] }];
                }
            });
            const [currentChatId, setCurrentChatId] = useState('default');
            const [chatInput, setChatInput] = useState('');
            const [isChatOpen, setIsChatOpen] = useState(false);
            const [chatWidth, setChatWidth] = useState(400); 
            const [chatFiles, setChatFiles] = useState([]); 
            const [chatModel, setChatModel] = useState('gemini-3-pro');
            const [isChatSending, setIsChatSending] = useState(false);

            const [lightboxItem, setLightboxItem] = useState(null);

            // State management
            const [isPanning, setIsPanning] = useState(false);
            const [isDragging, setIsDragging] = useState(false);
            const [dragNodeId, setDragNodeId] = useState(null);
            const [resizingNodeId, setResizingNodeId] = useState(null);
            const [connectingSource, setConnectingSource] = useState(null);
            const [connectingTarget, setConnectingTarget] = useState(null); // 从输入端口开始的连接目标节点ID
            const [connectingInputType, setConnectingInputType] = useState(null); // 'default', 'oref', 'sref'
            const [mousePos, setMousePos] = useState({ x: 0, y: 0 });
            const [hoverTargetId, setHoverTargetId] = useState(null);

            // 框选相关状态
            const [isSelecting, setIsSelecting] = useState(false);
            const [selectionBox, setSelectionBox] = useState(null); // { startX, startY, endX, endY } (屏幕坐标)
            const [selectedNodeIds, setSelectedNodeIds] = useState(new Set()); // 多选节点ID集合

            const [contextMenu, setContextMenu] = useState({ x: 0, y: 0, worldX: 0, worldY: 0, visible: false });
            const [historyContextMenu, setHistoryContextMenu] = useState({ visible: false, x: 0, y: 0, item: null });
            const [frameContextMenu, setFrameContextMenu] = useState({ visible: false, x: 0, y: 0, nodeId: null, frame: null });
            const [settingsOpen, setSettingsOpen] = useState(false);
            const [historyOpen, setHistoryOpen] = useState(false);
            const [batchModalOpen, setBatchModalOpen] = useState(false);
            const [batchSelectedIds, setBatchSelectedIds] = useState(new Set());
            const [chatSessionDropdownOpen, setChatSessionDropdownOpen] = useState(false);
            const [activeTool, setActiveTool] = useState('select');
            const [activeDropdown, setActiveDropdown] = useState(null);
            const [apiTesting, setApiTesting] = useState(null);
            const [apiStatus, setApiStatus] = useState({});
            // 实时计时器状态：nodeId -> elapsedSeconds
            const [nodeTimers, setNodeTimers] = useState({});

            const canvasRef = useRef(null);
            const lastMousePos = useRef({ x: 0, y: 0 });
            const chatEndRef = useRef(null);
            const nodesRef = useRef(nodes);
            const selectedNodeIdRef = useRef(selectedNodeId);
            const selectedNodeIdsRef = useRef(selectedNodeIds); // 存储多选节点ID的ref
            const connectionsRef = useRef(connections);
            const frameSelectionRef = useRef({});

            useEffect(() => { 
                // 保存时过滤掉jimeng-4.5配置
                const filteredConfigs = apiConfigs.filter(c => c.id !== 'jimeng-4.5');
                localStorage.setItem('tapnow_api_configs', JSON.stringify(filteredConfigs)); 
            }, [apiConfigs]);
            
            // 全局 Delete 键删除节点
            useEffect(() => {
                const handleDeleteKey = (e) => {
                    // 防止在输入框中触发
                    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.isContentEditable) return;
                    
                    // 检查是否按下了 Delete 或 Del 键
                    if (e.key === 'Delete' || e.key === 'Del') {
                        e.preventDefault();
                        e.stopPropagation();
                        
                        const currentSelectedId = selectedNodeIdRef.current;
                        const currentSelectedIds = selectedNodeIdsRef.current;
                        
                        // 删除选中的节点
                        if (currentSelectedId) {
                            deleteNode(currentSelectedId);
                            setSelectedNodeId(null);
                        } else if (currentSelectedIds && currentSelectedIds.size > 0) {
                            // 删除多选节点
                            currentSelectedIds.forEach(id => deleteNode(id));
                            setSelectedNodeIds(new Set());
                        }
                    }
                };
                
                window.addEventListener('keydown', handleDeleteKey);
                return () => {
                    window.removeEventListener('keydown', handleDeleteKey);
                };
            }, []);
            // localStorage 写入防抖函数
            const debouncedSaveHistory = useMemo(() => debounce((historyToSave) => {
                try {
                    localStorage.setItem('tapnow_history', JSON.stringify(historyToSave));
                } catch (e) {
                    console.error('保存历史记录失败（可能超出存储配额）:', e);
                    // 如果存储失败，尝试减少数据量
                    try {
                        const reduced = historyToSave.map(item => ({
                            id: item.id,
                            type: item.type,
                            url: item.url,
                            prompt: item.prompt?.substring(0, 200) || '',
                            time: item.time,
                            status: item.status,
                            modelName: item.modelName,
                            width: item.width,
                            height: item.height,
                            ratio: item.ratio,
                            mjImages: item.mjImages,
                            selectedMjImageIndex: item.selectedMjImageIndex,
                            mjRatio: item.mjRatio,
                            mjNeedsSplit: item.mjNeedsSplit,
                            mjImageInfo: item.mjImageInfo
                        }));
                        localStorage.setItem('tapnow_history', JSON.stringify(reduced));
                    } catch (e2) {
                        console.error('减少数据后保存也失败:', e2);
                        try {
                            // 最小化保存：只保留必要字段
                            const minimal = historyToSave.map(item => ({
                                id: item.id,
                                type: item.type,
                                url: item.url,
                                prompt: item.prompt?.substring(0, 100) || '',
                                time: item.time,
                                status: item.status,
                                modelName: item.modelName
                            }));
                            debouncedSaveHistory(minimal);
                        } catch (e3) {
                            console.error('最小化保存也失败:', e3);
                        }
                    }
                }
            }, 1000), []);

            const debouncedSaveGlobalKey = useMemo(() => debounce((key) => {
                localStorage.setItem('tapnow_global_key', key);
            }, 1000), []);

            useEffect(() => { debouncedSaveGlobalKey(globalApiKey); }, [globalApiKey, debouncedSaveGlobalKey]);
            
            // 优化localStorage存储，处理配额超限问题
            useEffect(() => {
                try {
                    // 只存储必要的元数据，不存储完整的base64图片和长URL
                    const historyToSave = history.map(item => {
                        const saved = { ...item };
                        // 如果是Midjourney切割后的图片，只保存标记和原图URL，不保存完整的base64数组
                        if (item.mjImages && item.mjImages.length === 4) {
                            // 保存切割标记和原图URL，切割后的图片在需要时重新生成
                            saved.mjImages = null; // 不保存base64数组
                            saved.mjNeedsSplit = true; // 标记需要重新切割
                            saved.mjOriginalUrl = item.mjOriginalUrl || item.url; // 保存原图URL
                        }
                        // 如果URL是data URL且太长，只保存前100个字符作为标记
                        if (item.url && item.url.startsWith('data:') && item.url.length > 5000) {
                            saved.url = item.url.substring(0, 100) + '...'; // 只保存前100个字符
                        }
                        // 移除不必要的字段，减少存储大小
                        delete saved.mjImageInfo; // 不保存图片信息
                        return saved;
                    });
                    debouncedSaveHistory(historyToSave);
                } catch (e) {
                    console.error('保存历史记录失败（可能超出存储配额）:', e);
                    // 如果存储失败，尝试清理旧数据，只保留最近20条
                    try {
                        const reduced = history.slice(0, 20).map(item => {
                            const saved = { ...item };
                            // 移除所有可能很大的字段
                            if (saved.url && saved.url.startsWith('data:')) {
                                saved.url = saved.url.substring(0, 100) + '...';
                            }
                            if (saved.mjImages) saved.mjImages = null;
                            if (saved.mjImageInfo) delete saved.mjImageInfo;
                            return saved;
                        });
                        debouncedSaveHistory(reduced);
                    } catch (e2) {
                        console.error('清理后仍无法保存:', e2);
                        // 最后尝试：只保存最基本的字段
                        try {
                            const minimal = history.slice(0, 10).map(item => ({
                                id: item.id,
                                type: item.type,
                                prompt: item.prompt?.substring(0, 100),
                                time: item.time,
                                status: item.status,
                                modelName: item.modelName
                            }));
                            debouncedSaveHistory(minimal);
                        } catch (e3) {
                            console.error('最小化保存也失败:', e3);
                        }
                    }
                }
            }, [history, debouncedSaveHistory]);
            const debouncedSaveChatSessions = useMemo(() => debounce((sessions) => {
                try { localStorage.setItem('tapnow_chat_sessions', JSON.stringify(sessions)); } catch (e) {}
            }, 1000), []);
            useEffect(() => { debouncedSaveChatSessions(chatSessions); }, [chatSessions, debouncedSaveChatSessions]);
            useEffect(() => { 
                nodesRef.current = nodes; 
                selectedNodeIdRef.current = selectedNodeId;
                selectedNodeIdsRef.current = selectedNodeIds; // 同步更新多选节点ref
                connectionsRef.current = connections; 
            }, [nodes, selectedNodeId, selectedNodeIds, connections]);

            // 使用 useMemo 创建 nodes Map，优化节点查找性能（O(1) 查找）
            const nodesMap = useMemo(() => {
                const map = new Map();
                nodes.forEach(node => {
                    map.set(node.id, node);
                });
                return map;
            }, [nodes]);

            // 使用 useMemo 缓存连接相关的计算，避免重复计算
            const connectionsByNode = useMemo(() => {
                const byNode = {
                    to: new Map(), // nodeId -> connections[]
                    from: new Map() // nodeId -> connections[]
                };
                connections.forEach(conn => {
                    if (!byNode.to.has(conn.to)) {
                        byNode.to.set(conn.to, []);
                    }
                    byNode.to.get(conn.to).push(conn);
                    
                    if (!byNode.from.has(conn.from)) {
                        byNode.from.set(conn.from, []);
                    }
                    byNode.from.get(conn.from).push(conn);
                });
                return byNode;
            }, [connections]);
            
            // 实时更新节点计时器
            useEffect(() => {
                const interval = setInterval(() => {
                    const now = Date.now();
                    const activeTasks = history.filter(h => 
                        h.sourceNodeId && 
                        h.status === 'generating' && 
                        h.startTime
                    );
                    
                    const newTimers = {};
                    activeTasks.forEach(task => {
                        const elapsed = Math.floor((now - task.startTime) / 100);
                        newTimers[task.sourceNodeId] = elapsed / 10; // 转换为秒，保留1位小数
                    });
                    
                    setNodeTimers(newTimers);
                }, 100); // 每100ms更新一次
                
                return () => clearInterval(interval);
            }, [history]);
            
            // 检查并重新切割需要切割的Midjourney图片（使用useRef避免重复切割）
            const splittingRef = useRef(new Set());
            useEffect(() => {
                history.forEach(item => {
                    if (item.mjNeedsSplit && item.mjOriginalUrl && item.apiConfig?.modelId?.includes('mj') && item.status === 'completed') {
                        // 避免重复切割
                        if (splittingRef.current.has(item.id)) {
                            return;
                        }
                        splittingRef.current.add(item.id);
                        
                        // 延迟切割，避免阻塞UI
                        setTimeout(() => {
                            // 获取比例信息
                            let ratio = item.mjRatio || '1:1';
                            if (item.prompt && item.prompt.includes('--ar ')) {
                                const arMatch = item.prompt.match(/--ar\s+([\d:]+)/);
                                if (arMatch && arMatch[1]) {
                                    ratio = arMatch[1];
                                }
                            }
                            
                            console.log(`Midjourney: 开始重新切割图片，任务ID: ${item.id}, 比例: ${ratio}`);
                            
                            // 重新切割图片
                            splitMidjourneyImage(item.mjOriginalUrl, ratio).then((splitImages) => {
                                const imageUrls = splitImages.map(img => typeof img === 'string' ? img : img.url);
                                const firstImage = splitImages[0];
                                const firstUrl = typeof firstImage === 'string' ? firstImage : firstImage.url;
                                
                                setHistory((prev) => prev.map((hItem) => 
                                    hItem.id === item.id 
                                        ? { 
                                            ...hItem, 
                                            mjImages: imageUrls, 
                                            url: firstUrl, 
                                            selectedMjImageIndex: 0,
                                            mjRatio: ratio,
                                            mjNeedsSplit: false, // 标记已切割
                                            mjImageInfo: splitImages.map(img => typeof img === 'string' ? null : { width: img.width, height: img.height, ratio: img.ratio })
                                        } 
                                        : hItem
                                ));
                                
                                splittingRef.current.delete(item.id);
                                console.log(`Midjourney: 重新切割完成，任务ID: ${item.id}`);
                            }).catch((err) => {
                                console.error('Midjourney: 重新切割图片失败:', err);
                                splittingRef.current.delete(item.id);
                                // 保持原图显示，标记需要重新切割
                                setHistory((prev) => prev.map((hItem) => 
                                    hItem.id === item.id 
                                        ? { ...hItem, mjNeedsSplit: true } 
                                        : hItem
                                ));
                            });
                        }, 500); // 延迟500ms，确保UI已完全渲染
                    }
                });
            }, [history]);

            const handleChatResizeStart = (e) => { e.preventDefault(); setIsResizingChat(true); }; 
            const [isResizingChat, setIsResizingChat] = useState(false);

            const handleChatResizeMove = useCallback((e) => {
                if (!isResizingChat) return;
                const newWidth = window.innerWidth - e.clientX;
                setChatWidth(Math.max(300, Math.min(newWidth, 800)));
            }, [isResizingChat]);

            const handleChatResizeEnd = useCallback(() => {
                setIsResizingChat(false);
            }, []);

            useEffect(() => {
                if (isResizingChat) {
                    window.addEventListener('mousemove', handleChatResizeMove);
                    window.addEventListener('mouseup', handleChatResizeEnd);
                } else {
                    window.removeEventListener('mousemove', handleChatResizeMove);
                    window.removeEventListener('mouseup', handleChatResizeEnd);
                }
                return () => {
                    window.removeEventListener('mousemove', handleChatResizeMove);
                    window.removeEventListener('mouseup', handleChatResizeEnd);
                };
            }, [isResizingChat, handleChatResizeMove, handleChatResizeEnd]);

            const screenToWorld = useCallback((sx, sy) => {
                const rect = canvasRef.current?.getBoundingClientRect();
                const localX = rect ? sx - rect.left : sx;
                const localY = rect ? sy - rect.top : sy;
                return { x: (localX - view.x) / view.zoom, y: (localY - view.y) / view.zoom };
            }, [view]);

            const handleWheel = (e) => {
                // 检查鼠标是否在视频输入或视频拆解节点内
                const target = e.target;
                let isInsideNode = false;
                let scrollableElement = null;
                
                // 向上查找父元素，检查是否在 video-input 或 video-analyze 节点内
                let current = target;
                while (current && current !== e.currentTarget) {
                    if (current.classList) {
                        // 检查当前元素或父元素是否包含节点容器类
                        if (current.classList.contains('video-input-container') || 
                            current.classList.contains('video-analyze-container')) {
                            isInsideNode = true;
                            // 在当前容器内查找可滚动的元素
                            scrollableElement = current.querySelector('.overflow-y-auto, .custom-scrollbar, [class*="overflow-y"]');
                            if (!scrollableElement) {
                                // 如果没找到，检查当前元素本身是否可滚动
                                const style = window.getComputedStyle(current);
                                if (style.overflowY === 'auto' || style.overflowY === 'scroll' || 
                                    current.classList.contains('custom-scrollbar')) {
                                    scrollableElement = current;
                                }
                            }
                            break;
                        }
                        // 使用 closest 方法查找最近的容器
                        const container = current.closest('.video-input-container, .video-analyze-container');
                        if (container) {
                            isInsideNode = true;
                            scrollableElement = container.querySelector('.overflow-y-auto, .custom-scrollbar, [class*="overflow-y"]');
                            if (!scrollableElement) {
                                const style = window.getComputedStyle(container);
                                if (style.overflowY === 'auto' || style.overflowY === 'scroll') {
                                    scrollableElement = container;
                                }
                            }
                            break;
                        }
                    }
                    current = current.parentElement;
                }
                
                // 如果在节点内且找到可滚动元素，则滚动该元素而不是缩放画布
                if (isInsideNode && scrollableElement) {
                    e.preventDefault();
                    e.stopPropagation();
                    const maxScroll = scrollableElement.scrollHeight - scrollableElement.clientHeight;
                    const currentScroll = scrollableElement.scrollTop;
                    const newScroll = Math.max(0, Math.min(maxScroll, currentScroll + e.deltaY));
                    scrollableElement.scrollTop = newScroll;
                    return;
                }
                
                // 否则正常缩放画布
                e.preventDefault();
                const rect = e.currentTarget.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                setView((prev) => {
                    const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
                    let newZoom = Math.min(Math.max(prev.zoom * zoomFactor, 0.2), 3);
                    const scale = newZoom / prev.zoom;
                    return { zoom: newZoom, x: mouseX - (mouseX - prev.x) * scale, y: mouseY - (mouseY - prev.y) * scale };
                });
            };

            const handleMouseDown = (e) => {
                if (e.button === 0 || e.button === 1) {
                    if (e.currentTarget.id === 'canvas-bg') {
                        // 检测Ctrl+鼠标左键，开始框选
                        if (e.button === 0 && (e.ctrlKey || e.metaKey)) {
                            e.preventDefault();
                            setIsSelecting(true);
                            setIsPanning(false);
                            const rect = canvasRef.current?.getBoundingClientRect();
                            const startX = e.clientX - (rect?.left || 0);
                            const startY = e.clientY - (rect?.top || 0);
                            setSelectionBox({ startX, startY, endX: startX, endY: startY });
                            setSelectedNodeIds(new Set()); // 清空之前的选择
                            setSelectedNodeId(null);
                            return;
                        }
                        // 普通拖动画布
                        setIsPanning(true);
                        setIsDragging(false);
                        lastMousePos.current = { x: e.clientX, y: e.clientY };
                    }
                }
            };

            const nodeUpdateRef = useRef(null);
            const nodeUpdateRaf = useRef(null);
            const multiNodeUpdateRef = useRef(null); // 多节点更新ref

            const flushNodeUpdate = useCallback(() => {
                // 优先处理多节点更新
                if (multiNodeUpdateRef.current) {
                    const updates = multiNodeUpdateRef.current;
                    setNodes((prev) => {
                        const next = [...prev];
                        let hasChanges = false;
                        updates.forEach(({ nodeId, updater }) => {
                            const idx = next.findIndex((n) => n.id === nodeId);
                            if (idx !== -1) {
                                const updatedNode = updater(next[idx]);
                                if (updatedNode !== next[idx]) {
                                    next[idx] = updatedNode;
                                    hasChanges = true;
                                }
                            }
                        });
                        return hasChanges ? next : prev;
                    });
                    multiNodeUpdateRef.current = null;
                    nodeUpdateRaf.current = null;
                    return;
                }
                
                if (!nodeUpdateRef.current) {
                    nodeUpdateRaf.current = null;
                    return;
                }
                const { nodeId, updater } = nodeUpdateRef.current;
                setNodes((prev) => {
                    const idx = prev.findIndex((n) => n.id === nodeId);
                    if (idx === -1) return prev;
                    // 使用函数式更新，避免创建新数组的开销
                    const updatedNode = updater(prev[idx]);
                    // 如果节点没有变化，直接返回原数组（引用相等检查）
                    if (updatedNode === prev[idx]) return prev;
                    const next = [...prev];
                    next[idx] = updatedNode;
                    return next;
                });
                nodeUpdateRef.current = null;
                nodeUpdateRaf.current = null;
            }, []);

            const scheduleNodeUpdate = useCallback((nodeId, updater) => {
                nodeUpdateRef.current = { nodeId, updater };
                if (!nodeUpdateRaf.current) {
                    nodeUpdateRaf.current = requestAnimationFrame(flushNodeUpdate);
                }
            }, [flushNodeUpdate]);

            const scheduleMultiNodeUpdate = useCallback((updates) => {
                multiNodeUpdateRef.current = updates;
                if (!nodeUpdateRaf.current) {
                    nodeUpdateRaf.current = requestAnimationFrame(flushNodeUpdate);
                }
            }, [flushNodeUpdate]);

            useEffect(() => {
                return () => {
                    if (nodeUpdateRaf.current) {
                        cancelAnimationFrame(nodeUpdateRaf.current);
                    }
                };
            }, []);

            // 使用 requestAnimationFrame 节流框选逻辑
            const selectionRafRef = useRef(null);
            const pendingSelectionUpdate = useRef(null);

            const handleMouseMove = useCallback((e) => {
                const { clientX, clientY } = e;
                const worldPos = screenToWorld(clientX, clientY);
                setMousePos(worldPos);

                // 框选模式 - 使用 requestAnimationFrame 节流
                if (isSelecting) {
                    const rect = canvasRef.current?.getBoundingClientRect();
                    const endX = clientX - (rect?.left || 0);
                    const endY = clientY - (rect?.top || 0);
                    
                    // 立即更新框选框位置（视觉反馈）
                    setSelectionBox(prev => {
                        if (!prev) return null;
                        return { ...prev, endX, endY };
                    });
                    
                    // 节流节点选择计算
                    pendingSelectionUpdate.current = { endX, endY, rect };
                    
                    if (!selectionRafRef.current) {
                        selectionRafRef.current = requestAnimationFrame(() => {
                            if (!pendingSelectionUpdate.current) {
                                selectionRafRef.current = null;
                                return;
                            }
                            
                            const { endX, endY, rect } = pendingSelectionUpdate.current;
                            const currentSelectionBox = selectionBox;
                            if (!currentSelectionBox) {
                                selectionRafRef.current = null;
                                return;
                            }
                            
                            // 计算被框选的节点
                            const boxStartX = Math.min(currentSelectionBox.startX, endX);
                            const boxStartY = Math.min(currentSelectionBox.startY, endY);
                            const boxEndX = Math.max(currentSelectionBox.startX, endX);
                            const boxEndY = Math.max(currentSelectionBox.startY, endY);
                            
                            // 将屏幕坐标转换为世界坐标
                            const worldStart = screenToWorld(boxStartX + (rect?.left || 0), boxStartY + (rect?.top || 0));
                            const worldEnd = screenToWorld(boxEndX + (rect?.left || 0), boxEndY + (rect?.top || 0));
                            
                            // 使用 ref 获取最新的 nodes，避免闭包问题
                            const currentNodes = nodesRef.current;
                            const selected = new Set();
                            currentNodes.forEach(node => {
                                const nodeRight = node.x + node.width;
                                const nodeBottom = node.y + node.height;
                                // 检查节点是否与框选框相交
                                if (node.x < worldEnd.x && nodeRight > worldStart.x &&
                                    node.y < worldEnd.y && nodeBottom > worldStart.y) {
                                    selected.add(node.id);
                                }
                            });
                            setSelectedNodeIds(selected);
                            
                            pendingSelectionUpdate.current = null;
                            selectionRafRef.current = null;
                        });
                    }
                    return;
                }

                if (isPanning) {
                    setIsDragging(true);
                    const dx = clientX - lastMousePos.current.x;
                    const dy = clientY - lastMousePos.current.y;
                    // 使用函数式更新，避免依赖 view
                    setView((prev) => ({ ...prev, x: prev.x + dx, y: prev.y + dy }));
                    lastMousePos.current = { x: clientX, y: clientY };
                    return;
                }

                if (resizingNodeId) {
                    scheduleNodeUpdate(resizingNodeId, (node) => ({
                        ...node,
                        width: Math.max(250, worldPos.x - node.x),
                        height: Math.max(250, worldPos.y - node.y)
                    }));
                } else if (dragNodeId) {
                    // 使用 movementX/Y 更流畅，避免频繁计算
                    const deltaX = e.movementX / view.zoom;
                    const deltaY = e.movementY / view.zoom;
                    // 添加阈值，避免微小移动触发更新
                    if (Math.abs(deltaX) > 0.1 || Math.abs(deltaY) > 0.1) {
                        // 使用 ref 获取最新的多选节点集合，避免闭包问题
                        const currentSelectedNodeIds = selectedNodeIdsRef.current;
                        // 如果有多选节点（大于1个）且被拖动的节点在选中集合中，同时拖动所有选中的节点
                        if (currentSelectedNodeIds && currentSelectedNodeIds.size > 1 && currentSelectedNodeIds.has(dragNodeId)) {
                            // 拖动多个节点时，使用批量更新
                            const updates = Array.from(currentSelectedNodeIds).map(nodeId => ({
                                nodeId,
                                updater: (node) => ({
                                    ...node,
                                    x: node.x + deltaX,
                                    y: node.y + deltaY
                                })
                            }));
                            scheduleMultiNodeUpdate(updates);
                        } else {
                            scheduleNodeUpdate(dragNodeId, (node) => ({
                                ...node,
                                x: node.x + deltaX,
                                y: node.y + deltaY
                            }));
                        }
                    }
                }
            }, [isPanning, isSelecting, selectionBox, dragNodeId, resizingNodeId, screenToWorld, view.zoom, scheduleNodeUpdate, scheduleMultiNodeUpdate]);

            const handleMouseUp = () => {
                // 结束框选
                if (isSelecting) {
                    setIsSelecting(false);
                    setSelectionBox(null);
                    // 如果只选中一个节点，设置selectedNodeId
                    if (selectedNodeIds.size === 1) {
                        const nodeId = Array.from(selectedNodeIds)[0];
                        setSelectedNodeId(nodeId);
                    } else if (selectedNodeIds.size === 0) {
                        setSelectedNodeId(null);
                    }
                    return;
                }
                
                if (isPanning) {
                    setIsPanning(false);
                    if (!isDragging && !connectingSource && !connectingTarget && !dragNodeId && !resizingNodeId) {
                        setSelectedNodeId(null);
                        setSelectedNodeIds(new Set());
                        setContextMenu(prev => ({ ...prev, visible: false }));
                        setActiveDropdown(null);
                        setHistoryContextMenu(prev => ({ ...prev, visible: false }));
                    }
                }
                if (!connectingSource && !connectingTarget) { setDragNodeId(null); setResizingNodeId(null); }
            };

            const handleNodeMouseUp = (targetId, e, inputType = 'default') => {
                e.stopPropagation();
                // 从输出端口连接到输入端口（原有逻辑）
                if (connectingSource && connectingSource !== targetId) {
                    // 检查是否已存在相同输入点的连接
                    const exists = connections.some((c) => 
                        c.from === connectingSource && 
                        c.to === targetId && 
                        (c.inputType || 'default') === inputType
                    );
                    if (!exists) {
                        // 如果连接到特定输入点，先删除该输入点的旧连接
                        if (inputType !== 'default') {
                            setConnections((prev) => prev.filter((c) => 
                                !(c.to === targetId && (c.inputType || 'default') === inputType)
                            ));
                        }
                        setConnections((prev) => [...prev, { 
                            id: `conn-${Date.now()}`, 
                            from: connectingSource, 
                            to: targetId,
                            inputType: inputType !== 'default' ? inputType : undefined
                        }]);
                    }
                }
                // 从输入端口连接到输出端口（新功能）
                else if (connectingTarget && connectingTarget !== targetId) {
                    // 使用connectingInputType而不是inputType参数（因为是从输入端口开始的连接）
                    const actualInputType = connectingInputType || inputType;
                    // 检查是否已存在相同输入点的连接
                    const exists = connections.some((c) => 
                        c.from === targetId && 
                        c.to === connectingTarget && 
                        (c.inputType || 'default') === actualInputType
                    );
                    if (!exists) {
                        // 如果连接到特定输入点，先删除该输入点的旧连接
                        if (actualInputType !== 'default') {
                            setConnections((prev) => prev.filter((c) => 
                                !(c.to === connectingTarget && (c.inputType || 'default') === actualInputType)
                            ));
                        }
                        setConnections((prev) => [...prev, { 
                            id: `conn-${Date.now()}`, 
                            from: targetId, 
                            to: connectingTarget,
                            inputType: actualInputType !== 'default' ? actualInputType : undefined
                        }]);
                    }
                }
                setConnectingSource(null);
                setConnectingTarget(null);
                setConnectingInputType(null);
                setHoverTargetId(null);
                setIsPanning(false);
                setDragNodeId(null);
                setResizingNodeId(null);
            };

            const handleBackgroundClick = (e) => {
                if (connectingSource) {
                    const world = screenToWorld(e.clientX, e.clientY);
                    setContextMenu({ visible: true, x: e.clientX, y: e.clientY, worldX: world.x, worldY: world.y, sourceNodeId: connectingSource });
                    setConnectingSource(null);
                } else if (connectingTarget) {
                    // 从输入端口开始的连接，点击背景时弹出参考图窗口
                    const world = screenToWorld(e.clientX, e.clientY);
                    setContextMenu({ visible: true, x: e.clientX, y: e.clientY, worldX: world.x, worldY: world.y, targetNodeId: connectingTarget, inputType: connectingInputType });
                    setConnectingTarget(null);
                    setConnectingInputType(null);
                }
            };

            const handleDoubleClick = (e) => {
                if (e.currentTarget.id === 'canvas-bg') {
                    const world = screenToWorld(e.clientX, e.clientY);
                    setContextMenu({ visible: true, x: e.clientX, y: e.clientY, worldX: world.x, worldY: world.y, sourceNodeId: undefined });
                }
            };
            
            // 使用 useMemo 缓存连接图片的计算结果，避免重复计算
            const connectedImagesCache = useMemo(() => {
                const cache = new Map(); // nodeId -> { inputType -> images[] }
                connections.forEach(conn => {
                    const inputType = conn.inputType || 'default';
                    if (!cache.has(conn.to)) {
                        cache.set(conn.to, new Map());
                    }
                    const nodeConnections = cache.get(conn.to);
                    if (!nodeConnections.has(inputType)) {
                        nodeConnections.set(inputType, []);
                    }
                    const sourceNode = nodesMap.get(conn.from);
                    if (sourceNode && ((sourceNode.type === 'input-image') || (sourceNode.type === 'video-input'))) {
                        let images = [];
                        if (sourceNode.type === 'video-input') {
                            const selected = sourceNode.selectedKeyframes && sourceNode.selectedKeyframes.length > 0 
                                ? sourceNode.selectedKeyframes.map(f => f.url) 
                                : [];
                            if (selected.length > 0) {
                                images = selected;
                            } else if (sourceNode.frames && sourceNode.frames.length > 0) {
                                images = [sourceNode.frames[0].url];
                            }
                        } else if (sourceNode.content) {
                            images = [sourceNode.content];
                        }
                        nodeConnections.get(inputType).push(...images);
                    }
                });
                return cache;
            }, [connections, nodesMap, nodes.length, nodes.map(n => `${n.id}:${n.type}:${n.content ? 'hasContent' : ''}:${n.selectedKeyframes?.length || 0}:${n.frames?.length || 0}`).join('|')]);

            const getConnectedInputImages = useCallback((targetNodeId, inputType = 'default') => {
                const nodeCache = connectedImagesCache.get(targetNodeId);
                if (!nodeCache) return [];
                return nodeCache.get(inputType) || [];
            }, [connectedImagesCache]);

            // 使用 useMemo 缓存 video-input 节点查找结果
            const connectedVideoInputCache = useMemo(() => {
                const cache = new Map(); // nodeId -> videoInputNode
                connections.forEach(conn => {
                    if (!cache.has(conn.to)) {
                        const sourceNode = nodesMap.get(conn.from);
                        if (sourceNode && sourceNode.type === 'video-input') {
                            cache.set(conn.to, sourceNode);
                        }
                    }
                });
                return cache;
            }, [connections, nodesMap]);

            // 获取连接的 video-input 节点（用于 video-analyze 节点）
            const getConnectedVideoInputNode = useCallback((targetNodeId) => {
                return connectedVideoInputCache.get(targetNodeId) || null;
            }, [connectedVideoInputCache]);

            // 使用 useMemo 缓存特定输入点的图片URL
            const connectedImageForInputCache = useMemo(() => {
                const cache = new Map(); // `${nodeId}:${inputType}` -> imageUrl
                connections.forEach(conn => {
                    const inputType = conn.inputType || 'default';
                    const key = `${conn.to}:${inputType}`;
                    if (!cache.has(key)) {
                        const sourceNode = nodesMap.get(conn.from);
                        if (sourceNode) {
                            let imageUrl = null;
                            if (sourceNode.type === 'video-input') {
                                const selected = sourceNode.selectedKeyframes && sourceNode.selectedKeyframes.length > 0 
                                    ? sourceNode.selectedKeyframes[0].url 
                                    : null;
                                if (selected) {
                                    imageUrl = selected;
                                } else if (sourceNode.frames && sourceNode.frames[0]) {
                                    imageUrl = sourceNode.frames[0].url;
                                }
                            } else if (sourceNode.type === 'input-image' && sourceNode.content) {
                                imageUrl = sourceNode.content;
                            }
                            if (imageUrl) {
                                cache.set(key, imageUrl);
                            }
                        }
                    }
                });
                return cache;
            }, [connections, nodesMap, nodes.length, nodes.map(n => `${n.id}:${n.type}:${n.content ? 'hasContent' : ''}:${n.selectedKeyframes?.[0]?.url || ''}:${n.frames?.[0]?.url || ''}`).join('|')]);

            // 获取连接到特定输入点的图片URL
            const getConnectedImageForInput = useCallback((targetNodeId, inputType) => {
                const key = `${targetNodeId}:${inputType || 'default'}`;
                return connectedImageForInputCache.get(key) || null;
            }, [connectedImageForInputCache]);


            // 将生成结果同步到连接的预览节点
            const updatePreviewFromTask = (taskId, url, contentType = 'image', sourceNodeIdOverride = null, mjImages = null) => {
                if (!url && (!mjImages || mjImages.length === 0)) return;
                // 找到对应的源节点ID
                let sourceNodeId = sourceNodeIdOverride;
                if (!sourceNodeId) {
                    const historyItem = history.find(h => h.id === taskId);
                    sourceNodeId = historyItem?.sourceNodeId;
                }
                if (!sourceNodeId) {
                    console.warn('[Tapnow] updatePreviewFromTask: 未找到 sourceNodeId for taskId:', taskId);
                    return;
                }

                // 使用 ref 获取最新的 connections 状态，避免闭包问题
                const latestConnections = connectionsRef.current;
                console.log('[Tapnow] updatePreviewFromTask: 更新预览窗口', { taskId, url, contentType, sourceNodeId, mjImages, connectionsCount: latestConnections.length });
                
                // 使用函数式更新，确保获取最新的 connections 状态
                setNodes((prevNodes) => {
                    // 使用 ref 中的最新 connections
                    const targetIds = latestConnections
                        .filter((c) => c.from === sourceNodeId)
                        .map((c) => c.to);
                    
                    console.log('[Tapnow] updatePreviewFromTask: 检查连接', { 
                        sourceNodeId, 
                        allConnectionsFromSource: latestConnections.filter(c => c.from === sourceNodeId),
                        targetIds,
                        allNodes: prevNodes.map(n => ({ id: n.id, type: n.type }))
                    });
                    
                    if (!targetIds.length) {
                        console.warn('[Tapnow] updatePreviewFromTask: 未找到连接到预览窗口的连接', { 
                            sourceNodeId, 
                            connectionsFromSource: latestConnections.filter(c => c.from === sourceNodeId),
                            allConnections: latestConnections
                        });
                        return prevNodes;
                    }
                    
                    const previewNodes = prevNodes.filter(n => targetIds.includes(n.id) && n.type === 'preview');
                    console.log('[Tapnow] updatePreviewFromTask: 找到预览节点', { 
                        targetIds, 
                        previewNodes: previewNodes.map(n => ({ id: n.id, type: n.type }))
                    });
                    
                    return prevNodes.map((n) => 
                        targetIds.includes(n.id) && n.type === 'preview'
                            ? { ...n, content: url || (mjImages && mjImages.length > 0 ? mjImages[0] : url), previewType: contentType, previewMjImages: mjImages }
                            : n
                    );
                });
            };

            const deleteHistoryItem = (id) => {
                setHistory(prev => {
                    const filtered = prev.filter(item => item.id !== id);
                    // 立即保存到 localStorage，不等待防抖
                    try {
                        localStorage.setItem('tapnow_history', JSON.stringify(filtered));
                    } catch (e) {
                        console.error('立即保存历史记录失败:', e);
                    }
                    return filtered;
                });
                if (historyContextMenu.item && historyContextMenu.item.id === id) {
                    setHistoryContextMenu({ visible: false, x: 0, y: 0, item: null });
                }
            };

            const addNewModel = () => {
                const newConfig = { id: `custom-${Date.now()}`, provider: 'New Model', modelName: 'new-model-id', type: 'Chat', key: '', url: DEFAULT_BASE_URL, isCustom: true };
                setApiConfigs([...apiConfigs, newConfig]);
            };
            const updateApiConfig = (id, updates) => setApiConfigs((prev) => prev.map((c) => (c.id === id ? { ...c, ...updates } : c)));
            const deleteApiConfig = (id) => setApiConfigs((prev) => prev.filter((c) => c.id !== id));

            const testApiConnection = async (id) => {
                setApiTesting(id);
                setApiStatus((prev) => ({ ...prev, [id]: 'idle' }));
                const config = apiConfigs.find((c) => c.id === id);
                const apiKey = config?.key || globalApiKey;

                if (!apiKey) {
                    setApiStatus((prev) => ({ ...prev, [id]: 'error' }));
                    setApiTesting(null);
                    return;
                }

                try {
                    const response = await fetch(`${config?.url || DEFAULT_BASE_URL}/v1/models`, {
                        method: 'GET',
                        headers: { Authorization: `Bearer ${apiKey}` },
                    });
                    if (response.ok) setApiStatus((prev) => ({ ...prev, [id]: 'success' }));
                    else setApiStatus((prev) => ({ ...prev, [id]: 'error' }));
                } catch {
                    setApiStatus((prev) => ({ ...prev, [id]: 'error' }));
                }
                setApiTesting(null);
            };

            const getStatusColor = (modelId) => {
                if (!modelId) return 'bg-zinc-600';
                const status = apiStatus[modelId];
                if (status === 'success') return 'bg-green-500 shadow-[0_0_8px_rgba(34,197,94,0.8)]';
                if (status === 'error') return 'bg-red-500';
                const config = apiConfigs.find((c) => c.id === modelId);
                return (config?.key || globalApiKey) ? 'bg-zinc-400' : 'bg-zinc-700';
            };

            const currentSession = useMemo(() => chatSessions.find(s => s.id === currentChatId) || chatSessions[0], [chatSessions, currentChatId]);

            const scrollToBottom = () => {
                chatEndRef.current?.scrollIntoView({ behavior: "smooth" });
            };

            useEffect(() => {
                scrollToBottom();
            }, [currentSession?.messages, isChatOpen]);

            const createNewChat = () => {
                const newId = `chat-${Date.now()}`;
                const newSession = { id: newId, title: '新对话', messages: [] };
                setChatSessions(prev => [newSession, ...prev]);
                setCurrentChatId(newId);
            };

            const deleteChatSession = (e, id) => {
                e.stopPropagation();
                const newSessions = chatSessions.filter(s => s.id !== id);
                if (newSessions.length === 0) {
                    const defaultSession = { id: 'default', title: '新对话', messages: [] };
                    setChatSessions([defaultSession]);
                    setCurrentChatId('default');
                } else {
                    setChatSessions(newSessions);
                    if (currentChatId === id) setCurrentChatId(newSessions[0].id);
                }
            };

            const handleChatFileUpload = (e) => {
                const files = Array.from(e.target.files);
                files.forEach(file => {
                    const reader = new FileReader();
                    reader.onload = (ev) => {
                        const content = ev.target.result;
                        const fileExt = file.name.split('.').pop()?.toLowerCase() || '';
                        
                        // 判断文件类型
                        const isImage = file.type.startsWith('image/');
                        const isVideo = file.type.startsWith('video/');
                        const isAudio = file.type.startsWith('audio/');
                        const isPDF = file.type === 'application/pdf' || fileExt === 'pdf';
                        const isDoc = ['doc', 'docx'].includes(fileExt) || file.type.includes('word');
                        const isExcel = ['xls', 'xlsx'].includes(fileExt) || file.type.includes('excel') || file.type.includes('spreadsheet');
                        const isCode = ['js', 'jsx', 'ts', 'tsx', 'py', 'java', 'cpp', 'c', 'html', 'css', 'json', 'xml', 'yaml', 'yml', 'md', 'txt', 'sh', 'bash'].includes(fileExt);
                        
                        setChatFiles(prev => [...prev, {
                            name: file.name,
                            type: file.type,
                            content: content, 
                            isImage,
                            isVideo,
                            isAudio,
                            isPDF,
                            isDoc,
                            isExcel,
                            isCode,
                            fileExt
                        }]);
                    };
                    
                    // 根据文件类型选择读取方式
                    if (file.type.startsWith('image/') || file.type.startsWith('video/') || file.type.startsWith('audio/')) {
                        reader.readAsDataURL(file);
                    } else if (file.type === 'application/pdf') {
                        // PDF 也转换为 data URL
                        reader.readAsDataURL(file);
                    } else if (file.name.match(/\.(txt|md|js|jsx|ts|tsx|py|html|css|json|csv|xml|yaml|yml|sh|bash|java|cpp|c)$/i)) {
                        // 代码和文本文件读取为文本
                        reader.readAsText(file);
                    } else {
                        // 其他文件（如 Word、Excel）也尝试读取为 data URL
                        reader.readAsDataURL(file);
                    }
                });
                e.target.value = '';
            };

            const removeChatFile = (index) => {
                setChatFiles(prev => prev.filter((_, i) => i !== index));
            };

            const sendChatMessage = async () => {
                if ((!chatInput.trim() && chatFiles.length === 0) || isChatSending) return;

                const config = apiConfigs.find((c) => c.id === chatModel);
                const apiKey = config?.key || globalApiKey;
                const baseUrl = (config?.url || DEFAULT_BASE_URL).replace(/\/+$/, '');

                if (!apiKey) {
                    alert('请先在 API 设置中配置 Key');
                    setSettingsOpen(true);
                    return;
                }

                // 确保使用当前激活的会话（避免新建对话后第一条消息被写入旧会话）
                const chatIdToUse = currentChatId || chatSessions[0]?.id;
                const sessionToUse = chatSessions.find(s => s.id === chatIdToUse) || chatSessions[0];
                const currentSessionMessages = sessionToUse?.messages || [];
                if (sessionToUse && sessionToUse.id !== currentChatId) setCurrentChatId(sessionToUse.id);

                setIsChatSending(true);

                const newUserMsg = {
                    id: `msg-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
                    role: 'user',
                    content: chatInput,
                    files: [...chatFiles], 
                    timestamp: Date.now(),
                    modelId: chatModel // 保存发送消息时使用的模型ID
                };
                
                setChatSessions(prev => prev.map(s => {
                    if (s.id === chatIdToUse) {
                        return { ...s, messages: [...s.messages, newUserMsg], title: s.messages.length === 0 ? chatInput.slice(0, 20) : s.title };
                    }
                    return s;
                }));
                setChatInput('');
                setChatFiles([]);

                // 构建带上下文的对话历史，帮助模型回顾上下文
                // 使用当前会话的消息加上新消息
                const allMessages = [...currentSessionMessages, newUserMsg];
                const MAX_HISTORY_MESSAGES = 20;
                const recentMessages = allMessages.length > MAX_HISTORY_MESSAGES
                    ? allMessages.slice(-MAX_HISTORY_MESSAGES)
                    : allMessages;

                let apiMessages = [
                    {
                        role: 'system',
                        content: '你是一名多模态AI助手，需要结合整个对话的上下文进行连续回答。'
                    },
                    ...recentMessages.map(m => ({
                        role: m.role,
                        content: m.content
                    }))
                ];

                const currentContent = [];
                if (newUserMsg.content) currentContent.push({ type: "text", text: newUserMsg.content });
                
                newUserMsg.files.forEach(f => {
                    const isGeminiLike = (config?.modelName ?? '').toLowerCase().includes('gemini');

                    if (f.isImage) {
                        currentContent.push({
                            type: "image_url",
                            image_url: { url: f.content }
                        });
                    } else if (f.isVideo) {
                        if (isGeminiLike) {
                            // Gemini 视频分析：按官方规范也走 image_url，url 直接指向 mp4
                            currentContent.push({
                                type: "image_url",
                                image_url: { url: f.content }
                            });
                        } else {
                            currentContent.push({
                                type: "text",
                                text: `\n[User attached video: ${f.name}]\n`
                            });
                        }
                    } else if (f.isAudio) {
                        currentContent.push({
                            type: "text",
                            text: `\n[User attached audio: ${f.name}]\n`
                        });
                    } else if (f.isPDF || f.isDoc || f.isExcel) {
                        // PDF、Word、Excel 等文档文件，发送文件名和类型信息
                        currentContent.push({
                            type: "text",
                            text: `\n[User attached document: ${f.name} (${f.isPDF ? 'PDF' : f.isDoc ? 'Word' : 'Excel'})]\n`
                        });
                    } else if (f.isCode || (f.content && typeof f.content === 'string' && f.content.length < 50000)) {
                        // 代码文件或文本文件，直接发送内容
                        currentContent.push({
                            type: "text",
                            text: `\n[File: ${f.name}]\n\`\`\`${f.fileExt || 'text'}\n${f.content}\n\`\`\`\n`
                        });
                    } else {
                        // 其他文件或二进制文件
                        currentContent.push({
                            type: "text",
                            text: `\n[User attached file: ${f.name}]\n`
                        });
                    }
                });

                apiMessages.push({ role: 'user', content: currentContent });

                try {
                    const response = await fetch(`${baseUrl}/v1/chat/completions`, {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${apiKey}`,
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            model: config?.modelName || 'gemini-3-pro-preview',
                            messages: apiMessages,
                            stream: false 
                        })
                    });

                    if (!response.ok) {
                        const errText = await response.text();
                        throw new Error(errText || `API Error: ${response.status}`);
                    }

                    const data = await response.json();
                    const aiContent = data.choices?.[0]?.message?.content || "No response";

                    const newAssistantMsg = {
                        id: `msg-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
                        role: 'assistant',
                        content: aiContent,
                        timestamp: Date.now(),
                        modelId: chatModel // 保存回复消息时使用的模型ID
                    };

                    setChatSessions(prev => prev.map(s => {
                        if (s.id === currentChatId) {
                            return { ...s, messages: [...s.messages, newAssistantMsg] };
                        }
                        return s;
                    }));

                } catch (error) {
                    console.error("Chat Error", error);
                    const errorMsg = {
                        id: `msg-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
                        role: 'assistant',
                        content: `Error: ${error.message}`,
                        isError: true,
                        timestamp: Date.now()
                    };

                    setChatSessions(prev => prev.map(s => {
                        if (s.id === currentChatId) {
                            return { ...s, messages: [...s.messages, errorMsg] };
                        }
                        return s;
                    }));
                } finally {
                    setIsChatSending(false);
                }
            };

            const getBlobFromUrl = async (url) => {
                const res = await fetch(url);
                return await res.blob();
            };

            const getBase64FromUrl = async (url) => {
                if (url.startsWith('data:')) {
                    return url.split(',')[1];
                }
                const blob = await getBlobFromUrl(url);
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onloadend = () => resolve(reader.result.split(',')[1]);
                    reader.onerror = reject;
                    reader.readAsDataURL(blob);
                });
            };

            const blobToDataURL = (blob) => {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onloadend = () => resolve(reader.result);
                    reader.onerror = reject;
                    reader.readAsDataURL(blob);
                });
            };

            // 压缩/缩放图片用于Midjourney上传（Discord对图片有尺寸和大小限制）
            const prepareImageForMidjourneyUpload = async (imageUrl, maxSize = 2048, maxFileSizeMB = 8) => {
                return new Promise((resolve, reject) => {
                    const img = new Image();
                    img.crossOrigin = 'anonymous';
                    
                    img.onload = () => {
                        const originalWidth = img.width;
                        const originalHeight = img.height;
                        
                        // 计算缩放后的尺寸，保持宽高比
                        let newWidth = originalWidth;
                        let newHeight = originalHeight;
                        
                        if (originalWidth > maxSize || originalHeight > maxSize) {
                            const scale = maxSize / Math.max(originalWidth, originalHeight);
                            newWidth = Math.floor(originalWidth * scale);
                            newHeight = Math.floor(originalHeight * scale);
                            console.log(`Midjourney: 缩放图片 ${originalWidth}x${originalHeight} -> ${newWidth}x${newHeight}`);
                        }
                        
                        // 创建canvas并绘制
                        const canvas = document.createElement('canvas');
                        canvas.width = newWidth;
                        canvas.height = newHeight;
                        const ctx = canvas.getContext('2d');
                        
                        // 使用高质量绘制
                        ctx.imageSmoothingEnabled = true;
                        ctx.imageSmoothingQuality = 'high';
                        ctx.drawImage(img, 0, 0, newWidth, newHeight);
                        
                        // 转换为base64，使用JPEG格式压缩
                        // 从高质量开始，如果文件太大则降低质量
                        let quality = 0.92;
                        let dataUrl = canvas.toDataURL('image/jpeg', quality);
                        
                        // 检查文件大小（base64编码后的大小约为原始大小的133%）
                        const base64Length = dataUrl.split(',')[1]?.length || 0;
                        const fileSizeMB = (base64Length * 3 / 4) / (1024 * 1024);
                        
                        // 如果文件太大，降低质量
                        if (fileSizeMB > maxFileSizeMB) {
                            console.log(`Midjourney: 图片文件大小 ${fileSizeMB.toFixed(2)}MB 超过限制，降低质量...`);
                            quality = 0.75;
                            dataUrl = canvas.toDataURL('image/jpeg', quality);
                            const newBase64Length = dataUrl.split(',')[1]?.length || 0;
                            const newFileSizeMB = (newBase64Length * 3 / 4) / (1024 * 1024);
                            console.log(`Midjourney: 降低质量后文件大小 ${newFileSizeMB.toFixed(2)}MB`);
                        }
                        
                        resolve(dataUrl);
                    };
                    
                    img.onerror = (error) => {
                        console.error('Midjourney: 图片加载失败', error);
                        // 如果加载失败，返回原图
                        resolve(imageUrl);
                    };
                    
                    img.src = imageUrl;
                });
            };

            // 上传图片到Midjourney并获取HTTP URL（用于oref和sref指令）
            const uploadMidjourneyImages = async (base64Array, baseUrl, apiKey) => {
                try {
                    // 先处理所有图片：压缩/缩放
                    console.log(`Midjourney: 准备上传 ${base64Array.length} 张图片，先进行压缩/缩放处理...`);
                    const processedImages = await Promise.all(
                        base64Array.map(async (imageUrl, index) => {
                            // 如果是data URL，先压缩/缩放
                            if (imageUrl.startsWith('data:')) {
                                try {
                                    const processed = await prepareImageForMidjourneyUpload(imageUrl, 2048, 8);
                                    console.log(`Midjourney: 图片[${index}]处理完成`);
                                    return processed;
                                } catch (error) {
                                    console.error(`Midjourney: 图片[${index}]处理失败，使用原图`, error);
                                    return imageUrl;
                                }
                            } else {
                                // 如果是HTTP URL，需要先转换为data URL再处理
                                try {
                                    const blob = await getBlobFromUrl(imageUrl);
                                    const dataUrl = await blobToDataURL(blob);
                                    const processed = await prepareImageForMidjourneyUpload(dataUrl, 2048, 8);
                                    console.log(`Midjourney: 图片[${index}]从URL处理完成`);
                                    return processed;
                                } catch (error) {
                                    console.error(`Midjourney: 图片[${index}]从URL处理失败`, error);
                                    throw error;
                                }
                            }
                        })
                    );
                    
                    // 清理base64数组，确保每个元素都是纯base64字符串
                    const cleanedBase64Array = processedImages.map((base64, index) => {
                        // 如果是data URL，提取base64部分
                        let cleaned = base64;
                        if (typeof cleaned !== 'string') {
                            throw new Error(`base64[${index}]不是字符串类型`);
                        }
                        
                        // 如果是data URL，提取base64部分
                        if (cleaned.includes(',')) {
                            // 直接提取逗号后的部分（base64数据）
                            cleaned = cleaned.split(',')[1];
                        } else if (cleaned.startsWith('data:')) {
                            // 如果没有逗号但有data:前缀，使用正则提取
                            cleaned = cleaned.replace(/^data:[^;]*;base64,?/i, '');
                        }
                        
                        // 严格清理：移除所有非base64字符（包括空白字符和不可见字符）
                        // 只保留有效的base64字符：A-Z, a-z, 0-9, +, /, =
                        const beforeClean = cleaned.length;
                        cleaned = cleaned.replace(/[^A-Za-z0-9+/=]/g, '');
                        const afterClean = cleaned.length;
                        if (beforeClean !== afterClean) {
                            console.log(`Midjourney: base64[${index}]清理了 ${beforeClean - afterClean} 个非法字符`);
                        }
                        
                        if (!cleaned || cleaned.length < 100) {
                            throw new Error(`base64[${index}]无效或太短，长度: ${cleaned?.length || 0}`);
                        }
                        
                        // 验证base64格式：只包含 base64 字符（A-Z, a-z, 0-9, +, /, =）
                        // 注意：base64字符串可能以0-2个=结尾作为填充
                        const base64Regex = /^[A-Za-z0-9+/]+={0,2}$/;
                        if (!base64Regex.test(cleaned)) {
                            console.error(`Midjourney: base64[${index}]格式验证失败，长度: ${cleaned.length}, 前50字符: ${cleaned.substring(0, 50)}`);
                            throw new Error(`invalid_base64_format: base64[${index}]格式无效`);
                        }
                        
                        // 验证base64长度是否为4的倍数（base64编码要求）
                        // 如果不是4的倍数，添加填充
                        const padding = cleaned.length % 4;
                        if (padding !== 0) {
                            // 移除现有的填充字符，然后重新添加正确的填充
                            cleaned = cleaned.replace(/=+$/, '');
                            cleaned += '='.repeat(4 - padding);
                            
                            // 填充后再次验证
                            if (!base64Regex.test(cleaned)) {
                                console.error(`Midjourney: base64[${index}]填充后验证失败，长度: ${cleaned.length}`);
                                throw new Error(`invalid_base64_format: base64[${index}]填充后格式无效`);
                            }
                        }
                        
                        // 测试base64是否能正确解码（确保base64有效）
                        try {
                            const testDecode = atob(cleaned);
                            if (!testDecode || testDecode.length === 0) {
                                throw new Error('base64解码结果为空');
                            }
                            console.log(`Midjourney: base64[${index}]解码测试通过，解码后长度: ${testDecode.length}`);
                        } catch (decodeError) {
                            console.error(`Midjourney: base64[${index}]解码测试失败:`, decodeError);
                            throw new Error(`invalid_base64_format: base64[${index}]无法解码`);
                        }
                        
                        // 根据API文档，base64Array需要完整的data URL格式：data:image/png;base64,xxx
                        // 而不是纯base64字符串
                        const dataUrl = `data:image/jpeg;base64,${cleaned}`;
                        console.log(`Midjourney: base64[${index}]清理完成，长度: ${cleaned.length}, 前20字符: ${cleaned.substring(0, 20)}`);
                        return dataUrl;
                    });
                    
                    // 使用Midjourney的上传接口：/mj/submit/upload-discord-images
                    const uploadEndpoint = `${baseUrl}/mj/submit/upload-discord-images`;
                    
                    console.log('Midjourney: 上传图片，base64数组长度:', cleanedBase64Array.length, '第一个data URL长度:', cleanedBase64Array[0]?.length, '前50字符:', cleanedBase64Array[0]?.substring(0, 50));
                    
                    // 最终验证所有data URL字符串（现在返回的是完整的data URL格式）
                    cleanedBase64Array.forEach((dataUrl, idx) => {
                        if (!dataUrl || typeof dataUrl !== 'string') {
                            throw new Error(`base64[${idx}]无效或不是字符串`);
                        }
                        // 验证是否是data URL格式：data:image/xxx;base64,xxx
                        if (!dataUrl.startsWith('data:image/')) {
                            throw new Error(`base64[${idx}]不是有效的data URL格式`);
                        }
                        // 提取base64部分进行验证
                        let base64Part = '';
                        if (dataUrl.includes(',')) {
                            base64Part = dataUrl.split(',')[1];
                        } else {
                            throw new Error(`base64[${idx}]data URL格式不正确，缺少逗号`);
                        }
                        
                        if (!base64Part || base64Part.length < 100) {
                            throw new Error(`base64[${idx}]无效或太短`);
                        }
                        // 验证base64格式
                        const base64Regex = /^[A-Za-z0-9+/]+={0,2}$/;
                        if (!base64Regex.test(base64Part)) {
                            console.error(`Midjourney: base64[${idx}]最终验证失败，包含非法字符`);
                            throw new Error(`base64[${idx}]格式无效`);
                        }
                        // 验证长度是4的倍数
                        if (base64Part.length % 4 !== 0) {
                            throw new Error(`base64[${idx}]长度不是4的倍数: ${base64Part.length}`);
                        }
                        // 再次测试解码
                        try {
                            atob(base64Part);
                        } catch (e) {
                            throw new Error(`base64[${idx}]无法解码: ${e.message}`);
                        }
                    });
                    
                    // 构建请求体
                    const requestBody = {
                        base64Array: cleanedBase64Array
                    };
                    
                    // 验证JSON序列化后的数据
                    const jsonString = JSON.stringify(requestBody);
                    console.log('Midjourney: 请求体JSON长度:', jsonString.length, 'base64数组长度:', cleanedBase64Array.length);
                    
                    const uploadResp = await fetch(uploadEndpoint, {
                        method: 'POST',
                        headers: {
                            Authorization: `Bearer ${apiKey}`,
                            'Content-Type': 'application/json'
                        },
                        body: jsonString
                    });
                    
                    if (!uploadResp.ok) {
                        let errorText = '';
                        try {
                            errorText = await uploadResp.text();
                            // 尝试解析为JSON
                            try {
                                const errorJson = JSON.parse(errorText);
                                throw new Error(`上传失败: ${uploadResp.status} - ${errorJson.description || errorJson.message || errorText}`);
                            } catch {
                                throw new Error(`上传失败: ${uploadResp.status} - ${errorText}`);
                            }
                        } catch (error) {
                            throw new Error(`上传失败: ${uploadResp.status} - ${error.message || errorText}`);
                        }
                    }
                    
                    const uploadData = await uploadResp.json();
                    console.log('Midjourney: 上传响应:', uploadData);
                    
                    // 检查响应格式
                    if (uploadData.code === 1 && uploadData.result && Array.isArray(uploadData.result)) {
                        console.log('Midjourney: 图片上传成功，获取URLs:', uploadData.result);
                        return uploadData.result; // 返回URL数组
                    } else {
                        const errorMsg = uploadData.description || uploadData.message || '上传失败：响应格式错误';
                        console.error('Midjourney: 上传失败，响应:', uploadData);
                        throw new Error(errorMsg);
                    }
                } catch (error) {
                    console.error('Midjourney: 图片上传失败:', error);
                    throw error;
                }
            };

            // 上传单个图片到图床并获取HTTP URL（用于Midjourney的oref和sref指令，以及拓展图片）
            const uploadImageToGetHttpUrl = async (imageUrl, baseUrl, apiKey) => {
                try {
                    // 如果是HTTP/HTTPS URL，直接返回
                    if (imageUrl.startsWith('http://') || imageUrl.startsWith('https://')) {
                        return imageUrl;
                    }

                    // 如果是data URL，需要上传
                    if (imageUrl.startsWith('data:')) {
                        // 提取base64数据（去掉 data:image/png;base64, 前缀）
                        // 确保正确提取纯base64字符串
                        let base64Data = imageUrl;
                        if (base64Data.includes(',')) {
                            base64Data = base64Data.split(',')[1];
                        } else {
                            // 如果没有逗号，尝试去掉 data: 前缀
                            base64Data = base64Data.replace(/^data:[^;]*;base64,?/i, '');
                        }
                        // 先清理所有非base64字符（包括所有空白字符和不可见字符）
                        // 这是最严格的方式：只保留有效的base64字符
                        base64Data = base64Data.replace(/[^A-Za-z0-9+/=]/g, '');
                        
                        if (!base64Data || base64Data.length < 100) {
                            console.error('拓展图片: base64数据无效或太短，长度:', base64Data?.length);
                            return null;
                        }
                        
                        // 验证base64格式：只包含 base64 字符（A-Z, a-z, 0-9, +, /, =）
                        const base64Regex = /^[A-Za-z0-9+/]*={0,2}$/;
                        if (!base64Regex.test(base64Data)) {
                            console.error('拓展图片: base64数据格式验证失败，包含非法字符');
                            // 再次清理（理论上不应该到这里）
                            base64Data = base64Data.replace(/[^A-Za-z0-9+/=]/g, '');
                            if (!base64Regex.test(base64Data)) {
                                console.error('拓展图片: 清理后仍无效，放弃上传');
                                return null;
                            }
                        }
                        
                        // 验证base64长度是否为4的倍数（base64编码要求）
                        const padding = base64Data.length % 4;
                        if (padding !== 0) {
                            console.warn('拓展图片: base64长度不是4的倍数，添加填充:', padding);
                            base64Data += '='.repeat(4 - padding);
                        }
                        
                        // 最终验证
                        if (!base64Regex.test(base64Data)) {
                            console.error('拓展图片: 最终验证失败');
                            return null;
                        }
                        
                        console.log('拓展图片: 提取的base64数据长度:', base64Data.length, '前50字符:', base64Data.substring(0, 50), '后10字符:', base64Data.substring(base64Data.length - 10), '格式验证通过:', base64Regex.test(base64Data));
                        
                        // 优先使用 Midjourney 官方上传接口
                        try {
                            // 确保 baseUrl 格式正确（移除末尾斜杠）
                            const cleanBaseUrl = baseUrl.replace(/\/+$/, '');
                            const uploadEndpoint = `${cleanBaseUrl}/mj/submit/upload-discord-images`;
                            const uploadPayload = {
                                base64Array: [base64Data]
                            };

                            console.log('拓展图片: 使用 Midjourney 上传接口上传图片...', uploadEndpoint, 'base64长度:', base64Data.length);
                            
                            const uploadResp = await fetch(uploadEndpoint, {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json',
                                    'Authorization': `Bearer ${apiKey}`
                                },
                                body: JSON.stringify(uploadPayload)
                            });

                            const responseText = await uploadResp.text();
                            console.log('拓展图片: Midjourney 上传响应状态:', uploadResp.status, '响应长度:', responseText.length);

                            if (uploadResp.ok) {
                                let uploadData;
                                try {
                                    uploadData = JSON.parse(responseText);
                                } catch (parseError) {
                                    console.error('拓展图片: Midjourney 上传响应解析失败', parseError, '响应内容:', responseText.substring(0, 200));
                                    throw new Error('响应不是有效的JSON格式');
                                }

                                console.log('拓展图片: Midjourney 上传响应数据:', uploadData);
                                console.log('拓展图片: 响应详细信息:', {
                                    code: uploadData.code,
                                    description: uploadData.description,
                                    result: uploadData.result,
                                    resultType: typeof uploadData.result,
                                    isArray: Array.isArray(uploadData.result),
                                    hasData: !!uploadData.data,
                                    hasUrl: !!uploadData.url
                                });

                                // 检查响应格式
                                if (uploadData.code === 1) {
                                    // 尝试多种可能的响应格式
                                    let httpUrl = null;
                                    
                                    // 格式1: result 是数组
                                    if (uploadData.result && Array.isArray(uploadData.result) && uploadData.result.length > 0) {
                                        httpUrl = uploadData.result[0];
                                    }
                                    // 格式2: result 是字符串
                                    else if (uploadData.result && typeof uploadData.result === 'string') {
                                        httpUrl = uploadData.result;
                                    }
                                    // 格式3: data 字段
                                    else if (uploadData.data && Array.isArray(uploadData.data) && uploadData.data.length > 0) {
                                        httpUrl = uploadData.data[0];
                                    }
                                    // 格式4: url 字段
                                    else if (uploadData.url) {
                                        httpUrl = uploadData.url;
                                    }
                                    
                                    if (httpUrl && (httpUrl.startsWith('http://') || httpUrl.startsWith('https://'))) {
                                        console.log('拓展图片: Midjourney 上传成功，获取HTTP URL:', httpUrl);
                                        return httpUrl;
                                    } else {
                                        console.warn('拓展图片: Midjourney 返回的URL格式不正确或为空', {
                                            httpUrl,
                                            code: uploadData.code,
                                            description: uploadData.description,
                                            result: uploadData.result,
                                            data: uploadData.data,
                                            url: uploadData.url
                                        });
                                    }
                                } else {
                                    console.warn('拓展图片: Midjourney 上传失败', {
                                        code: uploadData.code,
                                        description: uploadData.description,
                                        fullResponse: uploadData
                                    });
                                }
                            } else {
                                console.warn('拓展图片: Midjourney 上传失败', uploadResp.status, '响应内容:', responseText.substring(0, 200));
                            }
                        } catch (e) {
                            console.error('拓展图片: Midjourney 上传接口调用失败', e);
                        }

                        // 如果 Midjourney 上传失败，尝试使用图床服务作为备选
                        const mimeMatch = imageUrl.match(/data:([^;]+);base64/);
                        const mimeType = mimeMatch ? mimeMatch[1] : 'image/png';
                        
                        // 将base64转换为Blob
                        const byteCharacters = atob(base64Data);
                        const byteNumbers = new Array(byteCharacters.length);
                        for (let i = 0; i < byteCharacters.length; i++) {
                            byteNumbers[i] = byteCharacters.charCodeAt(i);
                        }
                        const byteArray = new Uint8Array(byteNumbers);
                        const blob = new Blob([byteArray], { type: mimeType });

                        const imageBedServices = [
                            // sm.ms图床
                            {
                                name: 'sm.ms',
                                url: 'https://sm.ms/api/v2/upload',
                                fieldName: 'smfile',
                                parseResponse: (data) => data.success && data.data?.url ? data.data.url : null
                            }
                        ];

                        for (const service of imageBedServices) {
                            if (service.skip) continue;
                            
                            try {
                                const formData = new FormData();
                                formData.append(service.fieldName, blob, 'image.png');
                                
                                const resp = await fetch(service.url, {
                                    method: 'POST',
                                    body: formData
                                });
                                
                                if (resp.ok) {
                                    const data = await resp.json();
                                    const httpUrl = service.parseResponse(data);
                                    if (httpUrl && (httpUrl.startsWith('http://') || httpUrl.startsWith('https://'))) {
                                        console.log(`拓展图片: 使用${service.name}图床上传成功，获取HTTP URL:`, httpUrl);
                                        return httpUrl;
                                    }
                                }
                            } catch (e) {
                                console.warn(`拓展图片: ${service.name}图床上传失败:`, e);
                                continue;
                            }
                        }

                        // 如果所有上传方式都失败，返回null
                        console.warn('拓展图片: 所有上传方式都失败，无法获取HTTP URL');
                        return null;
                    }

                    // 其他格式，直接返回
                    return imageUrl;
                } catch (error) {
                    console.error('拓展图片: 上传图片失败:', error);
                    return null;
                }
            };

            // 缩放图片到合理尺寸（用于Veo接口，避免图片过大）
            const resizeImageForVeo = async (imageUrl, maxWidth = 1920, maxHeight = 1920) => {
                return new Promise((resolve, reject) => {
                    const img = new Image();
                    img.crossOrigin = 'anonymous';
                    
                    img.onload = () => {
                        const originalWidth = img.width;
                        const originalHeight = img.height;
                        
                        // 如果图片尺寸已经小于等于目标尺寸，直接返回原图
                        if (originalWidth <= maxWidth && originalHeight <= maxHeight) {
                            console.log(`Veo: 图片尺寸 ${originalWidth}x${originalHeight} 无需缩放`);
                            if (imageUrl.startsWith('data:')) {
                                resolve(imageUrl);
                            } else {
                                // 如果是URL，转换为data URL
                                getBase64FromUrl(imageUrl).then(base64 => {
                                    resolve(`data:image/png;base64,${base64}`);
                                }).catch(reject);
                            }
                            return;
                        }
                        
                        // 计算缩放后的尺寸，保持宽高比
                        let newWidth = originalWidth;
                        let newHeight = originalHeight;
                        
                        if (originalWidth > maxWidth || originalHeight > maxHeight) {
                            const scale = Math.min(maxWidth / originalWidth, maxHeight / originalHeight);
                            newWidth = Math.round(originalWidth * scale);
                            newHeight = Math.round(originalHeight * scale);
                            
                            // 确保尺寸是偶数（某些编码器要求）
                            newWidth = newWidth % 2 === 0 ? newWidth : newWidth - 1;
                            newHeight = newHeight % 2 === 0 ? newHeight : newHeight - 1;
                        }
                        
                        console.log(`Veo: 缩放图片 ${originalWidth}x${originalHeight} -> ${newWidth}x${newHeight}`);
                        
                        // 使用canvas缩放图片
                        const canvas = document.createElement('canvas');
                        canvas.width = newWidth;
                        canvas.height = newHeight;
                        const ctx = canvas.getContext('2d');
                        
                        // 使用高质量缩放
                        ctx.imageSmoothingEnabled = true;
                        ctx.imageSmoothingQuality = 'high';
                        ctx.drawImage(img, 0, 0, newWidth, newHeight);
                        
                        // 转换为data URL
                        const dataUrl = canvas.toDataURL('image/png', 0.95);
                        resolve(dataUrl);
                    };
                    
                    img.onerror = (e) => {
                        console.error('Veo: 图片加载失败', e);
                        reject(new Error('图片加载失败'));
                    };
                    
                    // 设置图片源
                    if (imageUrl.startsWith('data:')) {
                        img.src = imageUrl;
                    } else if (imageUrl.startsWith('blob:')) {
                        img.src = imageUrl;
                    } else {
                        // 对于其他URL，先转换为blob再加载（避免CORS问题）
                        getBlobFromUrl(imageUrl).then(blob => {
                            const blobUrl = URL.createObjectURL(blob);
                            img.src = blobUrl;
                        }).catch(reject);
                    }
                });
            };

            const disconnectConnection = (connectionId) => {
                setConnections(prev => {
                    const filtered = prev.filter(conn => conn.id !== connectionId);
                    // 触发节点重新渲染，确保引用成功区域正确更新
                    return filtered;
                });
            };

            const handleDrop = (nodeId, e) => {
                e.preventDefault(); e.stopPropagation();
                e.currentTarget.classList.remove('drag-over');
                const files = Array.from(e.dataTransfer.files);
                const imageFiles = files.filter(file => file.type.startsWith('image/'));
                if (imageFiles.length > 0) {
                    const file = imageFiles[0];
                    const reader = new FileReader();
                    reader.onload = async (ev) => {
                        const content = ev.target.result;
                        let dimensions = { w: 0, h: 0 };
                        try { dimensions = await getImageDimensions(content); } catch (e) {}
                        setNodes((prev) => prev.map((n) => n.id === nodeId ? { ...n, content: content, dimensions } : n));
                    };
                    reader.readAsDataURL(file);
                }
            };

            const handleDragOver = (e) => { e.preventDefault(); e.stopPropagation(); e.currentTarget.classList.add('drag-over'); };
            const handleDragLeave = (e) => { e.preventDefault(); e.stopPropagation(); e.currentTarget.classList.remove('drag-over'); };

            useEffect(() => {
                const handleGlobalPaste = (e) => {
                    const currentSelectedId = selectedNodeIdRef.current;
                    let targetNode = null;
                    if (currentSelectedId) {
                         targetNode = nodesRef.current.find(n => n.id === currentSelectedId);
                    }
                    // If no specific node selected, find the only input-image node if exists
                    if (!targetNode) {
                        const inputNodes = nodesRef.current.filter(n => n.type === 'input-image');
                        if (inputNodes.length === 1) targetNode = inputNodes[0];
                    }

                    if (!targetNode || targetNode.type !== 'input-image') return;
                    
                    const items = Array.from(e.clipboardData.items);
                    const imageItem = items.find(item => item.type.startsWith('image/'));
                    
                    if (imageItem) {
                        e.preventDefault(); 
                        const file = imageItem.getAsFile();
                        if (file) {
                        const reader = new FileReader();
                        reader.onload = async (ev) => {
                            const content = ev.target.result;
                            let dimensions = { w: 0, h: 0 };
                            try { dimensions = await getImageDimensions(content); } catch (e) {}
                            setNodes((prev) => prev.map((n) => n.id === targetNode.id ? { ...n, content: content, dimensions } : n));
                        };
                        reader.readAsDataURL(file);
                        }
                    }
                };

                document.addEventListener('paste', handleGlobalPaste);
                return () => { document.removeEventListener('paste', handleGlobalPaste); };
            }, []);

            const pollVeoJob = async (jobId, taskId, baseUrl, apiKey, w, h, attempt = 0) => {
                const maxAttempts = 90; // 增加到90次，支持最长360秒（6分钟）的生成时间
                const delayMs = 4000;

                if (attempt > maxAttempts) {
                    setHistory((prev) => prev.map((hItem) => hItem.id === taskId ? { ...hItem, status: 'failed', errorMsg: 'Veo 轮询超时' } : hItem));
                    return;
                }

                fetch(`${baseUrl}/v2/videos/generations/${jobId}`, {
                    method: 'GET',
                    headers: { Authorization: `Bearer ${apiKey}` },
                })
                .then(async (resp) => {
                    const text = await resp.text();
                    let data;
                    try { data = JSON.parse(text); } catch (err) { setTimeout(() => pollVeoJob(jobId, taskId, baseUrl, apiKey, w, h, attempt + 1), delayMs); return; }

                    console.log('[Tapnow] Veo Poll:', data);
                    const status = data?.data?.status || data?.status || data?.data?.task_status;
                    const progress = data?.data?.progress || data?.progress || '0%';
                    const failReason = data?.data?.fail_reason || data?.fail_reason || '';

                    // 处理成功状态
                    if (status === 'SUCCESS' || status === 'succeeded' || status === 'FINISHED' || status === 'completed') {
                        const videoUrl = data?.data?.output || data?.output || data?.data?.video_url || data?.video_url || data?.data?.data?.output;
                        if (!videoUrl) {
                            console.warn('[Tapnow] Veo: 任务成功但未找到视频URL', data);
                            setHistory((prev) => prev.map((hItem) => hItem.id === taskId ? { ...hItem, status: 'failed', errorMsg: '未找到视频URL' } : hItem));
                            return;
                        }
                        console.log('[Tapnow] Veo: 任务成功，视频URL:', videoUrl);
                        const endTime = Date.now();
                        // 在更新 history 之前，先获取 sourceNodeId 和 ratio
                        // 使用函数式更新来确保获取最新的 historyItem
                        setHistory((prev) => {
                            const historyItem = prev.find(h => h.id === taskId);
                            const sourceNodeId = historyItem?.sourceNodeId;
                            const originalRatio = historyItem?.ratio;
                            const durationMs = endTime - (historyItem?.startTime || endTime);
                            
                            console.log('[Tapnow] Veo: 从历史记录获取信息', { taskId, originalRatio, sourceNodeId, historyItem });
                            
                            // 对于 veo3.1，尝试从实际视频获取真实尺寸
                            let finalW = w, finalH = h;
                            
                            // 异步获取视频尺寸并更新（使用 Promise）
                            (async () => {
                                try {
                                    const videoMeta = await getVideoMetadata(videoUrl);
                                    if (videoMeta && videoMeta.w > 0 && videoMeta.h > 0) {
                                        console.log('[Tapnow] Veo: 获取到视频实际尺寸', { w: videoMeta.w, h: videoMeta.h, requestedRatio: originalRatio });
                                        const actualW = videoMeta.w;
                                        const actualH = videoMeta.h;
                                        
                                        // 验证实际尺寸是否匹配请求的 aspect_ratio
                                        if (originalRatio === '16:9') {
                                            const actualRatio = actualW / actualH;
                                            const expectedRatio = 16/9;
                                            if (Math.abs(actualRatio - expectedRatio) > 0.1) {
                                                console.warn(`[Tapnow] Veo: 视频实际比例 ${actualRatio.toFixed(2)} 不匹配请求的 16:9 (${expectedRatio.toFixed(2)})，后端返回了错误的比例！`);
                                                console.warn(`[Tapnow] Veo: 实际尺寸: ${actualW}x${actualH}, 请求比例: 16:9`);
                                                console.warn(`[Tapnow] Veo: 强制使用请求的 16:9 比例，调整尺寸为: ${w}x${Math.round(w / (16/9))}`);
                                                // 如果后端返回了错误的比例，强制使用请求的比例
                                                finalW = w;
                                                finalH = Math.round(w / (16/9));
                                            } else {
                                                console.log(`[Tapnow] Veo: 视频实际比例匹配 16:9`);
                                                finalW = actualW;
                                                finalH = actualH;
                                            }
                                        } else if (originalRatio === '9:16') {
                                            const actualRatio = actualW / actualH;
                                            const expectedRatio = 9/16;
                                            if (Math.abs(actualRatio - expectedRatio) > 0.1) {
                                                console.warn(`[Tapnow] Veo: 视频实际比例 ${actualRatio.toFixed(2)} 不匹配请求的 9:16 (${expectedRatio.toFixed(2)})，后端返回了错误的比例！`);
                                                console.warn(`[Tapnow] Veo: 实际尺寸: ${actualW}x${actualH}, 请求比例: 9:16`);
                                                console.warn(`[Tapnow] Veo: 强制使用请求的 9:16 比例，调整尺寸为: ${Math.round(h * (9/16))}x${h}`);
                                                // 如果后端返回了错误的比例，强制使用请求的比例
                                                finalW = Math.round(h * (9/16));
                                                finalH = h;
                                            } else {
                                                console.log(`[Tapnow] Veo: 视频实际比例匹配 9:16`);
                                                finalW = actualW;
                                                finalH = actualH;
                                            }
                                        } else {
                                            // 如果没有指定比例，使用实际尺寸
                                            finalW = actualW;
                                            finalH = actualH;
                                        }
                                        
                                        // 更新历史记录
                                        setHistory((prevHistory) => {
                                            return prevHistory.map((hItem) => 
                                                hItem.id === taskId 
                                                    ? { ...hItem, status: 'completed', progress: 100, url: videoUrl, width: finalW, height: finalH, durationMs, ratio: originalRatio || hItem.ratio } 
                                                    : hItem
                                            );
                                        });
                                        
                                        // 更新预览窗口
                                        if (sourceNodeId) {
                                            setTimeout(() => {
                                                console.log('[Tapnow] Veo: 准备更新预览窗口', { taskId, videoUrl, sourceNodeId });
                                                updatePreviewFromTask(taskId, videoUrl, 'video', sourceNodeId);
                                            }, 0);
                                        }
                                    }
                                } catch (e) {
                                    console.warn('[Tapnow] Veo: 无法获取视频实际尺寸，使用请求尺寸', e);
                                    // 如果无法获取实际尺寸，使用请求的尺寸并根据 aspect_ratio 调整
                                    let fallbackW = w, fallbackH = h;
                                    if (originalRatio === '16:9') {
                                        const aspectRatioValue = fallbackW / fallbackH;
                                        if (Math.abs(aspectRatioValue - 16/9) > 0.1) {
                                            fallbackH = Math.round(fallbackW / (16/9));
                                        }
                                    } else if (originalRatio === '9:16') {
                                        const aspectRatioValue = fallbackW / fallbackH;
                                        if (Math.abs(aspectRatioValue - 9/16) > 0.1) {
                                            fallbackW = Math.round(fallbackH * (9/16));
                                        }
                                    }
                                    
                                    // 更新历史记录
                                    setHistory((prevHistory) => {
                                        return prevHistory.map((hItem) => 
                                            hItem.id === taskId 
                                                ? { ...hItem, status: 'completed', progress: 100, url: videoUrl, width: fallbackW, height: fallbackH, durationMs, ratio: originalRatio || hItem.ratio } 
                                                : hItem
                                        );
                                    });
                                    
                                    // 更新预览窗口
                                    if (sourceNodeId) {
                                        setTimeout(() => {
                                            console.log('[Tapnow] Veo: 准备更新预览窗口', { taskId, videoUrl, sourceNodeId });
                                            updatePreviewFromTask(taskId, videoUrl, 'video', sourceNodeId);
                                        }, 0);
                                    }
                                }
                            })();
                            
                            // 先返回原始状态，等待异步操作完成后再更新
                            return prev;
                        });
                        return;
                    }

                    // 处理失败状态
                    if (status === 'FAILED' || status === 'ERROR' || status === 'CANCELLED') {
                        let errorMsg = `任务失败: ${status}`;
                        if (failReason) {
                            try {
                                const reasonObj = typeof failReason === 'string' ? JSON.parse(failReason) : failReason;
                                errorMsg = reasonObj?.message || reasonObj?.code || failReason;
                            } catch (e) {
                                errorMsg = failReason || errorMsg;
                            }
                        }
                        console.error('[Tapnow] Veo: 任务失败', { status, failReason, errorMsg });
                        setHistory((prev) => prev.map((hItem) => hItem.id === taskId ? { ...hItem, status: 'failed', errorMsg } : hItem));
                        return;
                    }

                    // 处理 NOT_START 状态：可能是任务还在队列中，继续等待
                    if (status === 'NOT_START' || status === 'PENDING' || status === 'QUEUED') {
                        console.log(`[Tapnow] Veo: 任务状态 ${status}，进度 ${progress}，继续等待...`);
                        // 对于 NOT_START 状态，进度更新更慢一些，避免频繁更新
                        const currentProgress = parseInt(progress) || 0;
                        setHistory((prev) => prev.map((hItem) => hItem.id === taskId ? { 
                            ...hItem, 
                            status: 'generating', 
                            progress: Math.max(5, currentProgress),
                            errorMsg: status === 'NOT_START' ? '任务已创建，等待处理中...' : undefined
                        } : hItem));
                        setTimeout(() => pollVeoJob(jobId, taskId, baseUrl, apiKey, w, h, attempt + 1), delayMs);
                        return;
                    }

                    // 其他状态（如 PROCESSING、GENERATING 等）：继续轮询
                    const currentProgress = parseInt(progress) || Math.min(95, (attempt * 2) + 10);
                    console.log(`[Tapnow] Veo: 任务状态 ${status}，进度 ${progress}，继续轮询...`);
                    setHistory((prev) => prev.map((hItem) => hItem.id === taskId ? { ...hItem, status: 'generating', progress: currentProgress } : hItem));
                    setTimeout(() => pollVeoJob(jobId, taskId, baseUrl, apiKey, w, h, attempt + 1), delayMs);
                })
                .catch((err) => setTimeout(() => pollVeoJob(jobId, taskId, baseUrl, apiKey, w, h, attempt + 1), delayMs));
            };

            const pollSoraJob = (jobId, taskId, baseUrl, apiKey, w, h, modelId = '', attempt = 0) => {
                const maxAttempts = 80;
                const delayMs = 5000;

                if (attempt > maxAttempts) {
                    setHistory(prev => prev.map(hItem => hItem.id === taskId ? { ...hItem, status: 'failed', errorMsg: 'Sora 轮询超时' } : hItem));
                    return;
                }

                const pollEndpoint = modelId?.includes('grok')
                    ? `${baseUrl}/v2/videos/generations/${encodeURIComponent(jobId)}`
                    : `${baseUrl}/v1/videos/${encodeURIComponent(jobId)}`;

                fetch(pollEndpoint, {
                    method: 'GET',
                    headers: { Authorization: `Bearer ${apiKey}` },
                })
                .then(resp => resp.text())
                .then((text) => {
                    let data;
                    try { data = JSON.parse(text); } catch (err) { setTimeout(() => pollSoraJob(jobId, taskId, baseUrl, apiKey, w, h, modelId, attempt + 1), delayMs); return; }

                    console.log('[Tapnow] Sora/Grok Poll:', data);
                    const status = data?.data?.status || data?.status || data?.data?.task_status || data?.task_status;

                    if (status === 'SUCCESS' || status === 'succeeded' || status === 'FINISHED' || status === 'completed') {
                        const videoUrl = data?.data?.output || data?.output || data?.data?.video_url || data?.data?.url || data?.video_url || data?.url;
                        if (!videoUrl) {
                            setHistory(prev => prev.map(hItem => hItem.id === taskId ? { ...hItem, status: 'failed', errorMsg: '未找到视频URL' } : hItem));
                            return;
                        }
                        const endTime = Date.now();
                        // 在更新 history 之前，先获取 sourceNodeId
                        const historyItem = history.find(h => h.id === taskId);
                        const sourceNodeId = historyItem?.sourceNodeId;
                        const durationMs = endTime - (historyItem?.startTime || endTime);
                        // 使用 setHistory 的回调来确保获取最新的 historyItem
                        setHistory((prev) => {
                            const updated = prev.map((hItem) => hItem.id === taskId ? { ...hItem, status: 'completed', progress: 100, url: videoUrl, width: w, height: h, durationMs } : hItem);
                            // 在状态更新后，立即更新预览窗口
                            const updatedItem = updated.find(h => h.id === taskId);
                            if (updatedItem?.sourceNodeId) {
                                setTimeout(() => {
                                    console.log('[Tapnow] Sora: 准备更新预览窗口', { taskId, videoUrl, sourceNodeId: updatedItem.sourceNodeId });
                                    updatePreviewFromTask(taskId, videoUrl, 'video', updatedItem.sourceNodeId);
                                }, 0);
                            } else {
                                console.warn('[Tapnow] Sora: 未找到 sourceNodeId', { taskId, updatedItem });
                            }
                            return updated;
                        });
                        return;
                    }

                    if (status === 'FAILED' || status === 'ERROR' || status === 'CANCELLED') {
                        setHistory(prev => prev.map(hItem => hItem.id === taskId ? { ...hItem, status: 'failed', errorMsg: `任务失败: ${status}` } : hItem));
                        return;
                    }

                    setHistory(prev => prev.map(hItem => hItem.id === taskId ? { ...hItem, status: 'generating', progress: Math.min(95, (hItem.progress || 10) + 2) } : hItem));
                    setTimeout(() => pollSoraJob(jobId, taskId, baseUrl, apiKey, w, h, modelId, attempt + 1), delayMs);
                })
                .catch(err => setTimeout(() => pollSoraJob(jobId, taskId, baseUrl, apiKey, w, h, modelId, attempt + 1), delayMs));
            };

            // 切割Midjourney返回的4张图（2x2网格）
            // 压缩图片以减少存储大小
            const compressImage = (dataUrl, maxWidth = 1024, quality = 0.8) => {
                return new Promise((resolve) => {
                    const img = new Image();
                    img.onload = () => {
                        const canvas = document.createElement('canvas');
                        const ctx = canvas.getContext('2d');
                        
                        // 计算压缩后的尺寸
                        let width = img.width;
                        let height = img.height;
                        if (width > maxWidth || height > maxWidth) {
                            const scale = maxWidth / Math.max(width, height);
                            width = Math.floor(width * scale);
                            height = Math.floor(height * scale);
                        }
                        
                        canvas.width = width;
                        canvas.height = height;
                        
                        // 绘制并压缩
                        ctx.drawImage(img, 0, 0, width, height);
                        // 使用JPEG格式压缩，减少文件大小
                        const compressed = canvas.toDataURL('image/jpeg', quality);
                        resolve(compressed);
                    };
                    img.onerror = () => resolve(dataUrl); // 如果压缩失败，返回原图
                    img.src = dataUrl;
                });
            };

            const splitMidjourneyImage = async (imageUrl, ratio = '1:1') => {
                return new Promise((resolve, reject) => {
                    const img = new Image();
                    img.crossOrigin = 'anonymous';
                    
                    // 设置超时，防止图片加载卡死
                    const timeout = setTimeout(() => {
                        reject(new Error('图片加载超时'));
                    }, 30000); // 30秒超时
                    
                    img.onload = () => {
                        clearTimeout(timeout);
                        try {
                            const canvas = document.createElement('canvas');
                            const ctx = canvas.getContext('2d');
                            
                            // Midjourney返回的是2x2网格，每张图是原图的1/4
                            // 计算每张图的尺寸（使用Math.floor确保整数像素）
                            const singleWidth = Math.floor(img.width / 2);
                            const singleHeight = Math.floor(img.height / 2);
                            
                            // 计算实际每张图的比例
                            const actualRatio = singleWidth / singleHeight;
                            
                            const images = [];
                            
                            // 切割4张图：左上、右上、左下、右下
                            for (let row = 0; row < 2; row++) {
                                for (let col = 0; col < 2; col++) {
                                    // 计算裁剪区域（确保不超出边界）
                                    const cropX = Math.max(0, Math.min(col * singleWidth, img.width - singleWidth));
                                    const cropY = Math.max(0, Math.min(row * singleHeight, img.height - singleHeight));
                                    const cropW = Math.min(singleWidth, img.width - cropX);
                                    const cropH = Math.min(singleHeight, img.height - cropY);
                                    
                                    // 设置canvas尺寸
                                    canvas.width = cropW;
                                    canvas.height = cropH;
                                    
                                    // 清空canvas并设置白色背景（防止透明区域）
                                    ctx.fillStyle = '#ffffff';
                                    ctx.fillRect(0, 0, cropW, cropH);
                                    
                                    // 提取图片区域
                                    ctx.drawImage(
                                        img,
                                        cropX, cropY, cropW, cropH,
                                        0, 0, cropW, cropH
                                    );
                                    
                                    // 使用PNG格式，保持图片质量
                                    const dataUrl = canvas.toDataURL('image/png');
                                    images.push({
                                        url: dataUrl,
                                        width: cropW,
                                        height: cropH,
                                        ratio: actualRatio
                                    });
                                }
                            }
                            
                            console.log(`Midjourney: 切割图片完成，原图尺寸 ${img.width}x${img.height}，每张图尺寸 ${singleWidth}x${singleHeight}，比例 ${actualRatio.toFixed(2)}`);
                            resolve(images);
                        } catch (error) {
                            console.error('Midjourney: 切割图片时出错:', error);
                            reject(error);
                        }
                    };
                    
                    img.onerror = (e) => {
                        clearTimeout(timeout);
                        console.error('Midjourney: Failed to load image for splitting:', e);
                        reject(new Error('图片加载失败'));
                    };
                    
                    img.src = imageUrl;
                });
            };

            // Midjourney任务轮询函数
            const pollMidjourneyJob = (jobId, taskId, baseUrl, apiKey, mjMode = 'fast', w, h, attempt = 0) => {
                const maxAttempts = 120; // 最多轮询120次（约10分钟，假设每次5秒）
                const delayMs = 5000; // 每5秒轮询一次

                if (attempt > maxAttempts) {
                    setHistory((prev) => prev.map((hItem) => 
                        hItem.id === taskId 
                            ? { ...hItem, status: 'failed', errorMsg: 'Midjourney 轮询超时' } 
                            : hItem
                    ));
                    return;
                }

                fetch(`${baseUrl}/${mjMode}/mj/task/${jobId}/fetch`, {
                    method: 'GET',
                    headers: { 
                        Authorization: `Bearer ${apiKey}`,
                        'Content-Type': 'application/json'
                    },
                })
                .then((resp) => resp.text())
                .then((text) => {
                    let data;
                    try { 
                        data = JSON.parse(text); 
                    } catch (err) { 
                        console.error('Midjourney: Failed to parse response:', err);
                        setTimeout(() => pollMidjourneyJob(jobId, taskId, baseUrl, apiKey, mjMode, w, h, attempt + 1), delayMs); 
                        return; 
                    }

                    console.log('[Tapnow] Midjourney Poll:', data);
                    
                    const status = data?.status || '';
                    const progress = data?.progress || '0%';
                    const imageUrl = data?.imageUrl || '';
                    const failReason = data?.failReason || '';
                    const buttons = data?.buttons || [];

                    // 解析进度百分比
                    let progressNum = 0;
                    if (typeof progress === 'string' && progress.includes('%')) {
                        progressNum = parseInt(progress.replace('%', ''), 10) || 0;
                    } else if (typeof progress === 'number') {
                        progressNum = progress;
                    }

                    // 更新历史记录
                    setHistory((prev) => prev.map((hItem) => {
                        if (hItem.id === taskId) {
                            let newStatus = hItem.status;
                            let newErrorMsg = hItem.errorMsg;
                            let newProgress = progressNum;

                            if (status === 'SUCCESS' || status === 'FINISHED') {
                                newStatus = 'completed';
                                newProgress = 100;
                                newErrorMsg = null;
                                
                                // 如果是Midjourney任务且有图片URL，切割成4张图（拓展图片任务不需要切割）
                                if (imageUrl && hItem.apiConfig?.modelId?.includes('mj') && hItem.apiConfig?.modelId !== 'mj-zoom') {
                                    // 获取比例信息（从prompt中提取或使用默认值）
                                    let ratio = '1:1';
                                    if (hItem.prompt && hItem.prompt.includes('--ar ')) {
                                        const arMatch = hItem.prompt.match(/--ar\s+([\d:]+)/);
                                        if (arMatch && arMatch[1]) {
                                            ratio = arMatch[1];
                                        }
                                    }
                                    
                                    // 异步切割图片，不阻塞状态更新
                                    // 先更新状态，显示原图，避免白屏
                                    setHistory((prev) => prev.map((hItem) => 
                                        hItem.id === taskId 
                                            ? { ...hItem, url: imageUrl, mjRatio: ratio, mjOriginalUrl: imageUrl, mjNeedsSplit: true } 
                                            : hItem
                                    ));
                                    
                                    // 立即将完整原图同步到预览窗口（不裁剪）
                                    // 直接传入 sourceNodeId，避免依赖可能未更新的 history 状态
                                    // 使用 setTimeout 确保在下一个事件循环中执行，避免状态更新冲突
                                    const sourceNodeIdForPreview = hItem.sourceNodeId;
                                    if (sourceNodeIdForPreview) {
                                        setTimeout(() => {
                                            console.log('[Tapnow] Midjourney: 准备更新预览窗口', { taskId, imageUrl, sourceNodeId: sourceNodeIdForPreview });
                                            updatePreviewFromTask(taskId, imageUrl, 'image', sourceNodeIdForPreview);
                                        }, 0);
                                    } else {
                                        console.warn('[Tapnow] Midjourney: 未找到 sourceNodeId，无法更新预览窗口', { taskId, hItem });
                                    }
                                    
                                    // 延迟切割，确保UI先更新显示原图，避免白屏
                                    setTimeout(() => {
                                        splitMidjourneyImage(imageUrl, ratio).then((splitImages) => {
                                            // 提取URL数组（兼容新旧格式）
                                            const imageUrls = splitImages.map(img => typeof img === 'string' ? img : img.url);
                                            const firstImage = splitImages[0];
                                            const firstUrl = typeof firstImage === 'string' ? firstImage : firstImage.url;
                                            
                                            setHistory((prev) => prev.map((hItem) => 
                                                hItem.id === taskId 
                                                    ? { 
                                                        ...hItem, 
                                                        mjImages: imageUrls, 
                                                        url: firstUrl, 
                                                        selectedMjImageIndex: 0,
                                                        mjRatio: ratio,
                                                        mjOriginalUrl: imageUrl, // 保存原图URL
                                                        mjNeedsSplit: false, // 标记已切割
                                                        mjImageInfo: splitImages.map(img => typeof img === 'string' ? null : { width: img.width, height: img.height, ratio: img.ratio })
                                                    } 
                                                    : hItem
                                            ));
                                        }).catch((err) => {
                                            console.error('Midjourney: Failed to split image:', err);
                                            // 如果切割失败，保持原图显示，标记需要重新切割
                                            setHistory((prev) => prev.map((hItem) => 
                                                hItem.id === taskId 
                                                    ? { ...hItem, url: imageUrl, mjRatio: ratio, mjOriginalUrl: imageUrl, mjNeedsSplit: true } 
                                                    : hItem
                                            ));
                                        });
                                    }, 300); // 延迟300ms，确保原图已完全显示
                                    
                                    // 计算并保存用时
                                    const endTime = Date.now();
                                    const durationMs = endTime - (hItem.startTime || endTime);
                                    
                                    // 先更新状态，图片切割异步进行
                                    return { 
                                        ...hItem, 
                                        status: newStatus, 
                                        progress: newProgress, 
                                        errorMsg: newErrorMsg,
                                        url: imageUrl, // 临时使用原图，切割完成后会更新
                                        width: w,
                                        height: h,
                                        mjButtons: buttons,
                                        mjOriginalUrl: imageUrl, // 保存完整原图URL
                                        durationMs: durationMs
                                    };
                                }
                            } else if (status === 'FAILURE' || status === 'ERROR' || status === 'CANCELLED') {
                                newStatus = 'failed';
                                newErrorMsg = failReason || `任务失败: ${status}`;
                            } else if (status === 'NOT_START' || status === 'SUBMITTED' || status === 'IN_PROGRESS' || status === 'MODAL') {
                                newStatus = 'generating';
                                newErrorMsg = null;
                                // 如果进度为0%，至少显示5%
                                if (newProgress === 0) newProgress = 5;
                            } else {
                                newStatus = 'generating';
                                newErrorMsg = null;
                                // 渐进式更新进度
                                newProgress = Math.min(95, (hItem.progress || 5) + 2);
                            }

                                console.log(`[Tapnow] Midjourney Poll Status Update: Task ${taskId}, Status: ${newStatus}, Progress: ${newProgress}%, ImageUrl: ${imageUrl ? 'Yes' : 'No'}`);
                            
                            const updatedItem = { 
                                ...hItem, 
                                status: newStatus, 
                                progress: newProgress, 
                                errorMsg: newErrorMsg,
                                url: imageUrl || hItem.url,
                                width: w,
                                height: h,
                                mjButtons: buttons // 保存按钮信息，用于后续操作
                            };

                            // 如果任务成功且有图片URL，将结果同步到预览节点（使用完整原图，不裁剪）
                            // 注意：Midjourney任务已经在切割逻辑中处理了预览窗口更新，这里只处理非Midjourney任务
                            // 拓展图片任务（mj-zoom）也需要同步到节点
                            if ((status === 'SUCCESS' || status === 'FINISHED') && imageUrl && (!hItem.apiConfig?.modelId?.includes('mj') || hItem.apiConfig?.modelId === 'mj-zoom')) {
                                // 直接传入 sourceNodeId，避免依赖可能未更新的 history 状态
                                if (hItem.sourceNodeId) {
                                    console.log('[Tapnow] 图片生成: 准备更新节点', { taskId, imageUrl, sourceNodeId: hItem.sourceNodeId, modelId: hItem.apiConfig?.modelId });
                                    // 如果是拓展图片任务，更新拓展图片节点；否则更新预览窗口
                                    if (hItem.apiConfig?.modelId === 'mj-zoom') {
                                        setNodes((prev) => prev.map((n) => 
                                            n.id === hItem.sourceNodeId && n.type === 'expand-image'
                                                ? { ...n, content: imageUrl }
                                                : n
                                        ));
                                    } else {
                                        updatePreviewFromTask(taskId, imageUrl, 'image', hItem.sourceNodeId);
                                    }
                                } else {
                                    console.warn('[Tapnow] 图片生成: 未找到 sourceNodeId', { taskId, hItem });
                                }
                                
                                // 计算并保存用时
                                const endTime = Date.now();
                                const durationMs = endTime - (hItem.startTime || endTime);
                                updatedItem.durationMs = durationMs;
                            }

                            return updatedItem;
                        }
                        return hItem;
                    }));

                    // 如果任务完成或失败，停止轮询
                    if (status === 'SUCCESS' || status === 'FINISHED') {
                        return;
                    }

                    if (status === 'FAILURE' || status === 'ERROR' || status === 'CANCELLED') {
                        return;
                    }

                    // 继续轮询
                    setTimeout(() => pollMidjourneyJob(jobId, taskId, baseUrl, apiKey, mjMode, w, h, attempt + 1), delayMs);
                })
                .catch((err) => {
                    console.error(`[Tapnow] Midjourney Poll Fetch Error for task ${taskId}:`, err);
                    setHistory((prev) => prev.map((hItem) => 
                        hItem.id === taskId 
                            ? { ...hItem, status: 'failed', errorMsg: `轮询请求失败: ${err.message}` } 
                            : hItem
                    ));
                    // 即使出错也继续重试（最多重试3次）
                    if (attempt < 3) {
                        setTimeout(() => pollMidjourneyJob(jobId, taskId, baseUrl, apiKey, mjMode, w, h, attempt + 1), delayMs);
                    }
                });
            };

            const startGeneration = async (prompt, type, sourceImages, nodeId) => {
                const connectedImages = Array.isArray(sourceImages) ? sourceImages : (sourceImages ? [sourceImages] : []);
                const sourceImage = connectedImages.length > 0 ? connectedImages[0] : undefined;

                if (!prompt && !sourceImage) { alert('请输入提示词或连接参考图片'); return; }

                const node = nodes.find((n) => n.id === nodeId);
                const modelId = node?.settings?.model || (type === 'image' ? 'nano-banana' : 'sora-2');
                const config = apiConfigs.find((c) => c.id === modelId);
                const apiKey = config?.key || globalApiKey;
                const baseUrl = (config?.url || DEFAULT_BASE_URL).replace(/\/+$/, '');

                if (!apiKey) { alert('请先在设置中配置 API Key'); setSettingsOpen(true); return; }

                let ratio = node?.settings?.ratio || (modelId.includes('grok') ? '3:2' : '1:1');
                let resolution = node?.settings?.resolution || (modelId.includes('grok') ? '1080P' : 'Auto');
                let { sizeStr, w, h } = getModelParams(modelId, ratio, resolution);

                // Auto Resolution Logic (Direct Source, No Scaling, Just Alignment)
                // Fix: Only use source dimensions if Ratio is ALSO Auto. If user picks a ratio (e.g. 1:1), respect that.
                if (resolution === 'Auto' && ratio === 'Auto' && sourceImage) {
                    try {
                        const dims = await getImageDimensions(sourceImage);
                        // Force original size (aligned to 64) without downscaling
                        const safeW = Math.round(dims.w / 64) * 64;
                        const safeH = Math.round(dims.h / 64) * 64;
                        
                        w = safeW;
                        h = safeH;
                        sizeStr = `${safeW}x${safeH}`;
                        console.log(`[Auto Res] Using Source Dimensions: ${sizeStr}`);
                    } catch (e) { console.error("Auto Res Error", e); }
                } else {
                    if (!w || !h) {
                         const def = calculateResolution(ratio, resolution);
                         w = def.w;
                         h = def.h;
                         sizeStr = def.str;
                    }
                }

                // 当有参考图且选择了 Auto + (1K/2K/4K) 时：
                // 希望保持原图纵横比，只在原图分辨率基础上等比放大到目标级别（而不是变成固定 1:1 或 16:9）
                if (sourceImage && ratio === 'Auto' && ['1K', '2K', '4K'].includes(resolution)) {
                    try {
                        const dims = await getImageDimensions(sourceImage);
                        const longSideTarget = resolution === '4K'
                            ? 4096
                            : resolution === '2K'
                                ? 2048
                                : 1024;

                        const maxSide = Math.max(dims.w, dims.h) || 1;
                        const scale = longSideTarget / maxSide;
                        let newW = Math.round((dims.w * scale) / 16) * 16;
                        let newH = Math.round((dims.h * scale) / 16) * 16;

                        // 双保险，避免数值异常
                        newW = Math.max(16, newW);
                        newH = Math.max(16, newH);

                        w = newW;
                        h = newH;
                        sizeStr = `${newW}x${newH}`;
                        console.log(`[Auto+${resolution}] Upscale from ${dims.w}x${dims.h} -> ${sizeStr}`);
                    } catch (e) {
                        console.error('Auto+K Upscale Error', e);
                    }
                }

                let duration = node?.settings?.duration?.replace('s', '') || '5';
                if (modelId.includes('veo')) duration = '8'; else if (modelId.includes('hailuo')) duration = '6';

                const taskId = Date.now().toString();

                    // 获取正确的模型显示名称（用于历史记录）
                    const getModelDisplayName = () => {
                        // 如果是jimeng模型，根据modelId确定正确的provider名称
                        if (modelId.includes('jimeng-4.5')) return 'Jimeng 4.5';
                        if (modelId.includes('jimeng-4.1')) return 'Jimeng 4.1';
                        if (modelId.includes('jimeng-3.1')) return 'Jimeng 3.1';
                        // 其他模型使用config中的provider，如果没有则使用modelId
                        return config?.provider || modelId;
                    };
                
                const now = Date.now();
                setHistory((prev) => [{
                    id: taskId, type, url: '',
                    prompt: prompt || (sourceImage ? `Img2${type === 'image' ? 'Img' : 'Vid'}` : 'Untitled'),
                    time: new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),
                    status: 'generating', progress: 5, modelName: getModelDisplayName(), width: w, height: h,
                    remoteTaskId: null, 
                    apiConfig: { modelId, baseUrl, apiKey },
                    sourceNodeId: node?.id || null,
                    startTime: now,
                    durationMs: null,
                    ratio: ratio // 保存比例信息，用于后续验证返回结果
                }, ...prev]);
                setHistoryOpen(true);

                try {
                    if (type === 'image') {
                        let endpoint = `${baseUrl}/v1/images/generations`;
                        let payload;
                        let useMultipart = false;

                        const isBananaLike = modelId.includes('banana') || modelId.includes('edit') || modelId.includes('qwen');
                        const isOpenAIImage = modelId.includes('gpt') || (config?.modelName ?? '').includes('gpt-image') || (config?.provider ?? '').toLowerCase().includes('gpt-4o image');
                        const isFluxKontext = modelId.includes('flux') || (config?.modelName ?? '').includes('flux-kontext');
                    const isNanoBanana2 = (config?.modelName ?? '').includes('nano-banana-2') || modelId.includes('nano-banana-2');
                    const isMidjourney = modelId.includes('mj') || (config?.provider ?? '').toLowerCase().includes('midjourney');
                    const isJimeng = modelId.includes('jimeng-4.5') || modelId.includes('jimeng-4.1') || modelId.includes('jimeng-3.1') || (config?.modelName ?? '').includes('jimeng-4.5') || (config?.modelName ?? '').includes('jimeng-4.1') || (config?.modelName ?? '').includes('jimeng-3.1');
                    
                    // 获取jimeng模型名称，优先根据modelId判断（用户当前选择的模型），其次使用config中的modelName
                    const getJimengModelName = () => {
                        // 优先根据modelId判断，因为modelId是用户当前选择的模型
                        if (modelId.includes('jimeng-4.5')) return 'jimeng-4.5';
                        if (modelId.includes('jimeng-4.1')) return 'jimeng-4.1';
                        if (modelId.includes('jimeng-3.1')) return 'jimeng-3.1';
                        // 如果modelId无法判断，再使用config中的modelName
                        if (config?.modelName && (config.modelName.includes('jimeng-4.5') || config.modelName.includes('jimeng-4.1') || config.modelName.includes('jimeng-3.1'))) {
                            return config.modelName;
                        }
                        return 'jimeng-4.5'; // 默认使用4.5
                    };

                    const getImageSizeFlag = () => {
                        if (!isNanoBanana2) return undefined;
                        if (resolution === '4K') return '4K';
                        if (resolution === '2K') return '2K';
                        return '1K';
                    };
                    const imageSizeFlag = getImageSizeFlag();
                    const aspect = ratio === 'Auto' ? undefined : ratio;

                        if (connectedImages.length > 0 && isBananaLike) {
                            endpoint = `${baseUrl}/v1/images/edits`;
                            useMultipart = true;
                            const formData = new FormData();
                            formData.append('model', config?.modelName || 'nano-banana');
                            formData.append('prompt', prompt || 'enhance');
                            formData.append('n', '1');
                            formData.append('size', sizeStr);
                        if (aspect) formData.append('aspect_ratio', aspect);
                        if (imageSizeFlag) formData.append('image_size', imageSizeFlag);
                            
                            const blobPromises = connectedImages.map(url => getBlobFromUrl(url));
                            const blobs = await Promise.all(blobPromises);
                            blobs.forEach((blob, i) => {
                                formData.append('image', blob, `input_${i}.png`);
                            });
                            payload = formData;
                        } 
                        else if (isFluxKontext) {
                            // Flux(Dalle3 Edits) 走 multipart /v1/images/edits，支持多参考图
                            endpoint = `${baseUrl}/v1/images/edits`;
                            useMultipart = true;
                            const formData = new FormData();
                            formData.append('model', config?.modelName || 'flux-kontext-pro');
                            formData.append('prompt', prompt || '');
                            if (aspect) formData.append('aspect_ratio', aspect);
                            if (sizeStr) formData.append('size', sizeStr);
                            // 参考图：优先 connectedImages，其次 sourceImage
                            const refs = connectedImages.length > 0 ? connectedImages : (sourceImage ? [sourceImage] : []);
                            if (refs.length > 0) {
                                const blobPromises = refs.map(url => getBlobFromUrl(url));
                                const blobs = await Promise.all(blobPromises);
                                blobs.forEach((blob, i) => formData.append('image', blob, `flux_ref_${i}.png`));
                            }
                            payload = formData;
                        }
                        else if (isOpenAIImage) {
                            let finalPrompt = prompt || '';
                            const jsonBody = { 
                                model: config?.modelName || 'gpt-4o-image', 
                                prompt: finalPrompt, 
                                size: sizeStr, 
                                aspect_ratio: ratio 
                            };
                            
                            if (connectedImages.length > 0) {
                                const b64Promises = connectedImages.map(url => getBase64FromUrl(url));
                                const b64s = await Promise.all(b64Promises);
                                jsonBody.image = b64s.map(b => `data:image/png;base64,${b}`);
                            }
                            payload = jsonBody;
                    } else if (isNanoBanana2) {
                        payload = {
                            model: config?.modelName,
                            prompt,
                            n: 1,
                            response_format: 'url',
                            size: sizeStr,
                            ...(aspect ? { aspect_ratio: aspect } : {}),
                            ...(imageSizeFlag ? { image_size: imageSizeFlag } : {}),
                        };
                    } else if (isMidjourney) {
                        // Midjourney API: 使用 /mj/submit/imagine 接口
                        // 根据文档，支持fast和relax两种模式，通过URL路径区分
                        // 默认使用fast模式，可以通过配置或设置选择
                        const mjMode = node?.settings?.mjMode || 'fast'; // fast 或 relax
                        const mjVersion = node?.settings?.mjVersion || '--v 7';
                        
                        // 构建prompt，添加版本参数、比例参数和其他指令
                        let mjPrompt = prompt || '';
                        
                        // 添加比例参数 --ar（如果比例不是Auto）
                        if (ratio && ratio !== 'Auto') {
                            // 将比例转换为Midjourney格式，例如 1:1 -> --ar 1:1
                            if (!mjPrompt.includes('--ar ')) {
                                mjPrompt = `${mjPrompt} --ar ${ratio}`.trim();
                            }
                        }
                        
                        // 获取连接的图片（优先使用连接的图片，如果没有连接则使用手动输入的URL）
                        const orefConnected = getConnectedImageForInput(nodeId, 'oref');
                        const srefConnected = getConnectedImageForInput(nodeId, 'sref');
                        
                        // 收集所有需要上传的data URL图片（oref、sref和默认垫图）
                        const imagesToUpload = []; // 需要上传的data URL图片
                        const imageIndexMap = new Map(); // 记录每个图片在数组中的索引，用于映射上传后的URL
                        let orefImageUrl = null; // 用于在prompt中引用的URL
                        let srefImageUrl = null; // 用于在prompt中引用的URL
                        let defaultImageUrls = []; // 默认垫图的URL列表
                        
                        // 处理oref图片
                        const orefUrl = orefConnected || (node?.settings?.mjOref && node.settings.mjOref.trim());
                        if (orefUrl && orefUrl.trim()) {
                            let finalOrefUrl = orefUrl.trim();
                            // 如果是HTTP/HTTPS URL，直接使用
                            if (finalOrefUrl.startsWith('http://') || finalOrefUrl.startsWith('https://')) {
                                orefImageUrl = finalOrefUrl;
                            } 
                            // 如果是data URL，需要先上传获取HTTP URL
                            else if (finalOrefUrl.startsWith('data:')) {
                                imagesToUpload.push(finalOrefUrl);
                                imageIndexMap.set('oref', imagesToUpload.length - 1);
                            } else {
                                // 其他格式，尝试直接使用
                                orefImageUrl = finalOrefUrl;
                            }
                        }
                        
                        // 处理sref图片
                        const srefUrl = srefConnected || (node?.settings?.mjSref && node.settings.mjSref.trim());
                        if (srefUrl && srefUrl.trim()) {
                            let finalSrefUrl = srefUrl.trim();
                            // 如果是HTTP/HTTPS URL，直接使用
                            if (finalSrefUrl.startsWith('http://') || finalSrefUrl.startsWith('https://')) {
                                srefImageUrl = finalSrefUrl;
                            } 
                            // 如果是data URL，需要先上传获取HTTP URL
                            else if (finalSrefUrl.startsWith('data:')) {
                                imagesToUpload.push(finalSrefUrl);
                                imageIndexMap.set('sref', imagesToUpload.length - 1);
                            } else {
                                // 其他格式，尝试直接使用
                                srefImageUrl = finalSrefUrl;
                            }
                        }
                        
                        // 处理默认垫图（非oref/sref连接的图片）
                        if (connectedImages.length > 0) {
                            for (const img of connectedImages) {
                                const isOrefImage = orefConnected && img === orefConnected;
                                const isSrefImage = srefConnected && img === srefConnected;
                                if (!isOrefImage && !isSrefImage) {
                                    if (img.startsWith('http://') || img.startsWith('https://')) {
                                        // HTTP URL直接使用
                                        defaultImageUrls.push(img);
                                    } else if (img.startsWith('data:')) {
                                        // data URL需要上传
                                        imagesToUpload.push(img);
                                        imageIndexMap.set(`default_${defaultImageUrls.length}`, imagesToUpload.length - 1);
                                        // 先占位，上传后会替换
                                        defaultImageUrls.push(null);
                                    } else {
                                        // 其他格式，尝试直接使用
                                        defaultImageUrls.push(img);
                                    }
                                }
                            }
                        }
                        
                        // 如果有需要上传的图片，先上传获取URL
                        if (imagesToUpload.length > 0) {
                            try {
                                console.log(`Midjourney: 正在上传 ${imagesToUpload.length} 张图片获取URL...`);
                                const uploadedUrls = await uploadMidjourneyImages(imagesToUpload, baseUrl, apiKey);
                                
                                // 映射上传后的URL
                                if (imageIndexMap.has('oref')) {
                                    const index = imageIndexMap.get('oref');
                                    if (uploadedUrls[index]) {
                                        orefImageUrl = uploadedUrls[index];
                                        console.log('Midjourney: oref图片上传成功，获取URL:', orefImageUrl);
                                    }
                                }
                                
                                if (imageIndexMap.has('sref')) {
                                    const index = imageIndexMap.get('sref');
                                    if (uploadedUrls[index]) {
                                        srefImageUrl = uploadedUrls[index];
                                        console.log('Midjourney: sref图片上传成功，获取URL:', srefImageUrl);
                                    }
                                }
                                
                                // 更新默认垫图的URL
                                for (let i = 0; i < defaultImageUrls.length; i++) {
                                    if (defaultImageUrls[i] === null) {
                                        const key = `default_${i}`;
                                        if (imageIndexMap.has(key)) {
                                            const index = imageIndexMap.get(key);
                                            if (uploadedUrls[index]) {
                                                defaultImageUrls[i] = uploadedUrls[index];
                                                console.log(`Midjourney: 默认垫图${i}上传成功，获取URL:`, defaultImageUrls[i]);
                                            }
                                        }
                                    }
                                }
                            } catch (error) {
                                console.error('Midjourney: 图片上传失败:', error);
                                setHistory((prev) => prev.map((hItem) => 
                                    hItem.id === taskId 
                                        ? { ...hItem, status: 'failed', progress: 0, errorMsg: `图片上传失败: ${error.message}` } 
                                        : hItem
                                ));
                                return;
                            }
                        }
                        
                        // 过滤掉null值（上传失败的图片）
                        defaultImageUrls = defaultImageUrls.filter(url => url !== null);
                        
                        // 构建prompt：按照Midjourney格式
                        // 格式：默认垫图URL（在提示词前面，空格分隔）+ 文本提示词 + 版本 + 尺寸 + --oref [URL] + --ow [数值] + --sref [URL]
                        let finalMjPrompt = '';
                        
                        // 1. 首先添加默认垫图的URL（在提示词前面，用空格分隔）
                        if (defaultImageUrls.length > 0) {
                            finalMjPrompt = defaultImageUrls.join(' ') + ' ';
                        }
                        
                        // 2. 添加文本提示词
                        finalMjPrompt += mjPrompt.trim();
                        
                        // 3. 添加版本参数 --v（在提示词后面）
                        if (!finalMjPrompt.includes('--v ') && !finalMjPrompt.includes('--niji ')) {
                            finalMjPrompt = `${finalMjPrompt} ${mjVersion}`.trim();
                        }
                        
                        // 4. 添加比例参数 --ar（在版本后面）
                        if (ratio && ratio !== 'Auto') {
                            if (!finalMjPrompt.includes('--ar ')) {
                                finalMjPrompt = `${finalMjPrompt} --ar ${ratio}`.trim();
                            }
                        }
                        
                        // 5. 添加oref指令和图片URL（在尺寸后面）
                        if (orefImageUrl) {
                            if (!finalMjPrompt.includes('--oref ')) {
                                finalMjPrompt = `${finalMjPrompt} --oref ${orefImageUrl}`.trim();
                            }
                        }
                        
                        // 6. 添加ow指令
                        if (node?.settings?.mjOw && node.settings.mjOw > 0) {
                            const owValue = Math.min(1000, Math.max(1, node.settings.mjOw));
                            if (!finalMjPrompt.includes('--ow ')) {
                                finalMjPrompt = `${finalMjPrompt} --ow ${owValue}`.trim();
                            }
                        }
                        
                        // 7. 添加sref指令和图片URL（在最后）
                        if (srefImageUrl) {
                            if (!finalMjPrompt.includes('--sref ')) {
                                finalMjPrompt = `${finalMjPrompt} --sref ${srefImageUrl}`.trim();
                            }
                        }
                        
                        endpoint = `${baseUrl}/${mjMode}/mj/submit/imagine`;
                        payload = {
                            prompt: finalMjPrompt,
                            base64Array: [] // 不再使用base64Array，所有图片都已上传为URL
                        };
                        
                        // 提交Midjourney任务
                        const mjResp = await fetch(endpoint, {
                            method: 'POST',
                            headers: { 
                                Authorization: `Bearer ${apiKey}`,
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify(payload),
                        });
                        
                        const mjText = await mjResp.text();
                        if (!mjResp.ok) throw new Error(mjText || `Midjourney API error: ${mjResp.status}`);
                        let mjData = JSON.parse(mjText);
                        
                        // 检查响应状态码
                        if (mjData.code !== 1 && mjData.code !== 22) {
                            throw new Error(mjData.description || `Midjourney提交失败: code ${mjData.code}`);
                        }
                        
                        const remoteTaskId = mjData.result;
                        if (!remoteTaskId) throw new Error('未获取到任务ID');
                        
                        // 更新历史记录，保存远程任务ID
                        setHistory((prev) => prev.map((hItem) => 
                            hItem.id === taskId 
                                ? { ...hItem, remoteTaskId, status: mjData.code === 22 ? 'generating' : 'generating', progress: 5 } 
                                : hItem
                        ));
                        
                        // 开始轮询Midjourney任务状态
                        pollMidjourneyJob(remoteTaskId, taskId, baseUrl, apiKey, mjMode, w, h);
                        return;
                    } else if (isJimeng) {
                        // 即梦API处理
                        // 如果有连接的图片，使用图片生成图片接口
                        if (connectedImages.length > 0) {
                            endpoint = `${baseUrl}/v1/images/compositions`;
                            
                            // 确保prompt不为空（图生图也需要prompt）
                            if (!prompt || prompt.trim() === '') {
                                throw new Error('图生图功能需要提供提示词');
                            }
                            
                            // 智能尺寸处理：图生图时，如果ratio为Auto，以输入图片尺寸为准
                            let jimengRatio = ratio;
                            let jimengResolution = '2k'; // 默认2k
                            
                            if (ratio === 'Auto' && sourceImage) {
                                try {
                                    // 获取输入图片的尺寸
                                    const sourceDims = await getImageDimensions(sourceImage);
                                    const sourceW = sourceDims.w;
                                    const sourceH = sourceDims.h;
                                    
                                    // 计算宽高比（简化到常见比例）
                                    const calculateRatio = (w, h) => {
                                        const gcd = (a, b) => b === 0 ? a : gcd(b, a % b);
                                        const divisor = gcd(w, h);
                                        const ratioW = w / divisor;
                                        const ratioH = h / divisor;
                                        
                                        // 映射到常见比例
                                        if (ratioW === 1 && ratioH === 1) return '1:1';
                                        if (ratioW === 4 && ratioH === 3) return '4:3';
                                        if (ratioW === 3 && ratioH === 4) return '3:4';
                                        if (ratioW === 16 && ratioH === 9) return '16:9';
                                        if (ratioW === 9 && ratioH === 16) return '9:16';
                                        if (ratioW === 3 && ratioH === 2) return '3:2';
                                        if (ratioW === 2 && ratioH === 3) return '2:3';
                                        if (ratioW === 21 && ratioH === 9) return '21:9';
                                        // 如果无法匹配，返回最接近的常见比例
                                        const aspectRatio = w / h;
                                        if (Math.abs(aspectRatio - 1) < 0.1) return '1:1';
                                        if (Math.abs(aspectRatio - 4/3) < 0.1) return '4:3';
                                        if (Math.abs(aspectRatio - 3/4) < 0.1) return '3:4';
                                        if (Math.abs(aspectRatio - 16/9) < 0.1) return '16:9';
                                        if (Math.abs(aspectRatio - 9/16) < 0.1) return '9:16';
                                        // 默认返回计算出的比例
                                        return `${ratioW}:${ratioH}`;
                                    };
                                    
                                    jimengRatio = calculateRatio(sourceW, sourceH);
                                    console.log(`[即梦API] 图生图Auto尺寸: 输入图片 ${sourceW}x${sourceH}, 计算比例 ${jimengRatio}`);
                                    
                                    // 处理分辨率
                                    if (resolution === 'Auto') {
                                        // Auto时，使用输入图片的实际尺寸，不进行放大
                                        // 但需要转换为jimeng API支持的分辨率格式
                                        // 根据输入图片的长边确定分辨率
                                        const maxSide = Math.max(sourceW, sourceH);
                                        if (maxSide <= 1024) {
                                            jimengResolution = '1k';
                                        } else if (maxSide <= 2048) {
                                            jimengResolution = '2k';
                                        } else {
                                            jimengResolution = '4k';
                                        }
                                        console.log(`[即梦API] 图生图Auto分辨率: 输入图片最大边 ${maxSide}, 使用分辨率 ${jimengResolution}`);
                                    } else {
                                        // 2K或4K时，在输入图片尺寸基础上进行放大
                                        if (resolution === '1K') jimengResolution = '1k';
                                        else if (resolution === '2K') jimengResolution = '2k';
                                        else if (resolution === '4K') jimengResolution = '4k';
                                        
                                        // 计算放大后的尺寸（保持宽高比）
                                        const longSideTarget = resolution === '4K' ? 4096 : resolution === '2K' ? 2048 : 1024;
                                        const maxSide = Math.max(sourceW, sourceH);
                                        const scale = longSideTarget / maxSide;
                                        const scaledW = Math.round((sourceW * scale) / 16) * 16;
                                        const scaledH = Math.round((sourceH * scale) / 16) * 16;
                                        
                                        console.log(`[即梦API] 图生图${resolution}放大: ${sourceW}x${sourceH} -> ${scaledW}x${scaledH}, 比例 ${jimengRatio}, 分辨率 ${jimengResolution}`);
                                    }
                                } catch (e) {
                                    console.error('[即梦API] 获取输入图片尺寸失败，使用默认值:', e);
                                    // 如果获取尺寸失败，使用默认值
                                    jimengRatio = '1:1';
                                    if (resolution === '1K') jimengResolution = '1k';
                                    else if (resolution === '2K') jimengResolution = '2k';
                                    else if (resolution === '4K') jimengResolution = '4k';
                                }
                            } else {
                                // ratio不是Auto，使用用户选择的值
                                jimengRatio = ratio;
                                
                                // 转换分辨率格式
                                if (resolution === '1K') jimengResolution = '1k';
                                else if (resolution === '2K') jimengResolution = '2k';
                                else if (resolution === '4K') jimengResolution = '4k';
                            }
                            
                            // 即梦图生图：参考测试文件格式，使用JSON格式发送Base64图片数组
                            // 将所有图片（包括URL）都转换为Base64字符串，使用JSON格式发送
                            const imagePromises = connectedImages.map(async (imgUrl, index) => {
                                let base64String;
                                
                                if (imgUrl.startsWith('http://') || imgUrl.startsWith('https://')) {
                                    // HTTP URL，下载并转换为Base64
                                    try {
                                        console.log(`[即梦API] 正在下载URL图片 [${index + 1}/${connectedImages.length}]:`, imgUrl);
                                        const response = await fetch(imgUrl);
                                        if (!response.ok) {
                                            throw new Error(`下载图片失败: ${response.status} ${response.statusText}`);
                                        }
                                        
                                        const blob = await response.blob();
                                        // 转换为Base64
                                        base64String = await new Promise((resolve, reject) => {
                                            const reader = new FileReader();
                                            reader.onloadend = () => {
                                                // 获取完整的data URL，然后提取base64部分
                                                const dataUrl = reader.result;
                                                resolve(dataUrl);
                                            };
                                            reader.onerror = reject;
                                            reader.readAsDataURL(blob);
                                        });
                                        
                                        console.log(`[即梦API] URL图片下载并转换为Base64成功 [${index + 1}/${connectedImages.length}]`);
                                        return base64String;
                                    } catch (err) {
                                        console.error(`[即梦API] URL图片处理失败 [${index + 1}/${connectedImages.length}]:`, err);
                                        throw new Error(`无法处理URL图片: ${imgUrl}。错误: ${err.message}`);
                                    }
                                } else if (imgUrl.startsWith('data:')) {
                                    // Data URL，直接使用（已经是Base64格式）
                                    console.log(`[即梦API] Data URL图片 [${index + 1}/${connectedImages.length}]`);
                                    return imgUrl;
                                } else {
                                    // 其他情况，尝试作为URL处理并下载
                                    try {
                                        const response = await fetch(imgUrl);
                                        const blob = await response.blob();
                                        base64String = await new Promise((resolve, reject) => {
                                            const reader = new FileReader();
                                            reader.onloadend = () => resolve(reader.result);
                                            reader.onerror = reject;
                                            reader.readAsDataURL(blob);
                                        });
                                        return base64String;
                                    } catch (err) {
                                        throw new Error(`无法处理图片: ${imgUrl}`);
                                    }
                                }
                            });
                            
                            const base64Images = await Promise.all(imagePromises);
                            
                            const jimengModelName = getJimengModelName();
                            console.log('[即梦API] 图生图请求参数:', { 
                                endpoint, 
                                model: jimengModelName,
                                modelId,
                                configModelName: config?.modelName,
                                promptLength: prompt.trim().length,
                                promptPreview: prompt.trim().substring(0, 50),
                                ratio: jimengRatio,
                                resolution: jimengResolution,
                                imageCount: connectedImages.length,
                                base64ImageCount: base64Images.length,
                                useJsonFormat: true // 使用JSON格式
                            });
                            
                            // 即梦图生图：使用JSON格式发送Base64图片数组（参考测试文件格式）
                            // 根据参考文件，使用application/json格式，images字段为Base64字符串数组
                            useMultipart = false;
                            payload = {
                                model: jimengModelName,
                                prompt: prompt.trim(),
                                images: base64Images, // Base64字符串数组
                                ratio: jimengRatio,
                                resolution: jimengResolution,
                                response_format: 'url'
                            };
                            
                            console.log('[即梦API] JSON格式请求构建完成，准备发送请求');
                        } else {
                            // 文本生成图片
                            endpoint = `${baseUrl}/v1/images/generations`;
                            
                            // 转换比例格式：Auto -> "1:1" (默认)
                            const jimengRatio = ratio === 'Auto' ? '1:1' : ratio;
                            
                            // 转换分辨率格式：Auto -> "2k" (默认)
                            let jimengResolution = '2k'; // 默认2k
                            if (resolution === '1K') jimengResolution = '1k';
                            else if (resolution === '2K') jimengResolution = '2k';
                            else if (resolution === '4K') jimengResolution = '4k';
                            
                            // 确保prompt不为空
                            if (!prompt || prompt.trim() === '') {
                                throw new Error('提示词不能为空');
                            }
                            
                            const jimengModelName = getJimengModelName();
                            payload = {
                                model: jimengModelName,
                                prompt: prompt.trim(),
                                ratio: jimengRatio,
                                resolution: jimengResolution,
                                response_format: 'url'
                            };
                            
                            console.log('[即梦API] 请求参数:', { 
                                endpoint, 
                                model: payload.model,
                                modelId,
                                configModelName: config?.modelName,
                                ratio: payload.ratio, 
                                resolution: payload.resolution,
                                promptLength: payload.prompt?.length || 0,
                                promptPreview: payload.prompt?.substring(0, 50) || ''
                            });
                        }
                        } else {
                            payload = { model: config?.modelName, prompt, n: 1, size: sizeStr, response_format: 'url' };
                        }

                        // 即梦API使用sessionid作为Bearer token
                        // 注意：使用FormData时，不要手动设置Content-Type，让浏览器自动设置（包含boundary）
                        const headers = useMultipart 
                            ? { Authorization: `Bearer ${apiKey}` } 
                            : { Authorization: `Bearer ${apiKey}`, 'Content-Type': 'application/json' };
                        
                        // 确保endpoint是完整的URL
                        // endpoint可能已经是完整URL（包含baseUrl），也可能只是路径
                        let fullUrl;
                        if (endpoint.startsWith('http://') || endpoint.startsWith('https://')) {
                            fullUrl = endpoint;
                        } else {
                            // 如果endpoint只是路径，需要拼接baseUrl
                            const cleanBaseUrl = baseUrl.replace(/\/+$/, '');
                            fullUrl = `${cleanBaseUrl}${endpoint.startsWith('/') ? endpoint : '/' + endpoint}`;
                        }
                        
                        // 检查payload大小（Base64图片可能很大）
                        const requestBody = useMultipart ? payload : JSON.stringify(payload);
                        const bodySize = typeof requestBody === 'string' ? requestBody.length : 'FormData';
                        
                        console.log('[即梦API] 发送请求:', {
                            url: fullUrl,
                            method: 'POST',
                            headers: { ...headers, Authorization: 'Bearer ***' }, // 隐藏敏感信息
                            useMultipart,
                            bodySize: typeof bodySize === 'number' ? `${(bodySize / 1024 / 1024).toFixed(2)}MB` : bodySize,
                            imageCount: payload.images ? payload.images.length : 0,
                            model: payload.model, // 显示实际发送的模型名称
                            modelId, // 显示用户选择的modelId
                            configModelName: config?.modelName // 显示配置中的modelName
                        });
                        
                        let resp;
                        try {
                            resp = await fetch(fullUrl, {
                                method: 'POST',
                                headers: headers,
                                body: requestBody,
                            });
                        } catch (fetchError) {
                            console.error('[即梦API] Fetch请求失败:', {
                                error: fetchError,
                                url: fullUrl,
                                baseUrl: baseUrl,
                                endpoint: endpoint
                            });
                            
                            // 提供更详细的错误信息
                            let errorMessage = `网络请求失败：无法连接到即梦API服务`;
                            
                            if (fetchError.message && fetchError.message.includes('Failed to fetch')) {
                                errorMessage += `\n\nURL: ${fullUrl}\n\n请检查：\n1. 即梦API代理服务是否正在运行 (${baseUrl})\n2. 服务地址配置是否正确\n3. 网络连接是否正常\n4. 是否有防火墙阻止连接`;
                                
                                // 检查是否是CORS问题
                                if (fullUrl.includes('localhost') || fullUrl.includes('127.0.0.1')) {
                                    errorMessage += `\n5. 如果是本地服务，请确认服务正在运行并监听正确端口`;
                                }
                            } else {
                                errorMessage += `\n\n错误详情: ${fetchError.message || fetchError}`;
                            }
                            
                            throw new Error(errorMessage);
                        }
                        const text = await resp.text();
                        
                        // 先尝试解析响应
                        let data;
                        try {
                            data = JSON.parse(text);
                        } catch (e) {
                            throw new Error(`响应解析失败: ${text.substring(0, 100)}`);
                        }
                        
                        // 检查HTTP状态码错误
                        if (!resp.ok) {
                            // 尝试解析错误信息
                            let errorMsg = text || `Image API error: ${resp.status}`;
                            if (data?.error?.message) {
                                errorMsg = data.error.message;
                            } else if (data?.error) {
                                errorMsg = typeof data.error === 'string' ? data.error : JSON.stringify(data.error);
                            } else if (data?.message) {
                                errorMsg = data.message;
                            } else if (data?.code && data?.message) {
                                errorMsg = data.message;
                            }
                            
                            // 检查是否是后端服务模块缺失错误，优化错误信息显示
                            if (errorMsg.includes('Cannot find module') || errorMsg.includes('octetstream') || errorMsg.includes('MODULE_NOT_FOUND')) {
                                // 提取原始错误信息（去掉可能的重复前缀）
                                const originalError = errorMsg.replace(/后端服务错误[：:].*?错误详情[：:]/g, '').trim();
                                errorMsg = `❌ 即梦API代理服务缺少必要模块\n\n错误：${originalError}\n\n🔧 解决方案：\n1. 停止当前的jimeng-api.exe进程\n2. 重新下载最新版本的jimeng-api\n3. 如果使用Docker，请运行：\n   docker pull ghcr.io/iptag/jimeng-api:latest\n   docker run -d --name jimeng-api -p 5100:5100 ghcr.io/iptag/jimeng-api:latest\n4. 如果直接运行exe，请确保所有文件完整`;
                            }
                            
                            throw new Error(errorMsg);
                        }
                        
                        // 检查即梦API的错误码（即梦API使用code字段表示错误）
                        // code: 0或1表示成功，200表示HTTP成功，其他为错误
                        // 注意：即梦API可能返回负数错误码，如-2001, -1000
                        if (data?.code !== undefined) {
                            // 成功码：0, 1, 200
                            const isSuccess = data.code === 0 || data.code === 1 || data.code === 200;
                            if (!isSuccess) {
                                let errorMsg = data?.message || data?.error || `API错误: code ${data.code}`;
                                
                                // 检查是否是后端服务模块缺失错误，优化错误信息显示
                                if (errorMsg.includes('Cannot find module') || errorMsg.includes('octetstream') || errorMsg.includes('MODULE_NOT_FOUND')) {
                                    // 提取原始错误信息
                                    const originalError = errorMsg.replace(/后端服务错误[：:].*?错误详情[：:]/g, '').trim();
                                    errorMsg = `❌ 即梦API代理服务缺少必要模块\n\n错误：${originalError}\n\n🔧 解决方案：\n1. 停止当前的jimeng-api.exe进程\n2. 重新下载最新版本的jimeng-api\n3. 如果使用Docker，请运行：\n   docker pull ghcr.io/iptag/jimeng-api:latest\n   docker run -d --name jimeng-api -p 5100:5100 ghcr.io/iptag/jimeng-api:latest\n4. 如果直接运行exe，请确保所有文件完整`;
                                } else if (data.code === -1000) {
                                    // 简化-1000错误信息
                                    const originalMsg = errorMsg.replace(/后端服务错误[：:].*?错误详情[：:]/g, '').trim();
                                    if (originalMsg.includes('Cannot find module') || originalMsg.includes('octetstream') || originalMsg.includes('MODULE_NOT_FOUND')) {
                                        errorMsg = `❌ 即梦API代理服务缺少必要模块\n\n错误：${originalMsg}\n\n🔧 解决方案：\n1. 停止当前的jimeng-api.exe进程\n2. 重新下载最新版本的jimeng-api\n3. 如果使用Docker，请运行：\n   docker pull ghcr.io/iptag/jimeng-api:latest`;
                                    } else {
                                        errorMsg = `即梦API服务错误 (错误码: ${data.code})\n\n${originalMsg}`;
                                    }
                                }
                                
                                console.error('[即梦API] 错误响应:', JSON.stringify(data, null, 2));
                                throw new Error(errorMsg);
                            }
                        }
                        
                        // 即梦API响应格式：{ "created": ..., "data": [{ "url": "..." }, ...] }
                        // 4.1模型可能返回4张图片，3.1模型返回1张
                        console.log('[即梦API] 响应数据:', data);
                        
                        const imageData = data?.data || [];
                        if (!imageData || imageData.length === 0) {
                            console.error('[即梦API] 响应数据:', data);
                            throw new Error('No Image URL found in response');
                        }
                        
                        // 获取所有图片URL
                        const imageUrls = imageData.map(item => item?.url).filter(Boolean);
                        if (imageUrls.length === 0) {
                            console.error('[即梦API] 响应数据:', data);
                            throw new Error('No Image URL found in response');
                        }
                        
                        console.log('[即梦API] 获取到图片数量:', imageUrls.length, 'URLs:', imageUrls);
                        
                        // 对于即梦模型，使用第一张图片作为主图片，但保存所有图片
                        const primaryUrl = imageUrls[0];
                        const allUrls = imageUrls.length > 1 ? imageUrls : [primaryUrl];

                        const endTime = Date.now();
                        // 在更新 history 之前，先获取 sourceNodeId
                        const historyItem = history.find(h => h.id === taskId);
                        const sourceNodeId = historyItem?.sourceNodeId;
                        const durationMs = endTime - (historyItem?.startTime || endTime);
                        
                        // 使用 setHistory 的回调来确保获取最新的 historyItem
                        setHistory((prev) => {
                            const updated = prev.map((hItem) => {
                                if (hItem.id === taskId) {
                                    // 获取正确的模型显示名称（确保与发送给后端的模型一致）
                                    const getModelDisplayName = () => {
                                        // 如果是jimeng模型，根据modelId确定正确的provider名称
                                        if (modelId.includes('jimeng-4.5')) return 'Jimeng 4.5';
                                        if (modelId.includes('jimeng-4.1')) return 'Jimeng 4.1';
                                        if (modelId.includes('jimeng-3.1')) return 'Jimeng 3.1';
                                        // 其他模型保持原有的modelName
                                        return hItem.modelName || (config?.provider || modelId);
                                    };
                                    
                                    // 如果是即梦模型且有多张图片，保存所有URL
                                    const updatedItem = {
                                        ...hItem, 
                                        status: 'completed', 
                                        progress: 100, 
                                        url: primaryUrl, 
                                        width: w, 
                                        height: h, 
                                        durationMs,
                                        modelName: isJimeng ? getModelDisplayName() : hItem.modelName // 确保jimeng模型的modelName正确
                                    };
                                    
                                    // 如果是即梦模型，保存所有图片URL（使用mjImages字段以复用显示逻辑）
                                    // 4.1模型返回4张，3.1模型返回1张，但都保存到mjImages中
                                    if (isJimeng) {
                                        if (imageUrls.length > 1) {
                                            updatedItem.mjImages = imageUrls; // 使用mjImages字段，复用Midjourney的显示逻辑
                                            updatedItem.selectedMjImageIndex = 0; // 默认选中第一张
                                        } else if (imageUrls.length === 1) {
                                            // 单张图片也保存，方便统一处理
                                            updatedItem.mjImages = imageUrls;
                                            updatedItem.selectedMjImageIndex = 0;
                                        }
                                    }
                                    
                                    return updatedItem;
                                }
                                return hItem;
                            });
                            
                            // 在状态更新后，立即更新预览窗口
                            const updatedItem = updated.find(h => h.id === taskId);
                            if (updatedItem?.sourceNodeId) {
                                setTimeout(() => {
                                    console.log('[Tapnow] 普通图片生成: 准备更新预览窗口', { taskId, url: primaryUrl, sourceNodeId: updatedItem.sourceNodeId, mjImages: updatedItem.mjImages });
                                    // 如果是即梦模型且有多张图片，传递mjImages数组
                                    updatePreviewFromTask(taskId, primaryUrl, 'image', updatedItem.sourceNodeId, updatedItem.mjImages || null);
                                }, 0);
                            } else {
                                console.warn('[Tapnow] 普通图片生成: 未找到 sourceNodeId', { taskId, updatedItem });
                            }
                            return updated;
                        });
                        return;
                    }

                    if (type === 'video') {
                        // Veo 3.x 图生视频：按 /v2/videos/generations 规范发送 JSON，使用 images 数组而不是 input_image
                        if (modelId.includes('veo')) {
                            const endpoint = `${baseUrl}/v2/videos/generations`;

                            // 根据文档：images 支持 url 或 base64
                            // 对于Veo接口，如果图片过大，自动缩放到合理尺寸（1920x1080等）
                            let images = [];
                            if (connectedImages && connectedImages.length > 0) {
                                // 处理多张图片：先缩放，再转换为data URL
                                images = await Promise.all(connectedImages
                                    .filter(img => img && typeof img === 'string' && img.trim().length > 0)
                                    .map(async (img) => {
                                        const trimmedImg = img.trim();
                                        
                                        // 如果是 http/https URL，先检查尺寸，如果太大就缩放
                                        if (trimmedImg.startsWith('http://') || trimmedImg.startsWith('https://')) {
                                            console.log('Veo: Processing HTTP URL for image');
                                            // 对于URL，先尝试获取尺寸，如果太大就缩放
                                            try {
                                                const dims = await getImageDimensions(trimmedImg);
                                                if (dims.w > 1920 || dims.h > 1920) {
                                                    console.log(`Veo: 图片尺寸 ${dims.w}x${dims.h} 过大，需要缩放`);
                                                    const resized = await resizeImageForVeo(trimmedImg, 1920, 1920);
                                                    return resized;
                                                }
                                                // 尺寸合适，直接使用URL
                                                return trimmedImg;
                                            } catch (e) {
                                                console.warn('Veo: 无法获取图片尺寸，尝试直接使用URL', e);
                                                return trimmedImg;
                                            }
                                        }
                                        
                                        // 对于 data URL、blob URL 或其他格式，统一缩放处理
                                        console.log('Veo: Processing image (data/blob/other format)');
                                        try {
                                            // 先获取尺寸
                                            const dims = await getImageDimensions(trimmedImg);
                                            if (dims.w > 1920 || dims.h > 1920) {
                                                console.log(`Veo: 图片尺寸 ${dims.w}x${dims.h} 过大，需要缩放`);
                                                const resized = await resizeImageForVeo(trimmedImg, 1920, 1920);
                                                return resized;
                                            }
                                            // 尺寸合适，转换为data URL格式
                                            if (trimmedImg.startsWith('data:')) {
                                                return trimmedImg;
                                            } else if (trimmedImg.startsWith('blob:')) {
                                                const base64 = await getBase64FromUrl(trimmedImg);
                                                return `data:image/png;base64,${base64}`;
                                            } else if (trimmedImg.length > 100 && !trimmedImg.includes('://') && !trimmedImg.startsWith('data:')) {
                                                return `data:image/png;base64,${trimmedImg}`;
                                            } else {
                                                const base64 = await getBase64FromUrl(trimmedImg);
                                                return `data:image/png;base64,${base64}`;
                                            }
                                        } catch (e) {
                                            console.error('Veo: Failed to process image:', e);
                                            throw new Error(`无法处理图片格式: ${trimmedImg.substring(0, 50)}...`);
                                        }
                                    }));
                            } else if (sourceImage) {
                                // 单张图片处理：先检查尺寸，如果太大就缩放
                                const trimmedSource = sourceImage.trim();
                                
                                try {
                                    // 先获取图片尺寸
                                    const dims = await getImageDimensions(trimmedSource);
                                    console.log(`Veo: 源图片尺寸 ${dims.w}x${dims.h}`);
                                    
                                    // 如果图片过大，先缩放
                                    if (dims.w > 1920 || dims.h > 1920) {
                                        console.log(`Veo: 图片尺寸 ${dims.w}x${dims.h} 过大，缩放中...`);
                                        const resized = await resizeImageForVeo(trimmedSource, 1920, 1920);
                                        images = [resized];
                                    } else {
                                        // 尺寸合适，根据格式处理
                                        if (trimmedSource.startsWith('http://') || trimmedSource.startsWith('https://')) {
                                            console.log('Veo: Using HTTP URL for source image (尺寸合适)');
                                            images = [trimmedSource];
                                        } else if (trimmedSource.startsWith('data:')) {
                                            console.log('Veo: Using data URL for source image (尺寸合适)');
                                            images = [trimmedSource];
                                        } else if (trimmedSource.startsWith('blob:')) {
                                            console.log('Veo: Converting blob URL to base64 for source image');
                                            const base64 = await getBase64FromUrl(trimmedSource);
                                            images = [`data:image/png;base64,${base64}`];
                                        } else {
                                            if (trimmedSource.length > 100 && !trimmedSource.includes('://') && !trimmedSource.startsWith('data:')) {
                                                images = [`data:image/png;base64,${trimmedSource}`];
                                            } else {
                                                const base64 = await getBase64FromUrl(trimmedSource);
                                                images = [`data:image/png;base64,${base64}`];
                                            }
                                        }
                                    }
                                } catch (e) {
                                    console.error('Veo: Failed to process source image:', e);
                                    throw new Error(`无法处理图片格式: ${e.message}`);
                                }
                            }

                            // 构建 Veo 请求 payload
                            // 根据文档，images 是 required 字段，文生视频时传空数组，图生视频时传图片数据
                            // 图生视频时，确保 images 数组不为空
                            if (images.length === 0 && (connectedImages?.length > 0 || sourceImage)) {
                                console.error('Veo: 图片处理失败，images 数组为空', { connectedImages, sourceImage });
                                throw new Error('图片处理失败：无法获取图片数据');
                            }

                            // 验证图片数据格式：过滤掉无效数据，但不阻止请求发送
                            const validImages = images.filter((img, idx) => {
                                if (!img || typeof img !== 'string') {
                                    console.warn(`Veo: 跳过无效图片（索引 ${idx}）: 不是字符串`);
                                    return false;
                                }
                                if (img === 'base64_data' || img.trim() === 'base64_data') {
                                    console.warn(`Veo: 跳过占位符图片（索引 ${idx}）: base64_data`);
                                    return false;
                                }
                                return true;
                            });

                            if (validImages.length === 0 && (connectedImages?.length > 0 || sourceImage)) {
                                console.error('Veo: 所有图片数据都无效', { images, connectedImages, sourceImage });
                                throw new Error('图片数据格式错误：所有图片数据都无效');
                            }

                            // 对于 veo3.1 系列模型，确保 aspect_ratio 格式正确（只支持 '16:9' 和 '9:16'）
                            let aspectRatio = null;
                            if (ratio && ratio !== 'Auto') {
                                // 确保比例格式符合 API 要求
                                if (ratio === '16:9' || ratio === '9:16') {
                                    aspectRatio = ratio;
                                } else {
                                    // 对于其他比例，根据实际宽高计算最接近的比例
                                    const aspectRatioValue = w / h;
                                    if (Math.abs(aspectRatioValue - 16/9) < Math.abs(aspectRatioValue - 9/16)) {
                                        aspectRatio = '16:9';
                                    } else {
                                        aspectRatio = '9:16';
                                    }
                                }
                            }

                            const veoPayload = {
                                model: config?.modelName || 'veo3.1',
                                prompt,
                                enhance_prompt: false,
                                images: validImages.length > 0 ? validImages : [], // 使用验证后的图片数组
                                // 按接口说明：不传 aspect_ratio 时自动根据参考图匹配；只有非 Auto 时才显式传
                                ...(aspectRatio ? { aspect_ratio: aspectRatio } : {})
                            };

                            // 详细调试日志
                            console.log('Veo: 准备发送请求', {
                                endpoint,
                                model: veoPayload.model,
                                prompt: veoPayload.prompt?.substring(0, 50) + '...',
                                imagesCount: veoPayload.images.length,
                                firstImageType: veoPayload.images[0] ? 
                                    (veoPayload.images[0].startsWith('http') ? 'HTTP URL' : 
                                     veoPayload.images[0].startsWith('data:') ? 'Data URL' : 
                                     'Unknown') : 'empty',
                                firstImagePreview: veoPayload.images[0] ? 
                                    (veoPayload.images[0].startsWith('http') ? 
                                        veoPayload.images[0].substring(0, 80) : 
                                        veoPayload.images[0].substring(0, 100)) : 'empty',
                                aspect_ratio: veoPayload.aspect_ratio,
                                payloadSize: JSON.stringify(veoPayload).length
                            });

                            try {
                                console.log('Veo: 开始发送请求到', endpoint);
                                const resp = await fetch(endpoint, {
                                    method: 'POST',
                                    headers: { 
                                        Authorization: `Bearer ${apiKey}`, 
                                        'Content-Type': 'application/json' 
                                    },
                                    body: JSON.stringify(veoPayload)
                                });
                                
                                console.log('Veo: 收到响应', { status: resp.status, statusText: resp.statusText });
                                const text = await resp.text();
                                console.log('Veo: 响应内容', text.substring(0, 500));
                                
                                if (!resp.ok) {
                                    console.error('Veo: 请求失败', { status: resp.status, text });
                                    throw new Error(text || `Veo error: ${resp.status}`);
                                }
                                
                            const data = JSON.parse(text); 
                                console.log('Veo: 解析后的响应数据', data);
                            const jobId = data?.data?.id || data?.id || data?.task_id || data?.data?.task_id; 
                                
                                if (!jobId) {
                                    console.error('Veo: 未找到 JobId', data);
                                    throw new Error('Veo No JobId');
                                }
                                
                                console.log('Veo: 成功获取 JobId', jobId);
                            setHistory(prev => prev.map(h => h.id === taskId ? { ...h, status: 'generating', progress: 10 } : h));
                            pollVeoJob(jobId, taskId, baseUrl, apiKey, w, h);
                            return;
                            } catch (error) {
                                console.error('Veo: 请求发送失败', error);
                                setHistory(prev => prev.map(h => h.id === taskId ? { ...h, status: 'failed', errorMsg: error.message || '请求发送失败' } : h));
                                throw error;
                            }
                        }

                        let endpoint = '';
                        let body;
                        const headers = { Authorization: `Bearer ${apiKey}` };
                        // 统一将时长转为纯数字秒，避免后端期望 int 时收到字符串
                        const durationValueNum = (() => {
                            if (duration === null || duration === undefined) return 8;
                            const cleaned = String(duration).trim().replace(/[^\d]/g, '');
                            const parsed = parseInt(cleaned, 10);
                            return Number.isFinite(parsed) && parsed > 0 ? parsed : 8;
                        })();

                        // --- Grok-3 Video Logic (Pure JSON Strategy to fix Int type error, align spec /v2/videos/generations) ---
                        if (modelId.includes('grok')) {
                            const endpoint = `${baseUrl}/v2/videos/generations`;
                            // 1. 强制转换为整数 (解决 Go 后端类型错误)
                            const durationInt = parseInt(duration, 10);
                            const aspectRatioStr = ratio && ratio !== 'Auto' ? ratio : '3:2'; // 按官方枚举优先 3:2/2:3/1:1
                            const resolutionStr = (resolution && resolution !== 'Auto') ? resolution : '1080P'; // 官方支持 720P/1080P

                            console.log(`[Grok] Starting generation (JSON Mode). Duration: ${durationInt || 'N/A'} (type: ${typeof durationInt}), ratio: ${aspectRatioStr}, resolution: ${resolutionStr}`);

                            // 2. 准备基础 Payload
                            const payload = {
                                model: config?.modelName || 'grok-video-3',
                                prompt: prompt,
                                ratio: aspectRatioStr,
                                resolution: resolutionStr
                            };
                            if (Number.isFinite(durationInt) && durationInt > 0) {
                                payload.duration = durationInt;
                            }

                            // 3. 处理图片：转为 Base64 字符串
                            if (sourceImage) {
                                try {
                                    console.log('[Grok] Converting image to Base64...');
                                    let base64Data = '';
                                    
                                    if (sourceImage.startsWith('data:')) {
                                        base64Data = sourceImage; // 已经是 Base64
                                    } else {
                                        // 下载 blob 或 url 并转换
                                        const blob = await getBlobFromUrl(sourceImage);
                                        base64Data = await new Promise((resolve, reject) => {
                                            const reader = new FileReader();
                                            reader.onloadend = () => resolve(reader.result);
                                            reader.onerror = reject;
                                            reader.readAsDataURL(blob);
                                        });
                                    }
                                    
                                    // 将完整的 data URI 放入 images 数组（官方字段）
                                    payload.images = [base64Data]; 
                                } catch (e) {
                                    console.error('Grok Image Conversion Failed:', e);
                                    alert('图片处理失败，请检查图片链接或跨域设置');
                                    return;
                                }
                            }

                            // 4. 发送纯 JSON 请求
                            const resp = await fetch(endpoint, {
                                method: 'POST',
                                headers: { 
                                    'Authorization': `Bearer ${apiKey}`,
                                    'Content-Type': 'application/json' // 必须是 JSON
                                },
                                body: JSON.stringify(payload)
                            });
                            
                            const text = await resp.text();
                            
                            // 5. 错误处理
                            if (!resp.ok) {
                                console.error('[Grok API Error]', text);
                                throw new Error(text || `Grok API error: ${resp.status}`);
                            }
                            
                            // 6. 解析响应
                            let data;
                            try {
                                data = JSON.parse(text);
                            } catch (e) {
                                throw new Error('API 返回了非 JSON 格式数据');
                            }

                            // 兼容多种 ID 返回格式
                            const jobId = data?.data?.id || data?.id || data?.task_id;
                            if (!jobId) {
                                console.error('Grok No Task ID:', data);
                                throw new Error('API 未返回 Task ID');
                            }
                            
                            // 7. 进入轮询 (Grok 兼容 Sora 查询接口)
                            setHistory(prev => prev.map(h => h.id === taskId ? { ...h, status: 'generating', progress: 10, remoteTaskId: jobId } : h));
                            pollSoraJob(jobId, taskId, baseUrl, apiKey, w, h, modelId);
                            
                            return; // 阻断后续代码执行
                        }

                        // Generic Video Logic (Sora/Kling/etc) - Force Multipart for Image Input with correct field names
                        if (sourceImage) {
                             const formData = new FormData();
                             const blob = await getBlobFromUrl(sourceImage);
                             
                             if (modelId.includes('sora')) {
                                 endpoint = `${baseUrl}/v1/videos`;
                                 formData.append('model', config?.modelName || 'sora-2');
                                 formData.append('prompt', prompt);
                                 formData.append('seconds', duration);
                                 formData.append('size', sizeStr);
                                 // Sora sometimes uses input_reference or image, append both for safety
                                 formData.append('input_reference', blob, 'ref.png'); 
                                 formData.append('image', blob, 'ref.png');
                             } else if (modelId.includes('kling')) {
                                 endpoint = `${baseUrl}/kling/v1/videos/text2video`; 
                                 formData.append('model_name', config?.modelName);
                                 formData.append('prompt', prompt);
                                 formData.append('aspect_ratio', ratio);
                                 formData.append('duration', duration);
                                 formData.append('image', blob, 'input.png');
                            } else if (modelId.includes('jimeng')) {
                                 endpoint = `${baseUrl}/jimeng/submit/videos`;
                                 formData.append('prompt', prompt);
                                 formData.append('duration', parseInt(duration));
                                 formData.append('aspect_ratio', ratio);
                                 formData.append('image', blob, 'input.png'); 
                            } else if (modelId.includes('grok')) {
                                endpoint = `${baseUrl}/v1/videos`;
                                formData.append('model', config?.modelName || 'grok-video-3');
                                formData.append('prompt', prompt);
                                formData.append('aspect_ratio', ratio);
                                formData.append('duration', durationValueNum);
                                formData.append('image', blob, 'input.png');
                             } else {
                                 endpoint = `${baseUrl}/v1/videos`;
                                 formData.append('model', config?.modelName);
                                 formData.append('prompt', prompt);
                                 formData.append('image', blob, 'input.png');
                                 formData.append('size', sizeStr); // Ensure size is passed for generic
                             }
                             body = formData;
                        } else {
                             headers['Content-Type'] = 'application/json';
                             if (modelId.includes('sora')) {
                                 delete headers['Content-Type'];
                                 endpoint = `${baseUrl}/v1/videos`;
                                 const formData = new FormData();
                                 formData.append('model', config?.modelName || 'sora-2');
                                 formData.append('prompt', prompt);
                                 formData.append('seconds', duration);
                                 formData.append('size', sizeStr);
                                 body = formData;
                            } else if (modelId.includes('kling')) {
                                 endpoint = `${baseUrl}/kling/v1/videos/text2video`;
                                 body = JSON.stringify({ model_name: config?.modelName, prompt, aspect_ratio: ratio, duration });
                            } else if (modelId.includes('jimeng')) {
                                 endpoint = `${baseUrl}/jimeng/submit/videos`;
                                 body = JSON.stringify({ prompt, duration: parseInt(duration), aspect_ratio: ratio });
                            } else if (modelId.includes('grok')) {
                                endpoint = `${baseUrl}/v1/videos`;
                                body = JSON.stringify({
                                    model: config?.modelName || 'grok-video-3',
                                    prompt,
                                    aspect_ratio: ratio,
                                    duration: durationValueNum
                                });
                             } else {
                                 endpoint = `${baseUrl}/minimax/v1/video_generation`;
                                 body = JSON.stringify({ model: config?.modelName, prompt, resolution: sizeStr });
                             }
                        }

                        const resp = await fetch(endpoint, { method: 'POST', headers: body instanceof FormData ? { Authorization: headers.Authorization } : headers, body });
                        const text = await resp.text();
                        if (!resp.ok) throw new Error(text || `Video API error: ${resp.status}`);
                        const data = JSON.parse(text);
                        
                        const immediateUrl = data?.video_url || data?.url || data?.data?.video_url;
                        if (immediateUrl) { 
                            const endTime = Date.now();
                            // 在更新 history 之前，先获取 sourceNodeId
                            const historyItem = history.find(h => h.id === taskId);
                            const sourceNodeId = historyItem?.sourceNodeId;
                            const durationMs = endTime - (historyItem?.startTime || endTime);
                            // 使用 setHistory 的回调来确保获取最新的 historyItem
                            setHistory((prev) => {
                                const updated = prev.map((hItem) => hItem.id === taskId ? { ...hItem, status: 'completed', progress: 100, url: immediateUrl, width: w, height: h, durationMs } : hItem);
                                // 在状态更新后，立即更新预览窗口
                                const updatedItem = updated.find(h => h.id === taskId);
                                if (updatedItem?.sourceNodeId) {
                                    setTimeout(() => {
                                        console.log('[Tapnow] 视频立即返回: 准备更新预览窗口', { taskId, immediateUrl, sourceNodeId: updatedItem.sourceNodeId });
                                        updatePreviewFromTask(taskId, immediateUrl, 'video', updatedItem.sourceNodeId);
                                    }, 0);
                                } else {
                                    console.warn('[Tapnow] 视频立即返回: 未找到 sourceNodeId', { taskId, updatedItem });
                                }
                                return updated;
                            });
                            return; 
                        }
                        
                        const jobId = data?.data?.id || data?.id || data?.task_id || data?.data?.task_id;
                        if (!jobId) throw new Error('No Task/Job ID returned');

                        setHistory(prev => prev.map(h => h.id === taskId ? { ...h, status: 'generating', progress: 10, remoteTaskId: jobId } : h));
                        if (modelId.includes('veo')) pollVeoJob(jobId, taskId, baseUrl, apiKey, w, h);
                        else pollSoraJob(jobId, taskId, baseUrl, apiKey, w, h, modelId);
                    }
                } catch (err) {
                    console.error('[CONSOLE_ERROR]', err);
                    // 尝试解析错误信息，提取更友好的错误消息
                    let errorMsg = err?.message || '生成失败';
                    try {
                        // 如果错误信息是 JSON 字符串，尝试解析
                        if (typeof errorMsg === 'string' && errorMsg.trim().startsWith('{')) {
                            const errorData = JSON.parse(errorMsg);
                            if (errorData?.error?.message) {
                                errorMsg = errorData.error.message;
                            } else if (errorData?.error) {
                                errorMsg = typeof errorData.error === 'string' ? errorData.error : JSON.stringify(errorData.error);
                            } else if (errorData?.message) {
                                errorMsg = errorData.message;
                            }
                        }
                        
                        // 检查是否是后端服务模块缺失错误，优化错误信息显示
                        if (errorMsg.includes('Cannot find module') || errorMsg.includes('octetstream') || errorMsg.includes('MODULE_NOT_FOUND')) {
                            // 检查是否已经包含优化后的错误信息，避免重复
                            if (!errorMsg.includes('即梦API代理服务缺少必要模块') && !errorMsg.includes('❌')) {
                                // 提取原始错误信息（去掉可能的重复前缀）
                                const originalError = errorMsg.replace(/后端服务错误[：:].*?错误详情[：:]/g, '').trim();
                                errorMsg = `❌ 即梦API代理服务缺少必要模块\n\n错误：${originalError}\n\n🔧 解决方案：\n1. 停止jimeng-api.exe并重新下载最新版本\n2. 或使用Docker：docker pull ghcr.io/iptag/jimeng-api:latest`;
                            } else if (!errorMsg.includes('🔧')) {
                                // 如果已经有基本错误信息但没有解决方案，添加解决方案
                                errorMsg = errorMsg + '\n\n🔧 解决方案：\n1. 停止jimeng-api.exe并重新下载最新版本\n2. 或使用Docker：docker pull ghcr.io/iptag/jimeng-api:latest';
                            }
                        }
                    } catch (e) {
                        // 如果解析失败，使用原始错误信息
                        // 但仍然检查是否是模块缺失错误
                        if (errorMsg.includes('Cannot find module') || errorMsg.includes('octetstream') || errorMsg.includes('MODULE_NOT_FOUND')) {
                            // 检查是否已经包含优化后的错误信息
                            if (!errorMsg.includes('即梦API代理服务缺少必要模块') && !errorMsg.includes('❌')) {
                                errorMsg = `❌ 即梦API代理服务缺少必要模块\n\n🔧 解决方案：\n1. 停止jimeng-api.exe并重新下载最新版本\n2. 或使用Docker：docker pull ghcr.io/iptag/jimeng-api:latest`;
                            }
                        }
                    }
                    setHistory((prev) => prev.map((hItem) => hItem.id === taskId ? { ...hItem, status: 'failed', errorMsg } : hItem));
                }
            };

            const handleToggleTheme = () => {
                setTheme((prev) => (prev === 'dark' ? 'light' : 'dark'));
            };

            // --- 节点操作 ---
            const addNode = (type, worldX, worldY, sourceId, initialContent = undefined, initialDimensions = undefined, targetId = undefined, inputType = undefined) => {
                const defaultSize = type === 'gen-video'
                    ? { w: 320, h: 420 }
                    : type === 'gen-image'
                        ? { w: 360, h: 340 }
                        : type === 'video-input'
                            ? { w: 360, h: 420 }
                            : type === 'video-analyze'
                                ? { w: 400, h: 500 }
                                : type === 'image-compare'
                                ? { w: 400, h: 300 }
                                : type === 'preview'
                                    ? { w: 320, h: 260 }
                                    : { w: 260, h: 260 };
                const newNode = {
                    id: `node-${Date.now()}`,
                    type,
                    x: worldX - defaultSize.w / 2,
                    y: worldY - defaultSize.h / 2,
                    width: defaultSize.w,
                    height: defaultSize.h,
                    content: initialContent, 
                    ...(initialDimensions ? { dimensions: initialDimensions } : {}),
                    settings: type === 'gen-image'
                        ? { model: 'nano-banana', ratio: 'Auto', resolution: 'Auto', prompt: '' }
                        : type === 'gen-video'
                            ? { model: 'sora-2', duration: '5s', ratio: '16:9', videoPrompt: '' }
                            : type === 'video-analyze'
                                ? { model: 'gemini-3-pro', segmentDuration: 3, analysisMode: 'manual', voiceoverResults: [], analysisResults: [] }
                                : {},
                };
                setNodes(prev => [...prev, newNode]);
                // 从输出端口连接到新节点（原有逻辑）
                if (sourceId) {
                    setConnections(prev => [...prev, { id: `conn-${Date.now()}`, from: sourceId, to: newNode.id }]);
                }
                // 从输入端口连接到新节点（反向连接）
                if (targetId) {
                    setConnections(prev => {
                        // 如果连接到特定输入点，先删除该输入点的旧连接
                        if (inputType && inputType !== 'default') {
                            const filtered = prev.filter((c) => 
                                !(c.to === targetId && (c.inputType || 'default') === inputType)
                            );
                            return [...filtered, { 
                                id: `conn-${Date.now()}`, 
                                from: newNode.id, 
                                to: targetId,
                                inputType: inputType !== 'default' ? inputType : undefined
                            }];
                        }
                        return [...prev, { 
                            id: `conn-${Date.now()}`, 
                            from: newNode.id, 
                            to: targetId 
                        }];
                    });
                }
                setContextMenu(prev => ({ ...prev, visible: false }));
                setConnectingSource(null);
                setConnectingTarget(null);
                setConnectingInputType(null);
            };

            const deleteNode = (id) => {
                setNodes((prev) => prev.filter((n) => n.id !== id));
                setConnections((prev) => prev.filter((c) => c.from !== id && c.to !== id));
                if (selectedNodeId === id) setSelectedNodeId(null);
            };

            const updateNodeSettings = (id, newSettings) => setNodes((prev) => prev.map((n) => n.id === id ? { ...n, settings: { ...n.settings, ...newSettings } } : n));
            
            // 拓展图片 Zoom Out 功能
            const handleExpandImageZoom = async (nodeId, zoomLevel) => {
                const node = nodes.find(n => n.id === nodeId);
                if (!node || !node.content) {
                    console.warn('拓展图片: 节点不存在或没有图片内容');
                    return;
                }

                // 查找 Midjourney 配置（优先使用节点设置中选择的模型）
                const selectedMjModelId = node.settings?.mjModel || 'mj-v7';
                let mjConfig = apiConfigs.find(c => c.id === selectedMjModelId);
                
                // 如果找不到，尝试查找任何 Midjourney 配置
                if (!mjConfig) {
                    mjConfig = apiConfigs.find(c => c.id.includes('mj') || c.provider.toLowerCase().includes('midjourney'));
                }
                
                if (!mjConfig) {
                    alert('请先配置 Midjourney API');
                    setSettingsOpen(true);
                    return;
                }

                const apiKey = mjConfig.key || globalApiKey;
                const baseUrl = (mjConfig.url || DEFAULT_BASE_URL).replace(/\/+$/, '');
                if (!apiKey) {
                    alert('请先配置 Midjourney API Key');
                    setSettingsOpen(true);
                    return;
                }

                try {
                    // 1. 上传图片获取 HTTP URL（如果是 data URL）
                    let imageUrl = node.content;
                    if (imageUrl.startsWith('data:')) {
                        console.log('拓展图片: 开始上传图片获取 HTTP URL...', 'baseUrl:', baseUrl, 'apiKey存在:', !!apiKey);
                        const httpUrl = await uploadImageToGetHttpUrl(imageUrl, baseUrl, apiKey);
                        if (!httpUrl) {
                            console.error('拓展图片: 图片上传失败，所有方法都失败');
                            alert('图片上传失败，无法进行拓展。请检查网络连接和API配置。');
                            return;
                        }
                        console.log('拓展图片: 图片上传成功，HTTP URL:', httpUrl);
                        imageUrl = httpUrl;
                    } else if (imageUrl.startsWith('http://') || imageUrl.startsWith('https://')) {
                        console.log('拓展图片: 图片已经是HTTP URL，直接使用:', imageUrl);
                    } else {
                        console.warn('拓展图片: 图片URL格式未知:', imageUrl.substring(0, 50));
                    }

                    // 2. 先提交图片到 Midjourney 获取原始任务ID
                    const taskId = Date.now().toString();
                    const now = Date.now();
                    
                    setHistory((prev) => [{
                        id: taskId,
                        type: 'image',
                        url: '',
                        prompt: `Zoom Out ${zoomLevel}x`,
                        time: new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),
                        status: 'generating',
                        progress: 5,
                        modelName: 'Midjourney Zoom',
                        width: 0,
                        height: 0,
                        remoteTaskId: null,
                        apiConfig: { modelId: 'mj-zoom', baseUrl, apiKey },
                        sourceNodeId: nodeId,
                        startTime: now,
                        durationMs: null
                    }, ...prev]);
                    setHistoryOpen(true);

                    // 3. 提交图片到 Midjourney（使用 imagine 接口，不包含 zoom 参数）
                    const mjMode = 'fast';
                    const imagineEndpoint = `${baseUrl}/${mjMode}/mj/submit/imagine`;
                    const imaginePayload = {
                        prompt: imageUrl,
                        notifyHook: '',
                        state: ''
                    };

                    const imagineResp = await fetch(imagineEndpoint, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${apiKey}`
                        },
                        body: JSON.stringify(imaginePayload)
                    });

                    const imagineText = await imagineResp.text();
                    if (!imagineResp.ok) {
                        throw new Error(imagineText || `Imagine API error: ${imagineResp.status}`);
                    }

                    const imagineData = JSON.parse(imagineText);
                    if (imagineData.code !== 1 && imagineData.code !== 22) {
                        throw new Error(imagineData.description || `Midjourney提交失败: code ${imagineData.code}`);
                    }

                    const originalTaskId = imagineData.result;
                    if (!originalTaskId) throw new Error('未获取到任务ID');

                    console.log('拓展图片: 获取到原始任务ID', originalTaskId);

                    // 4. 等待原始任务完成（ZOOM操作需要原始任务完成）
                    console.log('拓展图片: 等待原始任务完成...', originalTaskId);
                    let originalTaskCompleted = false;
                    let pollCount = 0;
                    const maxPolls = 120; // 最多轮询120次（约10分钟）
                    
                    while (!originalTaskCompleted && pollCount < maxPolls) {
                        await new Promise(resolve => setTimeout(resolve, 5000)); // 每5秒检查一次
                        pollCount++;
                        
                        try {
                            const statusResp = await fetch(`${baseUrl}/${mjMode}/mj/task/${originalTaskId}/fetch`, {
                                method: 'GET',
                                headers: {
                                    'Authorization': `Bearer ${apiKey}`,
                                    'Content-Type': 'application/json'
                                }
                            });
                            
                            const statusText = await statusResp.text();
                            const statusData = JSON.parse(statusText);
                            const status = statusData?.status || '';
                            
                            console.log('拓展图片: 原始任务状态检查', { status, pollCount });
                            
                        if (status === 'SUCCESS' || status === 'FINISHED') {
                            originalTaskCompleted = true;
                            console.log('拓展图片: 原始任务已完成，可以执行ZOOM操作');
                        } else if (status === 'FAILURE' || status === 'ERROR' || status === 'CANCELLED') {
                            throw new Error(`原始任务失败: ${status}`);
                        }
                    } catch (error) {
                        if (pollCount >= maxPolls) {
                            throw new Error('原始任务状态检查超时');
                        }
                        console.warn('拓展图片: 状态检查出错，继续重试', error);
                    }
                }
                
                if (!originalTaskCompleted) {
                    throw new Error('原始任务超时，无法执行ZOOM操作');
                }

                // 5. 使用 modal 接口提交 ZOOM 操作
                const modalEndpoint = `${baseUrl}/mj/submit/modal`;
                // ZOOM操作的prompt格式：根据Midjourney文档，使用 --zoomout 参数
                const zoomPrompt = `--zoomout ${zoomLevel}`;
                const modalPayload = {
                    taskId: originalTaskId,
                    prompt: zoomPrompt
                    // maskBase64 可选，ZOOM 不需要蒙版
                };

                console.log('拓展图片: 调用 ZOOM modal 接口', { taskId: originalTaskId, prompt: zoomPrompt });
                
                const modalResp = await fetch(modalEndpoint, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiKey}`
                    },
                    body: JSON.stringify(modalPayload)
                });

                const modalText = await modalResp.text();
                if (!modalResp.ok) {
                    throw new Error(modalText || `Modal API error: ${modalResp.status}`);
                }

                const modalData = JSON.parse(modalText);
                if (modalData.code !== 1 && modalData.code !== 22) {
                    throw new Error(modalData.description || `ZOOM提交失败: code ${modalData.code}`);
                }

                const zoomTaskId = modalData.result;
                if (!zoomTaskId) throw new Error('未获取到ZOOM任务ID');

                console.log('拓展图片: 获取到ZOOM任务ID', zoomTaskId);

                // 6. 更新历史记录，保存ZOOM任务ID
                setHistory((prev) => prev.map((hItem) => 
                    hItem.id === taskId 
                        ? { ...hItem, remoteTaskId: zoomTaskId, status: 'generating', progress: 20 } 
                        : hItem
                ));

                // 7. 开始轮询ZOOM任务状态
                pollMidjourneyJob(zoomTaskId, taskId, baseUrl, apiKey, mjMode, 0, 0);
                } catch (error) {
                    console.error('拓展图片: 处理失败', error);
                    const taskId = Date.now().toString();
                    setHistory((prev) => {
                        const existing = prev.find(h => h.sourceNodeId === nodeId && h.prompt === `Zoom Out ${zoomLevel}x`);
                        if (existing) {
                            return prev.map((hItem) => 
                                hItem.id === existing.id 
                                    ? { ...hItem, status: 'failed', errorMsg: error.message || '拓展失败' } 
                                    : hItem
                            );
                        }
                        return prev;
                    });
                }
            };

            const handleFileUpload = (nodeId, e) => {
                const file = e.target.files?.[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = async (ev) => {
                         const content = ev.target.result;
                         let dimensions = { w: 0, h: 0 };
                         try { dimensions = await getImageDimensions(content); } catch (e) {}
                         setNodes((prev) => prev.map((n) => n.id === nodeId ? { ...n, content: content, dimensions } : n));
                    };
                    reader.readAsDataURL(file);
                }
            };

            // 按时间段分组关键帧
            const groupKeyframesByTime = (keyframes, segmentDuration) => {
                if (!keyframes || keyframes.length === 0) return [];
                const sorted = [...keyframes].sort((a, b) => a.time - b.time);
                const groups = [];
                let currentGroup = [];
                let currentGroupStart = sorted[0].time;
                
                sorted.forEach((frame, idx) => {
                    if (frame.time - currentGroupStart >= segmentDuration && currentGroup.length > 0) {
                        groups.push([...currentGroup]);
                        currentGroup = [frame];
                        currentGroupStart = frame.time;
                    } else {
                        currentGroup.push(frame);
                    }
                });
                
                if (currentGroup.length > 0) {
                    groups.push(currentGroup);
                }
                
                return groups;
            };

            // 为选中关键帧生成提示词
            const handleGeneratePrompts = async (nodeId) => {
                const node = nodes.find(n => n.id === nodeId);
                if (!node || node.type !== 'video-analyze') return;
                
                const videoInputNode = getConnectedVideoInputNode(nodeId);
                if (!videoInputNode) {
                    alert('请先连接一个视频输入节点');
                    return;
                }
                
                const selectedKeyframes = videoInputNode.selectedKeyframes || [];
                if (selectedKeyframes.length === 0) {
                    alert('请先在视频输入节点中选择关键帧');
                    return;
                }
                
                const config = apiConfigs.find((c) => c.id === node.settings?.model || 'gemini-3-pro');
                const apiKey = config?.key || globalApiKey;
                const baseUrl = (config?.url || DEFAULT_BASE_URL).replace(/\/+$/, '');
                
                if (!apiKey) {
                    alert('请先在 API 设置中配置 Key');
                    setSettingsOpen(true);
                    return;
                }
                
                const segmentDuration = node.settings?.segmentDuration || 3;
                const groups = groupKeyframesByTime(selectedKeyframes, segmentDuration);
                
                if (groups.length === 0) {
                    alert('无法分组关键帧');
                    return;
                }
                
                setNodes((prev) => prev.map((n) => n.id === nodeId ? { ...n, isGenerating: true, analysisResults: [] } : n));
                
                const allResults = [];
                const videoFileName = videoInputNode.videoFileName || 'video.mp4';
                const videoDuration = videoInputNode.videoMeta?.duration || 0;
                
                try {
                    for (let sceneIndex = 0; sceneIndex < groups.length; sceneIndex++) {
                        const group = groups[sceneIndex];
                        const timeRange = `${group[0].time.toFixed(1)}s-${group[group.length - 1].time.toFixed(1)}s`;
                        
                        // 构建多模态消息
                        const systemPrompt = `你是一个专业的视频拆解和提示词生成助手。请分析提供的视频关键帧，动态拆解视频内容，并根据用户选中的关键帧生成高质量的AI绘图提示词。

请返回严格的 JSON 格式，结构如下：
{
  "video_id": "${videoFileName}",
  "scene_index": ${sceneIndex + 1},
  "time_range": "${timeRange}",
  "keyframes": [
    {
      "type": "prev",
      "time": 5.2,
      "description": "上一画面内容简介",
      "mj_prompt": "Midjourney 英文提示词",
      "jimeng_prompt": "即梦中文提示词"
    },
    {
      "type": "current",
      "time": 6.8,
      "description": "当前画面内容简介",
      "mj_prompt": "Midjourney 英文提示词",
      "jimeng_prompt": "即梦中文提示词"
    },
    {
      "type": "next",
      "time": 8.7,
      "description": "下一画面内容简介",
      "mj_prompt": "Midjourney 英文提示词",
      "jimeng_prompt": "即梦中文提示词"
    }
  ],
  "global_tags": {
    "style": ["赛博朋克", "末日科幻"],
    "camera": ["低机位", "广角"],
    "color": ["冷暖对比"]
  }
}

要求：
1. 为每个关键帧生成 prev/current/next 三种类型的描述和提示词
2. mj_prompt 使用英文，适合 Midjourney
3. jimeng_prompt 使用中文，适合即梦AI
4. global_tags 提取整个场景的风格、镜头、色彩特征`;

                        const userContent = [
                            { type: "text", text: `请分析以下视频关键帧（场景 ${sceneIndex + 1}，时间段：${timeRange}），生成详细的提示词：` }
                        ];
                        
                        // 添加关键帧图片（限制最多15张，因为API限制是16张，需要留一些余量）
                        const maxFrames = 15;
                        const framesToSend = group.length > maxFrames ? group.slice(0, maxFrames) : group;
                        framesToSend.forEach((frame, idx) => {
                            userContent.push({
                                type: "image_url",
                                image_url: { url: frame.url }
                            });
                            if (idx < framesToSend.length - 1) {
                                userContent.push({ type: "text", text: `关键帧 ${idx + 1}（时间：${frame.time.toFixed(2)}s）` });
                            }
                        });
                        if (group.length > maxFrames) {
                            userContent.push({ type: "text", text: `注意：该场景共有 ${group.length} 个关键帧，但为了符合API限制，仅发送了前 ${maxFrames} 个关键帧进行分析。` });
                        }
                        
                        const apiMessages = [
                            { role: 'system', content: systemPrompt },
                            { role: 'user', content: userContent }
                        ];
                        
                        const response = await fetch(`${baseUrl}/v1/chat/completions`, {
                            method: 'POST',
                            headers: {
                                'Authorization': `Bearer ${apiKey}`,
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({
                                model: config?.modelName || 'gemini-3-pro-preview',
                                messages: apiMessages,
                                stream: false
                            })
                        });
                        
                        if (!response.ok) {
                            const errText = await response.text();
                            throw new Error(errText || `API Error: ${response.status}`);
                        }
                        
                        const data = await response.json();
                        const aiContent = data.choices?.[0]?.message?.content || "{}";
                        
                        // 尝试解析 JSON（可能包含 markdown 代码块）
                        let jsonStr = aiContent.trim();
                        if (jsonStr.startsWith('```')) {
                            jsonStr = jsonStr.replace(/^```(?:json)?\n?/, '').replace(/\n?```$/, '');
                        }
                        
                        let result;
                        try {
                            result = JSON.parse(jsonStr);
                        } catch (e) {
                            console.error('解析 JSON 失败:', e, jsonStr);
                            // 尝试修复常见的JSON格式问题
                            try {
                                // 移除可能的注释
                                jsonStr = jsonStr.replace(/\/\*[\s\S]*?\*\//g, '').replace(/\/\/.*/g, '');
                                // 尝试修复尾随逗号
                                jsonStr = jsonStr.replace(/,(\s*[}\]])/g, '$1');
                                result = JSON.parse(jsonStr);
                            } catch (e2) {
                                console.error('JSON修复后仍解析失败:', e2);
                                // 如果还是失败，创建一个默认结构
                                result = {
                                    video_id: videoFileName,
                                    scene_index: sceneIndex + 1,
                                    time_range: timeRange,
                                    keyframes: group.map((frame, fIdx) => ({
                                        type: fIdx === 0 ? 'prev' : fIdx === 1 ? 'current' : 'next',
                                        time: frame.time,
                                        description: `视频帧 ${frame.time.toFixed(1)}s`,
                                        mj_prompt: 'A detailed scene from the video',
                                        jimeng_prompt: '视频场景描述'
                                    })),
                                    global_tags: { style: [], camera: [], color: [] }
                                };
                            }
                        }
                        
                        allResults.push(result);
                        
                        // 更新节点状态
                        setNodes((prev) => prev.map((n) => 
                            n.id === nodeId 
                                ? { ...n, analysisResults: [...(n.analysisResults || []), result] }
                                : n
                        ));
                        
                        // 添加到历史记录
                        const taskId = `analyze-${nodeId}-${sceneIndex}-${Date.now()}`;
                        const historyItem = {
                            id: taskId,
                            type: 'analyze',
                            prompt: `视频拆解 - 场景 ${sceneIndex + 1}`,
                            url: group[0]?.url || '',
                            status: 'completed',
                            progress: 100,
                            modelName: config?.provider || 'Gemini 3 Pro',
                            time: new Date().toLocaleString('zh-CN'),
                            sourceNodeId: nodeId,
                            analysisResult: result,
                            videoFileName,
                            sceneIndex: sceneIndex + 1,
                            timeRange
                        };
                        
                        setHistory((prev) => [historyItem, ...prev]);
                    }
                    
                    setNodes((prev) => prev.map((n) => n.id === nodeId ? { ...n, isGenerating: false } : n));
                    
                } catch (error) {
                    console.error('生成提示词失败:', error);
                    setNodes((prev) => prev.map((n) => n.id === nodeId ? { ...n, isGenerating: false, errorMsg: error.message } : n));
                    alert(`生成提示词失败: ${error.message}`);
                }
            };

            // AI 视频全自动分析
            const handleAutoVideoAnalysis = async (nodeId) => {
                const node = nodes.find(n => n.id === nodeId);
                if (!node || node.type !== 'video-analyze') return;
                
                const videoInputNode = getConnectedVideoInputNode(nodeId);
                if (!videoInputNode || !videoInputNode.content) {
                    alert('请先连接一个包含视频的视频输入节点');
                    return;
                }
                
                // 预处理视频内容：如果是 blob: URL，需要转换为 base64 以便远程可访问
                let videoDataUrl = videoInputNode.content;
                if (videoDataUrl.startsWith('blob:')) {
                    try {
                        console.log('Converting Blob URL to Base64 for API...');
                        const blob = await fetch(videoDataUrl).then(r => r.blob());
                        videoDataUrl = await new Promise((resolve, reject) => {
                            const reader = new FileReader();
                            reader.onerror = () => reject(new Error('FileReader failed'));
                            reader.onloadend = () => resolve(reader.result);
                            reader.readAsDataURL(blob);
                        });
                    } catch (e) {
                        console.error('Blob conversion failed', e);
                        alert('视频转换失败，无法发送给 AI');
                        return;
                    }
                }
                
                // 强制使用 gemini-3-pro 模型（支持视频输入）
                let config = apiConfigs.find((c) => c.id === 'gemini-3-pro' && c.type === 'Chat');
                
                // 如果没有找到 gemini-3-pro，尝试其他 gemini 模型
                if (!config) {
                    config = apiConfigs.find((c) => {
                        const modelId = c.id?.toLowerCase() || '';
                        return modelId.includes('gemini') && c.type === 'Chat';
                    });
                }
                
                // 如果还是没有，使用默认配置
                if (!config) {
                    config = apiConfigs.find((c) => c.type === 'Chat');
                }
                
                const apiKey = config?.key || globalApiKey;
                const baseUrl = (config?.url || DEFAULT_BASE_URL).replace(/\/+$/, '');
                
                if (!apiKey) {
                    alert('请先在 API 设置中配置 Key');
                    setSettingsOpen(true);
                    return;
                }
                
                setNodes((prev) => prev.map((n) => 
                    n.id === nodeId 
                        ? { ...n, isGenerating: true, settings: { ...n.settings, voiceoverResults: [], analysisResults: [] } }
                        : n
                ));
                
                try {
                    const systemPrompt = `你是一位世界级的**游戏买量视频拆解专家**和**AI视觉导演**。你需要同时完成两项任务：

1. **视觉拆解**：分析视频的每一个分镜，推测其运镜手法（推拉摇移）、画面动态、人物关系。

2. **听觉提取**：提取视频中的口播文案（Voiceover）。

请按时间顺序，将视频拆解为多个关键场景，并返回如下 **JSON 格式**（不要包含Markdown代码块标记）：

{
  "voiceover_script": [
    { "time_range": "0s-3s", "text": "提取的口播文案..." }
  ],
  "scenes": [
    {
      "scene_id": 1,
      "time_range": "0s-2.5s",
      "visual_analysis": {
        "camera_movement": "详细描述运镜，例如：镜头瞬间快速拉远(Dolly Zoom Out)，或 环绕拍摄(Orbit)",
        "subject_dynamics": "描述主体动作，例如：角色从王座上猛然站起，披风飞扬",
        "atmosphere": "赛博朋克，冷峻，高科技感"
      },
      "prompts": {
        "jimeng_prompt": "即梦提示词：一定要包含运镜描述。格式：(运镜描述)+画面主体+环境+风格。例如：(镜头急速拉远)，一名黑发年轻男子坐在虚拟王座上，身穿黑色长风衣...",
        "mj_prompt": "Midjourney Prompt: English description, include camera directives like 'dynamic angle', 'fast zoom out', 'cinematic lighting'..."
      }
    }
  ]
}

**重要要求：**
- **运镜分析**要非常精准。
- **即梦提示词**必须将"运镜描述"放在最前面，用括号括起来。
- **口播提取**要依靠视频中的音频内容，如果视频没有声音则留空。`;

                    // 直接使用视频 URL（gemini-3-pro 支持视频输入）
                    const userContent = [
                        { type: "text", text: "请分析这段视频。请严格按JSON格式输出拆解报告。" },
                        { type: "image_url", image_url: { url: videoDataUrl } }
                    ];
                    
                    const apiMessages = [
                        { role: 'system', content: systemPrompt },
                        { role: 'user', content: userContent }
                    ];
                    
                    const response = await fetch(`${baseUrl}/v1/chat/completions`, {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${apiKey}`,
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            model: config?.modelName || 'gemini-3-pro-preview',
                            messages: apiMessages,
                            stream: false
                        })
                    });
                    
                    if (!response.ok) {
                        const errText = await response.text();
                        throw new Error(errText || `API Error: ${response.status}`);
                    }
                    
                    const data = await response.json();
                    const aiContent = data.choices?.[0]?.message?.content || "{}";
                    
                    // 解析 JSON
                    let jsonStr = aiContent.trim();
                    if (jsonStr.startsWith('```')) {
                        jsonStr = jsonStr.replace(/^```(?:json)?\n?/, '').replace(/\n?```$/, '');
                    }
                    
                    let result;
                    try {
                        result = JSON.parse(jsonStr);
                    } catch (e) {
                        console.error('解析 JSON 失败:', e, jsonStr);
                        // 尝试修复
                        try {
                            jsonStr = jsonStr.replace(/\/\*[\s\S]*?\*\//g, '').replace(/\/\/.*/g, '');
                            jsonStr = jsonStr.replace(/,(\s*[}\]])/g, '$1');
                            result = JSON.parse(jsonStr);
                        } catch (e2) {
                            throw new Error('模型返回的不是有效的 JSON 格式');
                        }
                    }
                    
                    // 处理 voiceover_script，转换为 voiceoverResults 格式
                    const voiceoverResults = (result.voiceover_script || []).map((v, idx) => ({
                        time: idx,
                        text: v.text || ''
                    }));
                    
                    // 处理 scenes，转换为 analysisResults 格式
                    const analysisResults = (result.scenes || []).map((scene, idx) => ({
                        scene_index: scene.scene_id || idx + 1,
                        time_range: scene.time_range || '',
                        keyframes: [{
                            type: 'current',
                            time: 0,
                            description: `${scene.visual_analysis?.camera_movement || ''} ${scene.visual_analysis?.subject_dynamics || ''}`.trim(),
                            mj_prompt: scene.prompts?.mj_prompt || '',
                            jimeng_prompt: scene.prompts?.jimeng_prompt || ''
                        }],
                        global_tags: {
                            style: scene.visual_analysis?.atmosphere ? [scene.visual_analysis.atmosphere] : [],
                            camera: scene.visual_analysis?.camera_movement ? [scene.visual_analysis.camera_movement] : [],
                            color: []
                        }
                    }));
                    
                    // 更新节点状态
                    setNodes((prev) => prev.map((n) => 
                        n.id === nodeId 
                            ? { 
                                ...n, 
                                isGenerating: false, 
                                settings: { 
                                    ...n.settings, 
                                    voiceoverResults, 
                                    analysisResults 
                                } 
                            }
                            : n
                    ));
                    
                } catch (error) {
                    console.error('AI视频分析失败:', error);
                    setNodes((prev) => prev.map((n) => 
                        n.id === nodeId 
                            ? { ...n, isGenerating: false, errorMsg: error.message || 'AI视频分析失败' }
                            : n
                    ));
                    alert(`AI视频分析失败: ${error.message}`);
                }
            };

            const handleVideoFileUpload = (nodeId, file) => {
                if (!file) return;
                const reader = new FileReader();
                reader.onload = async (ev) => {
                    const content = ev.target.result;
                    let videoMeta = { duration: 0, w: 0, h: 0 };
                    try { videoMeta = await getVideoMetadata(content); } catch (e) { console.warn('读取视频元信息失败', e); }
                    setNodes((prev) => prev.map((n) => 
                        n.id === nodeId 
                            ? { ...n, content, videoMeta, frames: [], selectedKeyframes: [], extractingFrames: false, videoFileName: file.name } 
                            : n
                    ));
                };
                reader.readAsDataURL(file);
            };

            const handleVideoDrop = (nodeId, e) => {
                e.preventDefault(); e.stopPropagation();
                e.currentTarget.classList.remove('drag-over');
                const files = Array.from(e.dataTransfer.files);
                const videoFile = files.find(file => file.type.startsWith('video/'));
                if (videoFile) {
                    handleVideoFileUpload(nodeId, videoFile);
                }
            };

            // 智能抽帧：场景检测算法
            const detectScenesAndCapture = async (videoUrl, threshold = 30) => {
                return new Promise((resolve, reject) => {
                    const video = document.createElement('video');
                    video.crossOrigin = "anonymous";
                    video.src = videoUrl;
                    video.muted = true;
                    
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d', { willReadFrequently: true });
                    
                    const keyframes = [];
                    let prevData = null;
                    
                    video.onloadeddata = async () => {
                        canvas.width = 320;
                        canvas.height = Math.floor(320 * (video.videoHeight / video.videoWidth));
                        
                        const duration = video.duration;
                        const sampleRate = 2;
                        
                        video.currentTime = 0;
                        
                        const scan = async () => {
                            // 检查是否已经扫描完成
                            const currentTime = video.currentTime;
                            if (currentTime >= duration || Math.abs(currentTime - duration) < 0.01) {
                                // 确保最后一帧也被包含
                                if (keyframes.length === 0 || parseFloat(keyframes[keyframes.length - 1].time) < duration - 0.5) {
                                    const hdCanvas = document.createElement('canvas');
                                    hdCanvas.width = video.videoWidth;
                                    hdCanvas.height = video.videoHeight;
                                    const hdCtx = hdCanvas.getContext('2d');
                                    video.currentTime = Math.max(0, duration - 0.1);
                                    await new Promise(r => {
                                        const timeout = setTimeout(() => r(), 200);
                                        video.onseeked = () => {
                                            clearTimeout(timeout);
                                            hdCtx.drawImage(video, 0, 0);
                                            const lastTime = Math.max(0, duration - 0.1);
                                            keyframes.push({
                                                time: lastTime.toFixed(2),
                                                image: hdCanvas.toDataURL('image/jpeg', 0.8)
                                            });
                                            r();
                                        };
                                    });
                                }
                                resolve(keyframes.map(kf => ({ time: parseFloat(kf.time), url: kf.image })));
                                return;
                            }
                            
                            ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                            const frameData = ctx.getImageData(0, 0, canvas.width, canvas.height).data;
                            
                            if (prevData) {
                                let diff = 0;
                                for (let i = 0; i < frameData.length; i += 4) {
                                    diff += Math.abs(frameData[i] - prevData[i]) +
                                            Math.abs(frameData[i+1] - prevData[i+1]) +
                                            Math.abs(frameData[i+2] - prevData[i+2]);
                                }
                                const avgDiff = diff / (frameData.length / 4 * 3);
                                
                                if (avgDiff > threshold) {
                                    const hdCanvas = document.createElement('canvas');
                                    hdCanvas.width = video.videoWidth;
                                    hdCanvas.height = video.videoHeight;
                                    hdCanvas.getContext('2d').drawImage(video, 0, 0);
                                    const dataUrl = hdCanvas.toDataURL('image/jpeg', 0.8);
                                    
                                    // 确保使用实际的currentTime，而不是字符串
                                    const captureTime = video.currentTime;
                                    keyframes.push({
                                        time: captureTime.toFixed(2),
                                        image: dataUrl
                                    });
                                    prevData = null;
                                } else {
                                    prevData = frameData;
                                }
                            } else {
                                // 第一帧，记录当前时间（确保使用实际的currentTime）
                                prevData = frameData;
                                const currentTime = video.currentTime;
                                const hdCanvas = document.createElement('canvas');
                                hdCanvas.width = video.videoWidth;
                                hdCanvas.height = video.videoHeight;
                                hdCanvas.getContext('2d').drawImage(video, 0, 0);
                                keyframes.push({ 
                                    time: currentTime.toFixed(2), 
                                    image: hdCanvas.toDataURL('image/jpeg', 0.8) 
                                });
                            }
                            
                            // 更新到下一个采样点
                            const nextTime = video.currentTime + (1 / sampleRate);
                            if (nextTime >= duration) {
                                // 确保最后一帧也被包含
                                if (keyframes.length === 0 || parseFloat(keyframes[keyframes.length - 1].time) < duration - 0.5) {
                                    const hdCanvas = document.createElement('canvas');
                                    hdCanvas.width = video.videoWidth;
                                    hdCanvas.height = video.videoHeight;
                                    const hdCtx = hdCanvas.getContext('2d');
                                    video.currentTime = Math.max(0, duration - 0.1);
                                    await new Promise(r => {
                                        const timeout = setTimeout(() => r(), 200);
                                        video.onseeked = () => {
                                            clearTimeout(timeout);
                                            hdCtx.drawImage(video, 0, 0);
                                            const lastTime = Math.max(0, duration - 0.1);
                                            keyframes.push({
                                                time: lastTime.toFixed(2),
                                                image: hdCanvas.toDataURL('image/jpeg', 0.8)
                                            });
                                            r();
                                        };
                                    });
                                }
                                resolve(keyframes.map(kf => ({ time: parseFloat(kf.time), url: kf.image })));
                                return;
                            }
                            video.currentTime = nextTime;
                            await new Promise(r => { 
                                const timeout = setTimeout(() => r(), 200); // 超时保护
                                video.onseeked = () => {
                                    clearTimeout(timeout);
                                    r();
                                };
                            });
                            scan();
                        };
                        
                        scan();
                    };
                    
                    video.onerror = (e) => reject(new Error("视频加载失败，请检查格式或跨域设置"));
                });
            };

            const handleAutoExtractKeyframes = async (nodeId, fps = 2) => {
                const node = nodes.find(n => n.id === nodeId);
                if (!node?.content) return;
                setNodes(prev => prev.map(n => n.id === nodeId ? { ...n, extractingFrames: true } : n));
                try {
                    const frames = await extractKeyFrames(node.content, { fps });
                    setNodes(prev => prev.map(n => n.id === nodeId ? { ...n, frames, selectedKeyframes: [], extractingFrames: false } : n));
                } catch (error) {
                    console.error('视频抽帧失败', error);
                    setNodes(prev => prev.map(n => n.id === nodeId ? { ...n, extractingFrames: false } : n));
                }
            };

            const handleSmartExtractKeyframes = async (nodeId, threshold = 30) => {
                const node = nodes.find(n => n.id === nodeId);
                if (!node?.content) return;
                setNodes(prev => prev.map(n => n.id === nodeId ? { ...n, extractingFrames: true } : n));
                try {
                    const frames = await detectScenesAndCapture(node.content, threshold);
                    setNodes(prev => prev.map(n => n.id === nodeId ? { ...n, frames, selectedKeyframes: [], extractingFrames: false } : n));
                } catch (error) {
                    console.error('智能抽帧失败', error);
                    alert(`智能抽帧失败: ${error.message}`);
                    setNodes(prev => prev.map(n => n.id === nodeId ? { ...n, extractingFrames: false } : n));
                }
            };

            // 提取口播文案
            const handleExtractVoiceover = async (nodeId) => {
                const node = nodes.find(n => n.id === nodeId);
                if (!node || node.type !== 'video-analyze') return;
                
                const videoInputNode = getConnectedVideoInputNode(nodeId);
                if (!videoInputNode || !videoInputNode.content) {
                    alert('请先连接一个包含视频的视频输入节点');
                    return;
                }
                
                const config = apiConfigs.find((c) => c.id === node.settings?.model || 'gemini-3-pro');
                const apiKey = config?.key || globalApiKey;
                const baseUrl = (config?.url || DEFAULT_BASE_URL).replace(/\/+$/, '');
                
                if (!apiKey) {
                    alert('请先在 API 设置中配置 Key');
                    setSettingsOpen(true);
                    return;
                }
                
                setNodes((prev) => prev.map((n) => n.id === nodeId ? { ...n, isExtractingVoiceover: true, voiceoverResults: [] } : n));
                
                const videoFileName = videoInputNode.videoFileName || 'video.mp4';
                const videoDuration = videoInputNode.videoMeta?.duration || 0;
                
                try {
                    // 构建多模态消息，请求提取口播文案
                    const systemPrompt = `你是一个专业的视频口播文案提取助手。请分析提供的视频，提取每一秒的口播内容。

请返回严格的 JSON 格式，结构如下：
{
  "video_id": "${videoFileName}",
  "duration": ${videoDuration},
  "voiceover": [
    {
      "time": 0,
      "text": "第一秒的口播内容"
    },
    {
      "time": 1,
      "text": "第二秒的口播内容"
    },
    {
      "time": 2,
      "text": "第三秒的口播内容"
    }
  ]
}

要求：
1. 按秒为单位提取口播内容
2. 如果某一秒没有口播，text 字段为空字符串
3. 准确记录每一秒的说话内容
4. 只提取口播文案，不要添加其他描述`;

                    // 从视频中提取关键帧用于分析（每5秒一帧，避免太多）
                    const sampleFrames = [];
                    const video = document.createElement('video');
                    video.crossOrigin = 'anonymous';
                    video.src = videoInputNode.content;
                    video.muted = true;
                    
                    await new Promise((resolve) => {
                        video.onloadedmetadata = () => {
                            const canvas = document.createElement('canvas');
                            canvas.width = video.videoWidth;
                            canvas.height = video.videoHeight;
                            const ctx = canvas.getContext('2d');
                            
                            let currentTime = 0;
                            const extractFrame = async () => {
                                if (currentTime >= videoDuration) {
                                    resolve();
                                    return;
                                }
                                
                                video.currentTime = currentTime;
                                await new Promise((r) => {
                                    video.onseeked = () => {
                                        ctx.drawImage(video, 0, 0);
                                        const dataUrl = canvas.toDataURL('image/jpeg', 0.8);
                                        sampleFrames.push({
                                            time: currentTime,
                                            url: dataUrl
                                        });
                                        currentTime += 5; // 每5秒一帧
                                        setTimeout(r, 50);
                                    };
                                });
                                extractFrame();
                            };
                            extractFrame();
                        };
                    });
                    
                    // 构建用户消息，包含视频帧
                    const userContent = [
                        { type: "text", text: `请分析以下视频，提取每一秒的口播文案。视频总时长：${videoDuration.toFixed(1)}秒。` }
                    ];
                    
                    // 添加关键帧（每5秒一帧，避免太多）
                    sampleFrames.forEach((frame) => {
                        userContent.push({
                            type: "image_url",
                            image_url: { url: frame.url }
                        });
                        userContent.push({
                            type: "text",
                            text: `时间点：${frame.time.toFixed(1)}秒`
                        });
                    });
                    
                    const apiMessages = [
                        { role: 'system', content: systemPrompt },
                        { role: 'user', content: userContent }
                    ];
                    
                    const response = await fetch(`${baseUrl}/v1/chat/completions`, {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${apiKey}`,
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            model: config?.modelName || 'gemini-3-pro-preview',
                            messages: apiMessages,
                            stream: false
                        })
                    });
                    
                    if (!response.ok) {
                        const errText = await response.text();
                        throw new Error(errText || `API Error: ${response.status}`);
                    }
                    
                    const data = await response.json();
                    const aiContent = data.choices?.[0]?.message?.content || "{}";
                    
                    // 解析 JSON
                    let jsonStr = aiContent.trim();
                    if (jsonStr.startsWith('```')) {
                        jsonStr = jsonStr.replace(/^```(?:json)?\n?/, '').replace(/\n?```$/, '');
                    }
                    
                    let result;
                    try {
                        result = JSON.parse(jsonStr);
                    } catch (e) {
                        console.error('解析 JSON 失败:', e, jsonStr);
                        // 尝试修复
                        try {
                            jsonStr = jsonStr.replace(/\/\*[\s\S]*?\*\//g, '').replace(/\/\/.*/g, '');
                            jsonStr = jsonStr.replace(/,(\s*[}\]])/g, '$1');
                            result = JSON.parse(jsonStr);
                        } catch (e2) {
                            throw new Error('模型返回的不是有效的 JSON 格式');
                        }
                    }
                    
                    // 更新节点状态
                    setNodes((prev) => prev.map((n) => 
                        n.id === nodeId 
                            ? { ...n, isExtractingVoiceover: false, voiceoverResults: result.voiceover || [] }
                            : n
                    ));
                    
                } catch (error) {
                    console.error('提取口播文案失败', error);
                    setNodes((prev) => prev.map((n) => 
                        n.id === nodeId 
                            ? { ...n, isExtractingVoiceover: false, errorMsg: error.message || '提取口播文案失败' }
                            : n
                    ));
                }
            };

            const handleToggleKeyframe = (nodeId, frame, index = 0, event = null) => {
                const shiftKey = !!event?.shiftKey;
                setNodes(prev => prev.map(n => {
                    if (n.id !== nodeId) return n;
                    const frames = n.frames || [];
                    const keyOf = (f) => `${f.time}-${f.url}`;
                    const frameMap = new Map(frames.map(f => [keyOf(f), f]));
                    const currentSelected = n.selectedKeyframes || [];
                    let nextSelected = [...currentSelected];

                    if (shiftKey && frameSelectionRef.current[nodeId] !== undefined && frameSelectionRef.current[nodeId] !== null && frames.length > 0) {
                        const lastIndex = frameSelectionRef.current[nodeId];
                        const start = Math.min(lastIndex, index);
                        const end = Math.max(lastIndex, index);
                        const rangeFrames = frames.slice(start, end + 1);
                        const selectedKeys = new Set(nextSelected.map(keyOf));
                        rangeFrames.forEach(f => selectedKeys.add(keyOf(f)));
                        nextSelected = Array.from(selectedKeys).map(k => frameMap.get(k)).filter(Boolean);
                    } else {
                        const exists = nextSelected.some(f => keyOf(f) === keyOf(frame));
                        nextSelected = exists 
                            ? nextSelected.filter(f => keyOf(f) !== keyOf(frame))
                            : [...nextSelected, frame];
                    }

                    frameSelectionRef.current[nodeId] = index;
                    return { ...n, selectedKeyframes: nextSelected };
                }));
            };

            const openFrameContextMenu = (e, nodeId, frame) => {
                e.preventDefault();
                e.stopPropagation();
                setFrameContextMenu({ visible: true, x: e.clientX, y: e.clientY, nodeId, frame });
            };

            const closeFrameContextMenu = () => {
                setFrameContextMenu({ visible: false, x: 0, y: 0, nodeId: null, frame: null });
            };

            const sendFrameToChat = () => {
                const { frame } = frameContextMenu;
                if (!frame?.url) return;
                const newFile = {
                    name: `Frame-${(frame.time ?? 0).toFixed(2)}s.png`,
                    type: 'image/png',
                    content: frame.url,
                    isImage: true,
                    isVideo: false,
                    isAudio: false,
                    fromHistory: true,
                    fileExt: 'png'
                };
                setChatFiles(prev => [...prev, newFile]);
                setIsChatOpen(true);
                closeFrameContextMenu();
            };

            const sendFrameToCanvas = async () => {
                const { frame } = frameContextMenu;
                if (!frame?.url) return;
                const world = screenToWorld(window.innerWidth / 2, window.innerHeight / 2);
                let dims;
                try {
                    const real = await getImageDimensions(frame.url);
                    if (real?.w && real?.h) dims = { w: real.w, h: real.h };
                } catch (e) {}
                addNode('input-image', world.x + 50, world.y + 50, null, frame.url, dims);
                closeFrameContextMenu();
            };

            const sendFrameToPreview = () => {
                const { frame } = frameContextMenu;
                if (!frame?.url) return;
                setNodes(prev => {
                    const previews = prev.filter(n => n.type === 'preview');
                    if (!previews.length) return prev;
                    const targetId = previews[previews.length - 1].id;
                    return prev.map(n =>
                        n.id === targetId
                            ? { ...n, content: frame.url, previewType: 'image' }
                            : n
                    );
                });
                closeFrameContextMenu();
            };

            const applyFrameToSelectedNode = () => {
                const { frame } = frameContextMenu;
                if (!frame?.url) return;
                const targetId = selectedNodeId;
                const targetNode = nodes.find(n => n.id === targetId);
                if (targetNode && targetNode.type === 'input-image') {
                    setNodes(prev => prev.map(n => n.id === targetId ? { ...n, content: frame.url } : n));
                } else {
                    alert('请先选择一个"图片输入"节点');
                }
                closeFrameContextMenu();
            };

            const handleHistoryRightClick = (e, item, imageUrl = null, imageIndex = null) => {
                e.preventDefault();
                e.stopPropagation();
                // 如果提供了 imageUrl 和 imageIndex，说明是点击了多图中的某一张
                // 否则使用 item.url（单图情况）
                const selectedUrl = imageUrl || item.url;
                const selectedIndex = imageIndex !== null ? imageIndex : (item.selectedMjImageIndex !== undefined ? item.selectedMjImageIndex : null);
                
                // 创建一个修改后的item，使用选中的图片URL
                const menuItem = {
                    ...item,
                    url: selectedUrl,
                    selectedMjImageIndex: selectedIndex
                };
                
                setHistoryContextMenu({ visible: true, x: e.clientX, y: e.clientY, item: menuItem });
            };

            const applyHistoryToSelectedNode = () => {
                const item = historyContextMenu.item;
                const targetId = selectedNodeId;
                const targetNode = nodes.find(n => n.id === targetId);

                if (targetNode && targetNode.type === 'input-image' && item.url) {
                    setNodes(prev => prev.map(n => n.id === targetId ? { ...n, content: item.url } : n));
                } else {
                    alert('请先选择一个"图片输入"节点');
                }
                setHistoryContextMenu({ visible: false, x: 0, y: 0, item: null });
            };

            const sendHistoryToCanvas = async () => {
                const item = historyContextMenu.item;
                if (!item?.url) return;
                const world = screenToWorld(window.innerWidth / 2, window.innerHeight / 2);
                
                // Fix: Mark video content so input-image node knows to display it properly
                let content = item.url;
                if (item.type === 'video' && !isVideoUrl(content)) {
                     // Append helper param so isVideoUrl returns true
                     content += (content.includes('?') ? '&' : '?') + 'force_video_display=true';
                }
                
                let dims;
                if (item.type === 'image') {
                    try {
                        const real = await getImageDimensions(content);
                        if (real?.w && real?.h) {
                            dims = { w: real.w, h: real.h };
                        }
                    } catch (e) {
                        console.error('SendHistoryToCanvas getImageDimensions error', e);
                    }
                }

                addNode('input-image', world.x + 50, world.y + 50, null, content, dims); 
                setHistoryContextMenu({ visible: false, x: 0, y: 0, item: null });
            };
            
            const sendHistoryToChat = () => {
                const item = historyContextMenu.item;
                if (!item || !item.url) return;
                
                // 确保正确识别图片和视频类型
                const isImage = item.type === 'image';
                const isVideo = item.type === 'video';
                const fileExt = isImage ? 'png' : (isVideo ? 'mp4' : 'file');
                const mimeType = isImage ? 'image/png' : (isVideo ? 'video/mp4' : 'application/octet-stream');
                
                const newFile = { 
                    name: `Generated-${item.id}.${fileExt}`, 
                    type: mimeType, 
                    content: item.url, 
                    isImage, 
                    isVideo, 
                    isAudio: false, 
                    fromHistory: true,
                    fileExt
                };
                
                setChatFiles(prev => [...prev, newFile]);
                setIsChatOpen(true); 
                setHistoryContextMenu({ visible: false, x: 0, y: 0, item: null });
            };

            // ... (rest of render logic unchanged) ...
            // 使用 useMemo 优化连接线渲染函数，避免重复查找和计算
            const renderConnections = useMemo(() => {
                return () => (
                    <div className="absolute inset-0 pointer-events-none overflow-visible w-full h-full">
                        <svg className="absolute inset-0 overflow-visible w-full h-full">
                            {connections.map((conn) => {
                                // 使用 nodesMap 快速查找，O(1) 复杂度
                                const fromNode = nodesMap.get(conn.from);
                                const toNode = nodesMap.get(conn.to);
                                if (!fromNode || !toNode) return null;
                                const startX = fromNode.x + fromNode.width - 4;
                                const startY = fromNode.y + fromNode.height / 2;
                                const endX = toNode.x + 4;
                                let endY = toNode.y + toNode.height / 2;

                                // 处理image-compare节点的多个输入点
                                if (toNode.type === 'image-compare') {
                                    // 使用缓存的 connectionsByNode，避免重复 filter
                                    const relevantConns = connectionsByNode.to.get(toNode.id) || [];
                                    const idx = relevantConns.findIndex(c => c.id === conn.id);
                                    if (idx === 0) endY = toNode.y + toNode.height * 0.33;
                                    else if (idx >= 1) endY = toNode.y + toNode.height * 0.66;
                                }
                                
                                // 处理Midjourney节点的oref和sref输入点
                                // 检查inputType是否为oref或sref（注意：default连接时inputType可能是undefined）
                                if (toNode.type === 'gen-image' && (conn.inputType === 'oref' || conn.inputType === 'sref')) {
                                    const currentModel = apiConfigs.find((m) => m.id === toNode.settings?.model);
                                    const isMidjourney = currentModel && (currentModel.id.includes('mj') || currentModel.provider.toLowerCase().includes('midjourney'));
                                    
                                    if (isMidjourney) {
                                        // 使用基于节点世界坐标的计算，考虑实际DOM结构
                                        // 节点结构：p-3(12px) + 计时器(如果有，约28px + mb-2=8px) + 标题(约16px + mb-2=8px) + 引用状态区域(如果有，约60px + mb-2=8px) + 提示词区域(约100px + mb-2=8px) + 指令区域
                                        // 指令区域：gap-1.5(6px) + oref项(约16px) + gap-1.5(6px) + ow项(约16px + input高度) + gap-1.5(6px) + sref项(约16px)
                                        const paddingTop = 12; // 节点顶部padding (p-3 = 12px)
                                        const timerHeight = 28; // 计时器区域高度（px-2 py-1 + text-[10px] ≈ 28px）
                                        const timerMarginBottom = 8; // 计时器下方margin (mb-2 = 8px)
                                        const titleHeight = 16; // 标题高度 (text-xs ≈ 12px + line-height ≈ 16px，flex items-center)
                                        const titleMarginBottom = 8; // 标题下方margin (mb-2 = 8px)
                                        const refAreaHeight = 60; // 引用状态区域高度（p-2 + 内容，约60px）
                                        const refAreaMarginBottom = 8; // 引用区域下方margin (mb-2 = 8px)
                                        const promptAreaHeight = 100; // 提示词区域高度（p-3 + textarea，约100px）
                                        const promptAreaMarginBottom = 8; // 提示词区域下方margin (mb-2 = 8px)
                                        const instructionGap = 6; // 指令项之间的gap (gap-1.5 = 6px)
                                        const instructionItemHeight = 16; // 每个指令项的实际高度（text-[10px] + flex items-center ≈ 16px）
                                        const owInputHeight = 28; // ow输入框高度（px-2 py-1 + text-[10px] ≈ 28px）
                                        
                                        // 检查是否有计时器（正在生成或已完成）
                                        const hasTimer = false; // 计时器是动态的，这里简化处理，实际应该从节点状态判断
                                        
                                        // 使用缓存的 connectionsByNode，避免重复 some 计算
                                        const toNodeConns = connectionsByNode.to.get(toNode.id) || [];
                                        const hasRefArea = toNodeConns.some(c => !c.inputType || c.inputType === 'default');
                                        
                                        // 计算基础偏移（到指令区域开始的位置）
                                        let baseOffset = paddingTop;
                                        if (hasTimer) {
                                            baseOffset += timerHeight + timerMarginBottom;
                                        }
                                        baseOffset += titleHeight + titleMarginBottom;
                                        if (hasRefArea) {
                                            baseOffset += refAreaHeight + refAreaMarginBottom;
                                        }
                                        baseOffset += promptAreaHeight + promptAreaMarginBottom;
                                        
                                        if (conn.inputType === 'oref') {
                                            // oref在第一个指令位置（第一个指令项的中心）
                                            // 指令区域开始 + 第一个指令项的中心
                                            endY = toNode.y + baseOffset + instructionItemHeight * 0.5;
                                        } else if (conn.inputType === 'sref') {
                                            // sref在第三个指令位置
                                            // 指令区域开始 + oref项(16px) + gap(6px) + ow项(owInputHeight ≈ 28px) + gap(6px) + sref项的中心(8px)
                                            endY = toNode.y + baseOffset + instructionItemHeight + instructionGap + owInputHeight + instructionGap + instructionItemHeight * 0.5;
                                        }
                                    }
                                }

                                const dist = Math.abs(endX - startX);
                                const cp1X = startX + dist * 0.5;
                                const cp2X = endX - dist * 0.5;
                                return (
                                    <g key={conn.id} className="connection-group">
                                        <path d={`M ${startX} ${startY} C ${cp1X} ${startY}, ${cp2X} ${endY}, ${endX} ${endY}`} stroke="transparent" strokeWidth="20" fill="none" style={{pointerEvents: 'stroke'}} />
                                        <path d={`M ${startX} ${startY} C ${cp1X} ${startY}, ${cp2X} ${endY}, ${endX} ${endY}`} stroke="#18181b" strokeWidth="4" fill="none" />
                                        <path d={`M ${startX} ${startY} C ${cp1X} ${startY}, ${cp2X} ${endY}, ${endX} ${endY}`} stroke="#71717a" strokeWidth="2" fill="none" />
                                        <circle cx={startX} cy={startY} r="2" fill="#71717a" />
                                        <circle cx={endX} cy={endY} r="2" fill="#71717a" />
                                        <g className="connection-delete cursor-pointer" onClick={() => disconnectConnection(conn.id)}>
                                            <circle cx={(startX + endX) / 2} cy={(startY + endY) / 2} r="8" fill="#ef4444" />
                                            <Unlink size={10} className="text-white" x={(startX + endX) / 2 - 5} y={(startY + endY) / 2 - 5} />
                                        </g>
                                    </g>
                                );
                            })}
                            {connectingSource && (() => {
                                // 使用 nodesMap 快速查找
                                const node = nodesMap.get(connectingSource);
                                if (!node) return null;
                                return <path d={`M ${node.x + node.width - 4} ${node.y + node.height / 2} C ${node.x + node.width + 100} ${node.y + node.height / 2}, ${mousePos.x - 100} ${mousePos.y}, ${mousePos.x} ${mousePos.y}`} stroke="#60a5fa" strokeWidth="2" fill="none" strokeDasharray="4,4" />;
                            })()}
                            {connectingTarget && (() => {
                                // 使用 nodesMap 快速查找
                                const node = nodesMap.get(connectingTarget);
                                if (!node) return null;
                            // 从输入端口向左拖拽，连接线从左侧开始
                            const startX = node.x + 4;
                            let startY = node.y + node.height / 2;
                            
                            // 处理Midjourney节点的oref和sref输入点
                            if (node.type === 'gen-image' && connectingInputType) {
                                const currentModel = apiConfigs.find((m) => m.id === node.settings?.model);
                                const isMidjourney = currentModel && (currentModel.id.includes('mj') || currentModel.provider.toLowerCase().includes('midjourney'));
                                
                                if (isMidjourney) {
                                    // 使用与连接线渲染相同的计算逻辑
                                    const paddingTop = 12;
                                    const timerHeight = 28;
                                    const timerMarginBottom = 8;
                                    const titleHeight = 16; // 标题高度 (text-xs ≈ 12px + line-height ≈ 16px)
                                    const titleMarginBottom = 8;
                                    const refAreaHeight = 60;
                                    const refAreaMarginBottom = 8;
                                    const promptAreaHeight = 100;
                                    const promptAreaMarginBottom = 8;
                                    const instructionGap = 6;
                                    const instructionItemHeight = 16; // 每个指令项的实际高度（text-[10px] + flex items-center ≈ 16px）
                                    const owInputHeight = 28; // ow输入框高度（px-2 py-1 + text-[10px] ≈ 28px）
                                    
                                    const hasTimer = false; // 计时器是动态的，这里简化处理
                                    // 使用缓存的 connectionsByNode，避免重复 some 计算
                                    const toNodeConns = connectionsByNode.to.get(node.id) || [];
                                    const hasRefArea = toNodeConns.some(c => !c.inputType || c.inputType === 'default');
                                    
                                    let baseOffset = paddingTop;
                                    if (hasTimer) {
                                        baseOffset += timerHeight + timerMarginBottom;
                                    }
                                    baseOffset += titleHeight + titleMarginBottom;
                                    if (hasRefArea) {
                                        baseOffset += refAreaHeight + refAreaMarginBottom;
                                    }
                                    baseOffset += promptAreaHeight + promptAreaMarginBottom;
                                    
                                    if (connectingInputType === 'oref') {
                                        startY = node.y + baseOffset + instructionItemHeight * 0.5;
                                    } else if (connectingInputType === 'sref') {
                                        // sref在第三个指令位置：oref项(16px) + gap(6px) + ow项(owInputHeight ≈ 28px) + gap(6px) + sref项的中心(8px)
                                        startY = node.y + baseOffset + instructionItemHeight + instructionGap + owInputHeight + instructionGap + instructionItemHeight * 0.5;
                                    }
                                }
                            }
                            // 处理image-compare节点的多个输入点
                            else if (node.type === 'image-compare') {
                                // 这里可以根据鼠标位置判断是哪个输入点，暂时使用中间位置
                                startY = node.y + node.height / 2;
                            }
                            
                            return <path d={`M ${startX} ${startY} C ${startX - 100} ${startY}, ${mousePos.x + 100} ${mousePos.y}, ${mousePos.x} ${mousePos.y}`} stroke="#60a5fa" strokeWidth="2" fill="none" strokeDasharray="4,4" />;
                        })()}
                    </svg>
                </div>
            );
            }, [connections, nodesMap, connectionsByNode, connectingSource, connectingTarget, connectingInputType, mousePos, apiConfigs]);

            // 使用 useMemo 缓存节点的连接状态，避免每次渲染时重复计算
            const nodeConnectedStatus = useMemo(() => {
                const status = new Map(); // nodeId -> boolean
                connections.forEach(conn => {
                    if (!conn.inputType || conn.inputType === 'default') {
                        status.set(conn.to, true);
                    }
                });
                return status;
            }, [connections]);

            const renderNode = (node) => {
                const isSelected = selectedNodeId === node.id || selectedNodeIds.has(node.id);
                const connectedImages = getConnectedInputImages(node.id);
                const isHoverTarget = hoverTargetId === node.id;
                // 使用缓存的连接状态，O(1) 查找
                const isConnected = nodeConnectedStatus.get(node.id) || false;

                return (
                    <div
                        key={node.id}
                        data-node-id={node.id}
                        className={`absolute rounded-xl shadow-xl transition-shadow duration-150 group flex flex-col node-wrapper ${
                            isSelected
                                ? 'ring-1 ring-blue-500 shadow-blue-500/20'
                                : theme === 'dark'
                                    ? 'border border-zinc-800 shadow-black/40'
                                    : 'border border-zinc-200 shadow-black/10'
                        } ${isHoverTarget && ((connectingSource && connectingSource !== node.id) || (connectingTarget && connectingTarget !== node.id)) ? 'ring-2 ring-green-500/50' : ''} ${
                            theme === 'dark' ? 'bg-[#18181b]' : 'bg-white'
                        }`}
                        style={{ 
                            left: node.x, 
                            top: node.y, 
                            width: node.width, 
                            height: node.height, 
                            cursor: (dragNodeId === node.id || (dragNodeId && selectedNodeIds.has(node.id))) ? 'grabbing' : 'default', 
                            zIndex: 10,
                            WebkitFontSmoothing: 'antialiased',
                            MozOsxFontSmoothing: 'grayscale',
                            textRendering: 'optimizeLegibility',
                            transform: 'translateZ(0)',
                            backfaceVisibility: 'hidden'
                        }}
                        onMouseDown={(e) => { 
                            if (e.button === 0) { 
                                e.stopPropagation(); 
                                // 如果按住了Ctrl键，添加到多选
                                if (e.ctrlKey || e.metaKey) {
                                    setSelectedNodeIds(prev => {
                                        const newSet = new Set(prev);
                                        if (newSet.has(node.id)) {
                                            newSet.delete(node.id);
                                        } else {
                                            newSet.add(node.id);
                                        }
                                        // 如果多选集合为空或只有一个，更新selectedNodeId
                                        if (newSet.size === 1) {
                                            setSelectedNodeId(Array.from(newSet)[0]);
                                        } else {
                                            setSelectedNodeId(null);
                                        }
                                        return newSet;
                                    });
                                } else {
                                    // 如果没有按住Ctrl，检查该节点是否已经在多选集合中
                                    const isAlreadySelected = selectedNodeIds.has(node.id);
                                    if (isAlreadySelected && selectedNodeIds.size > 1) {
                                        // 如果节点已经在多选集合中，保持多选状态，不重置
                                        // 只更新 selectedNodeId 为当前节点（用于显示详情等）
                                        setSelectedNodeId(node.id);
                                    } else {
                                        // 单选模式：重置为只选中当前节点
                                        setSelectedNodeId(node.id);
                                        setSelectedNodeIds(new Set([node.id]));
                                    }
                                }
                                setDragNodeId(node.id); 
                                setActiveDropdown(null); 
                            } 
                        }}
                        onMouseEnter={() => { if (connectingSource || connectingTarget) setHoverTargetId(node.id); }}
                        onMouseLeave={() => { if ((connectingSource || connectingTarget) && hoverTargetId === node.id) setHoverTargetId(null); }}
                        onMouseUp={(e) => handleNodeMouseUp(node.id, e)}
                    >
                        <button
                            onClick={(e) => { e.stopPropagation(); deleteNode(node.id); }}
                            className={`absolute -top-2.5 -right-2.5 z-50 p-1 rounded-full shadow border opacity-0 group-hover:opacity-100 transition-opacity scale-90 hover:scale-100 ${
                                theme === 'dark'
                                    ? 'bg-zinc-800 text-zinc-400 hover:text-red-500 hover:bg-zinc-700 border-zinc-700'
                                    : 'bg-zinc-100 text-zinc-500 hover:text-red-500 hover:bg-zinc-200 border-zinc-300'
                            }`}
                            onMouseDown={(e) => e.stopPropagation()}
                        >
                            <X size={12} />
                        </button>
                        <div className="absolute bottom-1 right-1 w-4 h-4 z-50 resize-handle flex items-end justify-end p-0.5" onMouseDown={(e) => { e.stopPropagation(); e.preventDefault(); setResizingNodeId(node.id); }}><svg width="6" height="6" viewBox="0 0 8 8" fill="none" className="text-zinc-600"><path d="M8 0L8 8L0 8" stroke="currentColor" strokeWidth="2" /></svg></div>
                        
                        {node.type !== 'input-image' && node.type !== 'video-input' && node.type !== 'video-analyze' && node.type !== 'preview' && (
                            node.type === 'image-compare' ? (
                                <>
                                    <div 
                                        className={`input-point ${connectingTarget === node.id && !connectingInputType ? 'active' : ''}`} 
                                        style={{ top: '33%' }} 
                                        title="图 1 输入" 
                                        onMouseDown={(e) => { e.stopPropagation(); e.preventDefault(); setConnectingTarget(node.id); setConnectingInputType('default'); }}
                                        onMouseUp={(e) => handleNodeMouseUp(node.id, e, 'default')} 
                                    />
                                    <div 
                                        className={`input-point ${connectingTarget === node.id && !connectingInputType ? 'active' : ''}`} 
                                        style={{ top: '66%' }} 
                                        title="图 2 输入" 
                                        onMouseDown={(e) => { e.stopPropagation(); e.preventDefault(); setConnectingTarget(node.id); setConnectingInputType('default'); }}
                                        onMouseUp={(e) => handleNodeMouseUp(node.id, e, 'default')} 
                                    />
                                </>
                            ) : (
                                <div 
                                    className={`input-point ${isConnected ? 'connected' : ''} ${connectingTarget === node.id && !connectingInputType ? 'active' : ''}`} 
                                    title="输入" 
                                    onMouseDown={(e) => { e.stopPropagation(); e.preventDefault(); setConnectingTarget(node.id); setConnectingInputType('default'); }}
                                    onMouseUp={(e) => handleNodeMouseUp(node.id, e, 'default')} 
                                />
                            )
                        )}
                        
                        {node.type !== 'preview' && (
                            <div
                                className={`connector connector-right ${connectingSource === node.id ? 'active' : ''} ${connectingTarget && hoverTargetId === node.id ? 'ring-2 ring-green-500/50' : ''}`}
                                title="输出"
                                onMouseDown={(e) => { e.stopPropagation(); e.preventDefault(); setConnectingSource(node.id); }}
                                onMouseEnter={() => { if (connectingTarget) setHoverTargetId(node.id); }}
                                onMouseLeave={() => { if (connectingTarget && hoverTargetId === node.id) setHoverTargetId(null); }}
                            >
                                <Plus size={10} />
                            </div>
                        )}

                        <div
                            className={`overflow-hidden rounded-xl flex-1 flex flex-col pointer-events-none h-full w-full relative ${
                                theme === 'dark' ? 'bg-[#18181b]' : 'bg-white'
                            }`}
                        >
                            {node.type === 'input-image' && (
                                <div
                                    className={`relative w-full h-full flex flex-col items-center justify-center transition-colors pointer-events-auto drop-zone ${
                                        theme === 'dark'
                                            ? 'bg-zinc-900 group-hover:bg-zinc-800'
                                            : 'bg-zinc-100 group-hover:bg-zinc-200'
                                    }`}
                                    onDrop={(e) => handleDrop(node.id, e)}
                                    onDragOver={handleDragOver}
                                    onDragLeave={handleDragLeave}
                                >
                                    {node.content ? (
                                        <div className="relative w-full h-full">
                                            {isVideoUrl(node.content) ? (
                                                 <video 
                                                    src={node.content} 
                                                    controls 
                                                    className="w-full h-full object-contain bg-black/50" 
                                                    draggable={false}
                                                    style={{
                                                        imageRendering: view.zoom >= 1 ? 'auto' : 'crisp-edges',
                                                        WebkitFontSmoothing: 'antialiased',
                                                        transform: 'translateZ(0)',
                                                        backfaceVisibility: 'hidden',
                                                        WebkitBackfaceVisibility: 'hidden'
                                                    }}
                                                />
                                            ) : (
                                                 <img 
                                                    src={node.content} 
                                                    className="w-full h-full object-contain bg-black/50" 
                                                    draggable={false}
                                                    style={{
                                                        imageRendering: view.zoom >= 1 ? 'auto' : 'crisp-edges',
                                                        WebkitFontSmoothing: 'antialiased',
                                                        transform: 'translateZ(0)',
                                                        backfaceVisibility: 'hidden',
                                                        WebkitBackfaceVisibility: 'hidden'
                                                    }}
                                                />
                                            )}
                                            {node.dimensions && (
                                                <div
                                                    className={`absolute bottom-2 right-2 text-[10px] px-1.5 py-0.5 rounded backdrop-blur-sm border ${
                                                        theme === 'dark'
                                                            ? 'bg-black/70 text-white border-white/10'
                                                            : 'bg-white/80 text-zinc-800 border-zinc-200'
                                                    }`}
                                                >
                                                    {node.dimensions.w}x{node.dimensions.h}
                                                </div>
                                            )}
                                            <div className="absolute inset-0 bg-black/40 opacity-0 group-hover:opacity-100 flex flex-col items-center justify-center transition-opacity gap-2">
                                                <label
                                                    className={`cursor-pointer px-3 py-1.5 rounded-lg text-xs backdrop-blur-sm border transition-colors ${
                                                        theme === 'dark'
                                                            ? 'bg-white/10 hover:bg-white/20 text-white border-white/10'
                                                            : 'bg-white hover:bg-zinc-100 text-zinc-800 border-zinc-300'
                                                    }`}
                                                    onMouseDown={(e) => e.stopPropagation()}
                                                >
                                                    更换 <input type="file" className="hidden" accept="image/*" onChange={(e) => handleFileUpload(node.id, e)} />
                                                </label>
                                                <div
                                                    className={`text-[10px] text-center px-2 ${
                                                        theme === 'dark' ? 'text-zinc-300' : 'text-zinc-500'
                                                    }`}
                                                >
                                                    或拖放图片到此处
                                                    <br />
                                                    或 Ctrl+V 粘贴
                                                </div>
                                            </div>
                                        </div>
                                    ) : (
                                        <div className="flex flex-col items-center justify-center h-full w-full">
                                             <div
                                                className={`w-12 h-12 rounded-2xl flex items-center justify-center mb-3 border ${
                                                    theme === 'dark'
                                                        ? 'bg-zinc-800 border-zinc-700/50'
                                                        : 'bg-zinc-100 border-zinc-300'
                                                }`}
                                             >
                                                <ImageIcon
                                                    className={`w-6 h-6 ${
                                                        theme === 'dark' ? 'text-zinc-500' : 'text-zinc-400'
                                                    }`}
                                                />
                                             </div>
                                             <label
                                                className="bg-blue-600 hover:bg-blue-500 text-white px-4 py-2 rounded-lg text-xs font-medium transition-colors cursor-pointer pointer-events-auto"
                                                onMouseDown={(e) => e.stopPropagation()}
                                             >
                                                选择图片
                                                <input type="file" className="hidden" accept="image/*" onChange={(e) => handleFileUpload(node.id, e)} />
                                             </label>
                                             <div
                                                className={`text-[10px] text-center mt-2 pointer-events-none ${
                                                    theme === 'dark' ? 'text-zinc-500' : 'text-zinc-500'
                                                }`}
                                             >
                                                或拖放图片到此处
                                                <br />
                                                或 Ctrl+V 粘贴
                                             </div>
                                        </div>
                                    )}
                                </div>
                            )}

                            {node.type === 'video-input' && (
                                <div
                                    className={`relative w-full h-full flex flex-col transition-colors pointer-events-auto drop-zone video-input-container ${
                                        theme === 'dark'
                                            ? 'bg-zinc-900/80'
                                            : 'bg-zinc-100'
                                    }`}
                                    onDrop={(e) => handleVideoDrop(node.id, e)}
                                    onDragOver={handleDragOver}
                                    onDragLeave={handleDragLeave}
                                >
                                    <div className="flex items-center justify-between px-3 py-2 border-b text-xs font-semibold">
                                        <div className="flex items-center gap-1.5">
                                            <Video size={13} className="text-blue-500" />
                                            <span>视频输入</span>
                                        </div>
                                        <div className="flex items-center gap-2 text-[10px] text-zinc-500">
                                            {node.videoMeta?.duration ? <span>时长 {node.videoMeta.duration.toFixed(1)}s</span> : null}
                                            {node.videoMeta?.w ? <span>{node.videoMeta.w}x{node.videoMeta.h}</span> : null}
                                            {node.selectedKeyframes?.length ? <span className="text-blue-500">关键帧 {node.selectedKeyframes.length} 个</span> : null}
                                        </div>
                                    </div>

                                    <div className="flex-1 flex flex-col gap-3 p-3 overflow-hidden min-h-0">
                                        {node.content ? (
                                            <div className="space-y-2">
                                                <div className="relative w-full aspect-video bg-black rounded-lg overflow-hidden flex items-center justify-center">
                                                    <video
                                                        src={node.content}
                                                        controls
                                                        className="w-full h-full object-contain"
                                                        draggable={false}
                                                    />
                                                </div>
                                                <div className="flex items-center gap-2">
                                                    <label
                                                        className="bg-blue-600 hover:bg-blue-500 text-white px-3 py-1.5 rounded text-xs font-medium transition-colors cursor-pointer"
                                                        onMouseDown={(e) => e.stopPropagation()}
                                                    >
                                                        更换视频
                                                        <input
                                                            type="file"
                                                            className="hidden"
                                                            accept="video/*"
                                                            onChange={(e) => handleVideoFileUpload(node.id, e.target.files?.[0])}
                                                        />
                                                    </label>
                                                    <button
                                                        className="px-3 py-1.5 rounded text-xs border hover:border-blue-500 hover:text-blue-600 transition-colors"
                                                        onMouseDown={(e) => e.stopPropagation()}
                                                        onClick={() => handleAutoExtractKeyframes(node.id, 2)}
                                                    >
                                                        自动抽帧（2fps）
                                                    </button>
                                                    <button
                                                        className="px-3 py-1.5 rounded text-xs border hover:border-green-500 hover:text-green-600 transition-colors bg-green-50 dark:bg-green-900/20 border-green-300 dark:border-green-700"
                                                        onMouseDown={(e) => e.stopPropagation()}
                                                        onClick={() => handleSmartExtractKeyframes(node.id, 30)}
                                                    >
                                                        智能抽帧
                                                    </button>
                                                    {node.extractingFrames && (
                                                        <span className="text-[11px] text-blue-500">抽帧中...</span>
                                                    )}
                                                </div>
                                            </div>
                                        ) : (
                                            <div className="flex flex-col items-center justify-center flex-1 gap-3">
                                                <div
                                                    className={`w-12 h-12 rounded-2xl flex items-center justify-center border ${
                                                        theme === 'dark'
                                                            ? 'bg-zinc-800 border-zinc-700/50'
                                                            : 'bg-zinc-100 border-zinc-300'
                                                    }`}
                                                >
                                                    <Video className={`w-6 h-6 ${theme === 'dark' ? 'text-zinc-500' : 'text-zinc-400'}`} />
                                                </div>
                                                <label
                                                    className="bg-blue-600 hover:bg-blue-500 text-white px-4 py-2 rounded-lg text-xs font-medium transition-colors cursor-pointer"
                                                    onMouseDown={(e) => e.stopPropagation()}
                                                >
                                                    选择或拖拽视频
                                                    <input
                                                        type="file"
                                                        className="hidden"
                                                        accept="video/*"
                                                        onChange={(e) => handleVideoFileUpload(node.id, e.target.files?.[0])}
                                                    />
                                                </label>
                                                <div className="text-[10px] text-center text-zinc-500 pointer-events-none">
                                                    支持 MP4/WEBM，拖拽或 Ctrl+V 不可用
                                                </div>
                                            </div>
                                        )}

                                        <div className="flex items-center justify-between text-[11px] text-zinc-500">
                                            <span>抽帧缩略图</span>
                                            <span>{(node.frames || []).length} 张</span>
                                        </div>
                                        <div
                                            className="grid gap-3 w-full overflow-y-auto custom-scrollbar flex-1 min-h-0"
                                            style={{
                                                gridTemplateColumns: 'repeat(auto-fill, minmax(clamp(140px, 20vw, 240px), 1fr))',
                                                gridAutoRows: 'minmax(110px, auto)'
                                            }}
                                        >
                                            {(node.frames || []).length === 0 ? (
                                                <div className="col-span-full text-[11px] text-zinc-500 text-center py-4 border rounded bg-white/40">
                                                    点击「自动抽帧」即可生成缩略图
                                                </div>
                                            ) : (
                                                (node.frames || []).map((frame, idx) => {
                                                    const selected = (node.selectedKeyframes || []).some(f => f.url === frame.url && f.time === frame.time);
                                                    return (
                                                        <button
                                                            key={`${frame.url}-${idx}`}
                                                            className={`relative rounded border overflow-hidden group ${selected ? 'ring-2 ring-blue-500' : ''}`}
                                                            onMouseDown={(e) => e.stopPropagation()}
                                                            onClick={(e) => handleToggleKeyframe(node.id, frame, idx, e)}
                                                            onContextMenu={(e) => openFrameContextMenu(e, node.id, frame)}
                                                        >
                                                            <img src={frame.url} className="w-full aspect-video object-contain bg-black" alt={`frame-${idx}`} />
                                                            <div className="absolute left-1 top-1 text-[10px] px-1 py-0.5 rounded bg-black/60 text-white">
                                                                {frame.time.toFixed(2)}s
                                                            </div>
                                                            <div className="absolute right-1 top-1 w-4 h-4 rounded-full border border-white/80 bg-black/40 flex items-center justify-center">
                                                                {selected ? <CheckCircle2 size={10} className="text-white" /> : null}
                                                            </div>
                                                        </button>
                                                    );
                                                })
                                            )}
                                        </div>
                                    </div>
                                </div>
                            )}

                            {node.type === 'video-analyze' && (
                                <div
                                    className={`relative w-full h-full flex flex-col transition-colors pointer-events-auto video-analyze-container ${theme === 'dark' ? 'bg-zinc-900/80' : 'bg-zinc-100'}`}
                                >
                                    <div className="flex items-center justify-between px-3 py-2 border-b text-xs font-semibold">
                                        <div className="flex items-center gap-1.5">
                                            <FileSearch size={13} className="text-blue-500" />
                                            <span>视频拆解 / 提示词反推</span>
                                        </div>
                                    </div>

                                    <div className="flex-1 flex flex-col gap-3 p-3 overflow-hidden min-h-0">
                                        {(() => {
                                            const videoInputNode = getConnectedVideoInputNode(node.id);
                                            if (!videoInputNode) {
                                                return (
                                                    <div className="flex flex-col items-center justify-center flex-1 gap-2 text-[11px] text-zinc-500">
                                                        <LinkIcon size={24} className="text-zinc-400" />
                                                        <span>请连接一个视频输入节点</span>
                                                    </div>
                                                );
                                            }
                                            
                                            const videoFileName = videoInputNode.videoFileName || '未命名视频';
                                            const videoDuration = videoInputNode.videoMeta?.duration || 0;
                                            const selectedKeyframes = videoInputNode.selectedKeyframes || [];
                                            
                                            return (
                                                <>
                                                    <div className="space-y-2">
                                                        <div className={`text-[11px] px-2 py-1.5 rounded border ${theme === 'dark' ? 'bg-zinc-800 border-zinc-700' : 'bg-white border-zinc-300'}`}>
                                                            <div className="flex items-center justify-between mb-1">
                                                                <span className="text-zinc-500">关联的视频</span>
                                                            </div>
                                                            <div className="text-zinc-700 dark:text-zinc-300">
                                                                <div>文件名: {videoFileName}</div>
                                                                <div>总时长: {videoDuration.toFixed(1)}s</div>
                                                                <div>已选关键帧: {selectedKeyframes.length} 个</div>
                                                            </div>
                                                        </div>
                                                        
                                                        {/* 模式选择切换按钮 */}
                                                        <div className="flex items-center gap-2 bg-zinc-100 dark:bg-zinc-800 p-1 rounded-lg border border-zinc-200 dark:border-zinc-700 shadow-inner">
                                                            <button
                                                                onClick={() => updateNodeSettings(node.id, { analysisMode: 'manual' })}
                                                                className={`flex-1 py-1 px-2 text-[11px] rounded transition-all flex justify-center items-center gap-1 ${
                                                                    (node.settings?.analysisMode || 'manual') === 'manual'
                                                                        ? 'bg-white dark:bg-zinc-600 shadow-md text-blue-600 dark:text-blue-300 font-bold'
                                                                        : 'text-zinc-500 hover:text-zinc-700 dark:hover:text-zinc-300'
                                                                }`}
                                                                onMouseDown={(e) => e.stopPropagation()}
                                                            >
                                                                <Camera size={12} /> 手动选帧拆解
                                                            </button>
                                                            <button
                                                                onClick={() => updateNodeSettings(node.id, { analysisMode: 'auto' })}
                                                                className={`flex-1 py-1 px-2 text-[11px] rounded transition-all flex justify-center items-center gap-1 ${
                                                                    node.settings?.analysisMode === 'auto'
                                                                        ? 'bg-white dark:bg-zinc-600 shadow-md text-purple-600 dark:text-purple-300 font-bold'
                                                                        : 'text-zinc-500 hover:text-zinc-700 dark:hover:text-zinc-300'
                                                                }`}
                                                                onMouseDown={(e) => e.stopPropagation()}
                                                            >
                                                                <Sparkles size={12} /> AI 导演拆解
                                                            </button>
                                                        </div>
                                                        
                                                        {(node.settings?.analysisMode || 'manual') === 'manual' && (
                                                            <>
                                                                <div className="flex items-center gap-2">
                                                                    <label className="text-[11px] text-zinc-500">按时间段分组:</label>
                                                                    <input
                                                                        type="number"
                                                                        min="1"
                                                                        max="30"
                                                                        value={node.settings?.segmentDuration || 3}
                                                                        onChange={(e) => updateNodeSettings(node.id, { segmentDuration: parseInt(e.target.value) || 3 })}
                                                                        className={`w-16 px-2 py-1 text-[11px] rounded border ${theme === 'dark' ? 'bg-zinc-800 border-zinc-700 text-zinc-300' : 'bg-white border-zinc-300 text-zinc-800'}`}
                                                                        onMouseDown={(e) => e.stopPropagation()}
                                                                    />
                                                                    <span className="text-[11px] text-zinc-500">秒</span>
                                                                </div>
                                                                
                                                                <div className="flex items-center gap-2">
                                                                    <label className="text-[11px] text-zinc-500">模型:</label>
                                                                    <select
                                                                        value={node.settings?.model || 'gemini-3-pro'}
                                                                        onChange={(e) => updateNodeSettings(node.id, { model: e.target.value })}
                                                                        className={`flex-1 px-2 py-1 text-[11px] rounded border ${theme === 'dark' ? 'bg-zinc-800 border-zinc-700 text-zinc-300' : 'bg-white border-zinc-300 text-zinc-800'}`}
                                                                        onMouseDown={(e) => e.stopPropagation()}
                                                                    >
                                                                        {apiConfigs.filter(c => c.type === 'Chat' && ['gemini-3-pro', 'gpt-5-1', 'deepseek-v3'].includes(c.id)).map(c => (
                                                                            <option key={c.id} value={c.id}>{c.provider}</option>
                                                                        ))}
                                                                    </select>
                                                                </div>
                                                            </>
                                                        )}
                                                        
                                                        <button
                                                            onClick={() => node.settings?.analysisMode === 'auto' ? handleAutoVideoAnalysis(node.id) : handleGeneratePrompts(node.id)}
                                                            disabled={node.isGenerating || ((node.settings?.analysisMode || 'manual') === 'manual' && selectedKeyframes.length === 0)}
                                                            className={`w-full px-3 py-2 rounded text-xs font-medium transition-colors flex items-center justify-center gap-2 ${
                                                                node.isGenerating
                                                                    ? 'bg-zinc-600 text-zinc-400 cursor-not-allowed'
                                                                    : node.settings?.analysisMode === 'auto'
                                                                        ? 'bg-gradient-to-r from-purple-600 to-indigo-600 hover:from-purple-500 hover:to-indigo-500 text-white shadow-lg'
                                                                        : 'bg-blue-600 hover:bg-blue-500 text-white'
                                                            }`}
                                                            onMouseDown={(e) => e.stopPropagation()}
                                                        >
                                                            {node.isGenerating ? (
                                                                <>
                                                                    <Loader2 size={14} className="animate-spin" />
                                                                    <span>{node.settings?.analysisMode === 'auto' ? 'AI 正在拉片分析中...' : '生成中...'}</span>
                                                                </>
                                                            ) : (
                                                                <>
                                                                    <Sparkles size={14} />
                                                                    <span>{node.settings?.analysisMode === 'auto' ? '开始全自动拆解视频' : '为选中关键帧生成提示词'}</span>
                                                                </>
                                                            )}
                                                        </button>
                                                        
                                                        {node.errorMsg && (
                                                            <div className="text-[10px] text-red-500 px-2 py-1 rounded bg-red-500/10">
                                                                {node.errorMsg}
                                                            </div>
                                                        )}
                                                    </div>
                                                    
                                                    {/* 结果展示区 (Auto 模式) */}
                                                    {node.settings?.analysisMode === 'auto' && node.settings?.analysisResults?.length > 0 && (
                                                        <div className="flex-1 overflow-y-auto custom-scrollbar pt-2">
                                                            {/* 口播文案 (Voiceover) */}
                                                            {node.settings.voiceoverResults?.length > 0 && (
                                                                <div className={`p-2 rounded-lg mb-4 ${theme === 'dark' ? 'bg-zinc-700/50 border border-zinc-700' : 'bg-blue-50 border border-blue-200'}`}>
                                                                    <h4 className={`text-xs font-semibold mb-2 flex items-center gap-1 ${theme === 'dark' ? 'text-white' : 'text-blue-700'}`}>
                                                                        <Mic2 size={12} /> 提取口播文案
                                                                    </h4>
                                                                    <div className="space-y-1">
                                                                        {node.settings.voiceoverResults.map((v, i) => (
                                                                            <p key={i} className={`text-[10px] select-text cursor-text ${theme === 'dark' ? 'text-zinc-300' : 'text-zinc-700'}`}>
                                                                                <span className="font-mono text-xs mr-2 opacity-70">[{v.time_range || `${v.time}s`}]</span>
                                                                                {v.text || <span className="text-zinc-400 italic">（无口播）</span>}
                                                                            </p>
                                                                        ))}
                                                                    </div>
                                                                </div>
                                                            )}

                                                            {/* 场景拆解结果 */}
                                                            <h4 className={`text-xs font-semibold mb-3 flex items-center gap-1 ${theme === 'dark' ? 'text-white' : 'text-zinc-800'}`}>
                                                                <Camera size={12} /> 导演级场景分析 ({node.settings.analysisResults.length} 场景)
                                                            </h4>
                                                            
                                                            <div className="space-y-4">
                                                                {node.settings.analysisResults.map((scene, i) => (
                                                                    <div key={i} className={`p-3 rounded-lg ${theme === 'dark' ? 'bg-zinc-800 border border-zinc-700' : 'bg-white border border-zinc-200'}`}>
                                                                        <h5 className={`text-sm font-bold mb-2 ${theme === 'dark' ? 'text-purple-400' : 'text-purple-700'}`}>
                                                                            场景 {scene.scene_index || scene.scene_id || i + 1} <span className="text-xs font-normal opacity-70 ml-2">({scene.time_range})</span>
                                                                        </h5>
                                                                        
                                                                        {/* 视觉分析 */}
                                                                        <div className="text-[11px] space-y-1 mb-3">
                                                                            {scene.keyframes?.[0]?.description && (
                                                                                <p className={`select-text cursor-text ${theme === 'dark' ? 'text-zinc-300' : 'text-zinc-700'}`}>
                                                                                    <span className="font-semibold mr-1">运镜/动态:</span> {scene.keyframes[0].description}
                                                                                </p>
                                                                            )}
                                                                            {scene.global_tags?.style?.[0] && (
                                                                                <p className={`select-text cursor-text ${theme === 'dark' ? 'text-zinc-300' : 'text-zinc-700'}`}>
                                                                                    <span className="font-semibold mr-1">氛围/风格:</span> {scene.global_tags.style[0]}
                                                                                </p>
                                                                            )}
                                                                        </div>

                                                                        {/* 提示词输出 */}
                                                                        <div className="space-y-2">
                                                                            {/* 即梦 Prompt */}
                                                                            {scene.keyframes?.[0]?.jimeng_prompt && (
                                                                                <div className={`p-2 rounded ${theme === 'dark' ? 'bg-zinc-700 border border-zinc-600' : 'bg-gray-100 border border-gray-300'}`}>
                                                                                    <h6 className={`text-[10px] font-semibold mb-1 flex items-center gap-1 ${theme === 'dark' ? 'text-yellow-300' : 'text-yellow-700'}`}><Code size={10} /> 即梦 Prompt</h6>
                                                                                    <p className={`text-[10px] whitespace-pre-wrap select-text cursor-text ${theme === 'dark' ? 'text-zinc-200' : 'text-zinc-800'}`}>{scene.keyframes[0].jimeng_prompt}</p>
                                                                                    <button onClick={() => navigator.clipboard.writeText(scene.keyframes[0].jimeng_prompt)} className="mt-1 flex items-center text-[9px] text-blue-400 hover:text-blue-300" onMouseDown={(e) => e.stopPropagation()}>
                                                                                        <ClipboardCopy size={10} className="mr-1" /> 复制
                                                                                    </button>
                                                                                </div>
                                                                            )}
                                                                            
                                                                            {/* MJ Prompt */}
                                                                            {scene.keyframes?.[0]?.mj_prompt && (
                                                                                <div className={`p-2 rounded ${theme === 'dark' ? 'bg-zinc-700 border border-zinc-600' : 'bg-gray-100 border border-gray-300'}`}>
                                                                                    <h6 className={`text-[10px] font-semibold mb-1 flex items-center gap-1 ${theme === 'dark' ? 'text-green-300' : 'text-green-700'}`}><Code size={10} /> MJ Prompt</h6>
                                                                                    <p className={`text-[10px] whitespace-pre-wrap select-text cursor-text ${theme === 'dark' ? 'text-zinc-200' : 'text-zinc-800'}`}>{scene.keyframes[0].mj_prompt}</p>
                                                                                    <button onClick={() => navigator.clipboard.writeText(scene.keyframes[0].mj_prompt)} className="mt-1 flex items-center text-[9px] text-blue-400 hover:text-blue-300" onMouseDown={(e) => e.stopPropagation()}>
                                                                                        <ClipboardCopy size={10} className="mr-1" /> 复制
                                                                                    </button>
                                                                                </div>
                                                                            )}
                                                                        </div>
                                                                    </div>
                                                                ))}
                                                            </div>
                                                        </div>
                                                    )}
                                                    
                                                    {/* 结果展示区 (Manual 模式) */}
                                                    {(node.settings?.analysisMode || 'manual') === 'manual' && node.analysisResults && node.analysisResults.length > 0 ? (
                                                        <div className="space-y-3 flex-1 flex flex-col min-h-0">
                                                            <div className="text-[11px] font-medium text-zinc-700 dark:text-zinc-300 shrink-0">拆解提示词 ({node.analysisResults.length} 个场景)</div>
                                                            <div className="space-y-3 flex-1 overflow-y-auto custom-scrollbar min-h-0">
                                                                {node.analysisResults.map((result, idx) => {
                                                                    // 获取关键帧对应的图片URL（从videoInputNode的frames或selectedKeyframes中查找）
                                                                    const getFrameImageUrl = (frameTime) => {
                                                                        // 先从selectedKeyframes中查找
                                                                        const selectedFrame = videoInputNode.selectedKeyframes?.find(f => Math.abs(f.time - frameTime) < 0.1);
                                                                        if (selectedFrame) return selectedFrame.url;
                                                                        // 再从frames中查找
                                                                        const frame = videoInputNode.frames?.find(f => Math.abs(f.time - frameTime) < 0.1);
                                                                        return frame?.url || null;
                                                                    };
                                                                    
                                                                    // 获取当前场景的主要关键帧（prev/current/next）
                                                                    const currentKeyframe = result.keyframes?.find(k => k.type === 'current') || result.keyframes?.[0];
                                                                    const prevKeyframe = result.keyframes?.find(k => k.type === 'prev');
                                                                    const nextKeyframe = result.keyframes?.find(k => k.type === 'next');
                                                                    
                                                                    // 获取简短描述（使用current的描述，如果没有则使用第一个）
                                                                    const shortDescription = currentKeyframe?.description || result.keyframes?.[0]?.description || '无描述';
                                                                    
                                                                    return (
                                                                        <div
                                                                            key={idx}
                                                                            className={`p-3 rounded-lg border ${theme === 'dark' ? 'bg-zinc-800 border-zinc-700' : 'bg-white border-zinc-300'}`}
                                                                        >
                                                                            {/* 场景标题和时间区间 */}
                                                                            <div className="flex items-center justify-between mb-2">
                                                                                <div className="font-medium text-[11px] text-zinc-800 dark:text-zinc-200">
                                                                                    场景 {result.scene_index || idx + 1}
                                                                                </div>
                                                                                <div className="text-[10px] text-zinc-500">
                                                                                    {result.time_range}
                                                                                </div>
                                                                            </div>
                                                                            
                                                                            {/* 简短描述 */}
                                                                            <div className="text-[10px] text-zinc-600 dark:text-zinc-400 mb-3 line-clamp-2 select-text cursor-text">
                                                                                {shortDescription}
                                                                            </div>
                                                                            
                                                                            {/* 关键帧缩略图 */}
                                                                            <div className="grid grid-cols-3 gap-2 mb-3">
                                                                                {[prevKeyframe, currentKeyframe, nextKeyframe].map((kf, kfIdx) => {
                                                                                    if (!kf) return <div key={kfIdx} className="aspect-video bg-zinc-200 dark:bg-zinc-700 rounded"></div>;
                                                                                    const imageUrl = getFrameImageUrl(kf.time);
                                                                                    return (
                                                                                        <div key={kfIdx} className="relative aspect-video bg-black rounded overflow-hidden">
                                                                                            {imageUrl ? (
                                                                                                <img src={imageUrl} className="w-full h-full object-cover" alt={`关键帧 ${kfIdx + 1}`} />
                                                                                            ) : (
                                                                                                <div className="w-full h-full flex items-center justify-center text-[8px] text-zinc-500">
                                                                                                    {kf.type === 'prev' ? '上一帧' : kf.type === 'current' ? '当前帧' : '下一帧'}
                                                                                                </div>
                                                                                            )}
                                                                                            <div className="absolute bottom-0 left-0 right-0 bg-black/60 text-white text-[8px] px-1 py-0.5 text-center">
                                                                                                {kf.time.toFixed(1)}s
                                                                                            </div>
                                                                                        </div>
                                                                                    );
                                                                                })}
                                                                            </div>
                                                                            
                                                                            {/* 提示词列表 */}
                                                                            <div className="space-y-2">
                                                                                {result.keyframes?.map((kf, kfIdx) => (
                                                                                    <div key={kfIdx} className="space-y-1.5">
                                                                                        <div className="text-[9px] text-zinc-500">
                                                                                            {kf.type === 'prev' ? '上一帧' : kf.type === 'current' ? '当前帧' : '下一帧'} ({kf.time.toFixed(1)}s)
                                                                                        </div>
                                                                                        
                                                                                        {/* MJ 提示词 */}
                                                                                        {kf.mj_prompt && (
                                                                                            <div className={`p-2 rounded border ${theme === 'dark' ? 'bg-zinc-900 border-zinc-600' : 'bg-zinc-50 border-zinc-200'}`}>
                                                                                                <div className="flex items-start justify-between gap-2">
                                                                                                    <div className="flex-1">
                                                                                                        <div className="text-[9px] text-zinc-500 mb-1">Midjourney 提示词</div>
                                                                                                        <div className="text-[10px] text-zinc-700 dark:text-zinc-300 break-words select-text cursor-text">{kf.mj_prompt}</div>
                                                                                                    </div>
                                                                                                    <div className="flex items-center gap-1 shrink-0">
                                                                                                        <button
                                                                                                            onClick={async () => {
                                                                                                                try {
                                                                                                                    await navigator.clipboard.writeText(kf.mj_prompt);
                                                                                                                    alert('已复制到剪贴板');
                                                                                                                } catch (e) {
                                                                                                                    alert('复制失败');
                                                                                                                }
                                                                                                            }}
                                                                                                            className={`p-1 rounded hover:bg-zinc-200 dark:hover:bg-zinc-700 transition-colors ${theme === 'dark' ? 'text-zinc-400 hover:text-zinc-300' : 'text-zinc-500 hover:text-zinc-700'}`}
                                                                                                            onMouseDown={(e) => e.stopPropagation()}
                                                                                                            title="复制"
                                                                                                        >
                                                                                                            <CopyPlus size={12} />
                                                                                                        </button>
                                                                                                        <button
                                                                                                            onClick={() => {
                                                                                                                const world = screenToWorld(node.x + node.width + 100, node.y + node.height / 2);
                                                                                                                const newNodeId = `node-${Date.now()}`;
                                                                                                                
                                                                                                                // 创建图生图节点
                                                                                                                const genImageNode = {
                                                                                                                    id: newNodeId,
                                                                                                                    type: 'gen-image',
                                                                                                                    x: world.x - 180,
                                                                                                                    y: world.y - 170,
                                                                                                                    width: 360,
                                                                                                                    height: 340,
                                                                                                                    settings: { 
                                                                                                                        model: 'mj-v6',
                                                                                                                        prompt: kf.mj_prompt,
                                                                                                                        ratio: 'Auto',
                                                                                                                        resolution: 'Auto'
                                                                                                                    }
                                                                                                                };
                                                                                                                
                                                                                                                setNodes((prev) => [...prev, genImageNode]);
                                                                                                                
                                                                                                                // 创建预览节点并连接
                                                                                                                setTimeout(() => {
                                                                                                                    const previewWorld = screenToWorld(node.x + node.width + 200, node.y + node.height / 2);
                                                                                                                    const previewNodeId = `node-${Date.now() + 1}`;
                                                                                                                    const previewNode = {
                                                                                                                        id: previewNodeId,
                                                                                                                        type: 'preview',
                                                                                                                        x: previewWorld.x - 160,
                                                                                                                        y: previewWorld.y - 130,
                                                                                                                        width: 320,
                                                                                                                        height: 260
                                                                                                                    };
                                                                                                                    
                                                                                                                    setNodes((prev) => [...prev, previewNode]);
                                                                                                                    
                                                                                                                    // 连接图生图节点到预览节点
                                                                                                                    setConnections((prev) => [...prev, { 
                                                                                                                        id: `conn-${Date.now()}`, 
                                                                                                                        from: newNodeId, 
                                                                                                                        to: previewNodeId 
                                                                                                                    }]);
                                                                                                                }, 50);
                                                                                                            }}
                                                                                                            className={`p-1 rounded hover:bg-blue-100 dark:hover:bg-blue-900/30 transition-colors text-blue-600 dark:text-blue-400`}
                                                                                                            onMouseDown={(e) => e.stopPropagation()}
                                                                                                            title="生成图生图节点"
                                                                                                        >
                                                                                                            <ImagePlus size={12} />
                                                                                                        </button>
                                                                                                    </div>
                                                                                                </div>
                                                                                            </div>
                                                                                        )}
                                                                                        
                                                                                        {/* 即梦提示词 */}
                                                                                        {kf.jimeng_prompt && (
                                                                                            <div className={`p-2 rounded border ${theme === 'dark' ? 'bg-zinc-900 border-zinc-600' : 'bg-zinc-50 border-zinc-200'}`}>
                                                                                                <div className="flex items-start justify-between gap-2">
                                                                                                    <div className="flex-1">
                                                                                                        <div className="text-[9px] text-zinc-500 mb-1">即梦提示词</div>
                                                                                                        <div className="text-[10px] text-zinc-700 dark:text-zinc-300 break-words select-text cursor-text">{kf.jimeng_prompt}</div>
                                                                                                    </div>
                                                                                                    <button
                                                                                                        onClick={async () => {
                                                                                                            try {
                                                                                                                await navigator.clipboard.writeText(kf.jimeng_prompt);
                                                                                                                alert('已复制到剪贴板');
                                                                                                            } catch (e) {
                                                                                                                alert('复制失败');
                                                                                                            }
                                                                                                        }}
                                                                                                        className={`p-1 rounded hover:bg-zinc-200 dark:hover:bg-zinc-700 transition-colors ${theme === 'dark' ? 'text-zinc-400 hover:text-zinc-300' : 'text-zinc-500 hover:text-zinc-700'}`}
                                                                                                        onMouseDown={(e) => e.stopPropagation()}
                                                                                                        title="复制"
                                                                                                    >
                                                                                                        <CopyPlus size={12} />
                                                                                                    </button>
                                                                                                </div>
                                                                                            </div>
                                                                                        )}
                                                                                    </div>
                                                                                ))}
                                                                            </div>
                                                                            
                                                                            {/* 全局标签 */}
                                                                            {result.global_tags && (
                                                                                <div className="mt-2 pt-2 border-t border-zinc-300 dark:border-zinc-700">
                                                                                    <div className="text-[9px] text-zinc-500 mb-1">全局标签</div>
                                                                                    <div className="flex flex-wrap gap-1">
                                                                                        {Object.entries(result.global_tags).map(([key, values]) => (
                                                                                            Array.isArray(values) && values.map((val, valIdx) => (
                                                                                                <span key={`${key}-${valIdx}`} className="text-[8px] px-1.5 py-0.5 rounded bg-blue-100 dark:bg-blue-900/30 text-blue-700 dark:text-blue-300">
                                                                                                    {val}
                                                                                                </span>
                                                                                            ))
                                                                                        ))}
                                                                                    </div>
                                                                                </div>
                                                                            )}
                                                                        </div>
                                                                    );
                                                                })}
                                                            </div>
                                                        </div>
                                                    ) : null}
                                                </>
                                            );
                                        })()}
                                    </div>
                                </div>
                            )}

                            {node.type === 'image-compare' && (
                                <div className="w-full h-full pointer-events-auto">
                                    <ImageCompareView 
                                        img1={connectedImages[0]} 
                                        img2={connectedImages[1]} 
                                    />
                                </div>
                            )}

                            {node.type === 'preview' && (
                                <div className="flex flex-col h-full pointer-events-auto">
                                    <div
                                        className={`flex items-center justify-between px-3 py-2 border-b text-xs font-semibold ${
                                            theme === 'dark'
                                                ? 'border-zinc-800 text-zinc-200'
                                                : 'border-zinc-200 text-zinc-700'
                                        }`}
                                    >
                                        <div className="flex items-center gap-1.5">
                                            <Maximize2 size={13} className="text-blue-500" />
                                            <span>预览窗口</span>
                                        </div>
                                        <span className="text-[10px] text-zinc-500">
                                            {node.previewType === 'video' ? '视频预览' : '图片预览'}
                                        </span>
                                    </div>
                                    <div className="flex-1 flex flex-col p-2 gap-2 min-h-0">
                                        <div
                                            className={`relative flex-1 rounded-lg overflow-hidden flex items-center justify-center min-h-0 ${
                                                theme === 'dark' ? 'bg-zinc-900' : 'bg-zinc-100'
                                            }`}
                                        >
                                            {node.content || (node.previewMjImages && node.previewMjImages.length > 0) ? (
                                                isVideoUrl(node.content) || node.previewType === 'video' ? (
                                                    <video
                                                        src={node.content}
                                                        className="w-full h-full object-contain bg-black"
                                                        controls
                                                        draggable={false}
                                                    />
                                                ) : node.previewMjImages && (node.previewMjImages.length === 4 || node.previewMjImages.length > 1) ? (
                                                    // 多张图片网格显示（即梦回传的四张图）
                                                    <div className={`w-full h-full grid gap-0.5 p-0.5 ${node.previewMjImages.length === 4 ? 'grid-cols-2 grid-rows-2' : 'grid-cols-2'}`}>
                                                        {node.previewMjImages.map((imgUrl, idx) => (
                                                            <div
                                                                key={idx}
                                                                className="relative w-full h-full overflow-hidden bg-black flex items-center justify-center"
                                                            >
                                                                <img 
                                                                    src={imgUrl} 
                                                                    className="max-w-full max-h-full w-auto h-auto object-contain" 
                                                                    alt={`预览图 ${idx + 1}`}
                                                                    draggable={false}
                                                                    style={{
                                                                        imageRendering: view.zoom < 1 ? 'crisp-edges' : 'auto',
                                                                        WebkitFontSmoothing: 'antialiased',
                                                                        transform: 'translateZ(0)',
                                                                        backfaceVisibility: 'hidden'
                                                                    }}
                                                                    onError={(e) => {
                                                                        console.error(`预览图片 ${idx + 1} 加载失败`);
                                                                        e.target.style.display = 'none';
                                                                    }}
                                                                    onLoad={(e) => {
                                                                        // 图片加载后，根据实际尺寸自适应
                                                                        const img = e.target;
                                                                        const container = img.parentElement;
                                                                        if (container && img.naturalWidth && img.naturalHeight) {
                                                                            const containerWidth = container.clientWidth;
                                                                            const containerHeight = container.clientHeight;
                                                                            
                                                                            // 如果图片比容器小，保持原始尺寸；否则按比例缩放
                                                                            if (img.naturalWidth <= containerWidth && img.naturalHeight <= containerHeight) {
                                                                                img.style.width = `${img.naturalWidth}px`;
                                                                                img.style.height = `${img.naturalHeight}px`;
                                                                                img.style.maxWidth = '100%';
                                                                                img.style.maxHeight = '100%';
                                                                            } else {
                                                                                img.style.width = '';
                                                                                img.style.height = '';
                                                                                img.style.maxWidth = '100%';
                                                                                img.style.maxHeight = '100%';
                                                                            }
                                                                        }
                                                                    }}
                                                                />
                                                            </div>
                                                        ))}
                                                    </div>
                                                ) : (
                                                    <img
                                                        src={node.content}
                                                        className="max-w-full max-h-full w-auto h-auto object-contain bg-black"
                                                        draggable={false}
                                                        onLoad={(e) => {
                                                            // 图片加载后，根据实际尺寸自适应
                                                            const img = e.target;
                                                            const container = img.parentElement;
                                                            if (container && img.naturalWidth && img.naturalHeight) {
                                                                const containerWidth = container.clientWidth;
                                                                const containerHeight = container.clientHeight;
                                                                
                                                                // 如果图片比容器小，保持原始尺寸；否则按比例缩放
                                                                if (img.naturalWidth <= containerWidth && img.naturalHeight <= containerHeight) {
                                                                    img.style.width = `${img.naturalWidth}px`;
                                                                    img.style.height = `${img.naturalHeight}px`;
                                                                    img.style.maxWidth = '100%';
                                                                    img.style.maxHeight = '100%';
                                                                } else {
                                                                    img.style.width = '';
                                                                    img.style.height = '';
                                                                    img.style.maxWidth = '100%';
                                                                    img.style.maxHeight = '100%';
                                                                }
                                                            }
                                                        }}
                                                    />
                                                )
                                            ) : (
                                                <div
                                                    className={`flex flex-col items-center justify-center text-[11px] ${
                                                        theme === 'dark' ? 'text-zinc-500' : 'text-zinc-500'
                                                    }`}
                                                >
                                                    <ImageIcon className="w-6 h-6 mb-1 text-zinc-400" />
                                                    <span>连接 AI 绘图 / AI 视频 节点</span>
                                                    <span>或从历史记录发送到此处进行预览</span>
                                                </div>
                                            )}
                                        </div>
                                        <div className="flex items-center justify-between gap-2 text-[11px]">
                                            <button
                                                className={`flex-1 inline-flex items-center justify-center gap-1 px-2 py-1 rounded border ${
                                                    theme === 'dark'
                                                        ? 'border-zinc-700 text-zinc-200 hover:bg-zinc-800'
                                                        : 'border-zinc-300 text-zinc-700 hover:bg-zinc-100'
                                                }`}
                                                onMouseDown={(e) => e.stopPropagation()}
                                                onClick={async () => {
                                                    if (!node.content) return;
                                                    try {
                                                        await navigator.clipboard.writeText(node.content);
                                                    } catch {}
                                                }}
                                            >
                                                <CopyPlus size={13} />
                                                复制链接
                                            </button>
                                            <button
                                                className={`flex-1 inline-flex items-center justify-center gap-1 px-2 py-1 rounded border ${
                                                    theme === 'dark'
                                                        ? 'border-zinc-700 text-zinc-200 hover:bg-zinc-800'
                                                        : 'border-zinc-300 text-zinc-700 hover:bg-zinc-100'
                                                }`}
                                                onMouseDown={(e) => e.stopPropagation()}
                                                onClick={async () => {
                                                    if (!node.content) return;
                                                    const world = screenToWorld(node.x + node.width + 100, node.y + node.height / 2);
                                                    let dims;
                                                    if (!isVideoUrl(node.content)) {
                                                        try {
                                                            const real = await getImageDimensions(node.content);
                                                            if (real?.w && real?.h) dims = { w: real.w, h: real.h };
                                                        } catch {}
                                                    }
                                                    addNode('input-image', world.x, world.y, null, node.content, dims);
                                                }}
                                            >
                                                <ArrowRightSquare size={13} />
                                                发送到画布
                                            </button>
                                            <button
                                                className={`flex-1 inline-flex items-center justify-center gap-1 px-2 py-1 rounded border ${
                                                    theme === 'dark'
                                                        ? 'border-zinc-700 text-zinc-200 hover:bg-zinc-800'
                                                        : 'border-zinc-300 text-zinc-700 hover:bg-zinc-100'
                                                }`}
                                                onMouseDown={(e) => e.stopPropagation()}
                                                onClick={() => {
                                                    if (!node.content) return;
                                                    const newFile = {
                                                        name: node.previewType === 'video' ? 'Preview.mp4' : 'Preview.png',
                                                        type: node.previewType === 'video' ? 'video/mp4' : 'image/png',
                                                        content: node.content,
                                                        isImage: node.previewType !== 'video',
                                                        isVideo: node.previewType === 'video',
                                                        isAudio: false,
                                                        fromPreview: true
                                                    };
                                                    setChatFiles((prev) => [...prev, newFile]);
                                                    setIsChatOpen(true);
                                                }}
                                            >
                                                <MessageSquare size={13} />
                                                发送到对话
                                            </button>
                                        </div>
                                    </div>
                                </div>
                            )}

                            {(node.type === 'gen-image' || node.type === 'gen-video') && (() => {
                                // 查找当前节点对应的正在生成的历史记录
                                const activeTask = history.find(h => 
                                    h.sourceNodeId === node.id && 
                                    (h.status === 'generating' || h.status === 'completed')
                                );
                                const isGenerating = activeTask && activeTask.status === 'generating';
                                const finalDuration = activeTask?.durationMs 
                                    ? (activeTask.durationMs / 1000).toFixed(1) 
                                    : null;
                                const elapsedSeconds = nodeTimers[node.id] || 0;
                                
                                return (
                                <div className="p-3 flex flex-col h-full pointer-events-auto">
                                    {/* 计时器显示 */}
                                    {(isGenerating || finalDuration) && (
                                        <div
                                            className={`mb-2 px-2 py-1 rounded text-[10px] font-mono text-center ${
                                                theme === 'dark'
                                                    ? 'bg-blue-500/20 text-blue-400 border border-blue-500/30'
                                                    : 'bg-blue-50 text-blue-600 border border-blue-200'
                                            }`}
                                        >
                                            {isGenerating ? (
                                                <span>⏱ {elapsedSeconds.toFixed(1)}s</span>
                                            ) : (
                                                <span>✓ 完成 {finalDuration}s</span>
                                            )}
                                        </div>
                                    )}
                                    <div
                                        className={`flex items-center gap-1.5 mb-2 text-xs font-semibold shrink-0 ${
                                            theme === 'dark' ? 'text-zinc-300' : 'text-zinc-700'
                                        }`}
                                    >
                                        {node.type === 'gen-image' ? <Wand2 size={12} className="text-blue-400" /> : <Video size={12} className="text-purple-400" />}
                                        <span>{node.type === 'gen-image' ? 'AI 绘图' : 'AI 视频'}</span>
                                    </div>
                                    {connectedImages.length > 0 && (
                                        <div
                                            className={`mb-2 rounded-lg border p-2 relative group/ref ${
                                                theme === 'dark'
                                                    ? 'bg-zinc-900/50 border-purple-500/20'
                                                    : 'bg-violet-50 border-violet-200'
                                            }`}
                                        >
                                             <div className="flex justify-between items-center mb-1.5">
                                                <span
                                                    className={`text-[10px] font-medium flex items-center gap-1 ${
                                                        theme === 'dark' ? 'text-zinc-300' : 'text-zinc-700'
                                                    }`}
                                                >
                                                    <ImagePlus size={10} />
                                                    引用成功
                                                </span>
                                                <span
                                                    className={`text-[9px] font-mono ${
                                                        theme === 'dark' ? 'text-zinc-500' : 'text-zinc-500'
                                                    }`}
                                                >
                                                    {connectedImages.length}/10
                                                </span>
                                             </div>
                                             <div className="flex -space-x-2 overflow-x-auto pb-1 items-center custom-scrollbar pl-1">
                                                {connectedImages.map((imgSrc, idx) => (
                                                    <div
                                                        key={idx}
                                                        className={`relative w-8 h-8 rounded-full border-2 shrink-0 thumb-stack-item cursor-pointer overflow-hidden ${
                                                            theme === 'dark'
                                                                ? 'border-[#18181b] bg-zinc-800'
                                                                : 'border-white bg-zinc-200'
                                                        }`}
                                                        style={{ zIndex: 10 - idx }}
                                                    >
                                                        <img src={imgSrc} className="w-full h-full object-cover" />
                                                    </div>
                                                ))}
                                             </div>
                                        </div>
                                    )}
                                    <div
                                        className={`rounded-lg p-3 mb-2 border focus-within:border-blue-500/30 transition-colors flex-1 flex flex-col ${
                                            theme === 'dark'
                                                ? 'bg-zinc-950/50 border-zinc-800'
                                                : 'bg-zinc-50 border-zinc-200'
                                        }`}
                                    >
                                        <textarea
                                            className={`w-full h-full bg-transparent text-xs outline-none resize-none custom-scrollbar ${
                                                theme === 'dark'
                                                    ? 'text-zinc-300 placeholder-zinc-600'
                                                    : 'text-zinc-800 placeholder-zinc-400'
                                            }`}
                                            placeholder="输入提示词..."
                                            value={node.type === 'gen-image' ? node.settings?.prompt : node.settings?.videoPrompt}
                                            onChange={(e) => updateNodeSettings(node.id, node.type === 'gen-image' ? { prompt: e.target.value } : { videoPrompt: e.target.value })}
                                            onMouseDown={(e) => e.stopPropagation()}
                                        />
                                    </div>
                                    
                                    {/* Midjourney指令UI: oref, ow, sref */}
                                    {node.type === 'gen-image' && (() => {
                                        const currentModel = apiConfigs.find((m) => m.id === node.settings?.model);
                                        const isMidjourney = currentModel && (currentModel.id.includes('mj') || currentModel.provider.toLowerCase().includes('midjourney'));
                                        return isMidjourney;
                                    })() && (() => {
                                        const orefConnected = getConnectedImageForInput(node.id, 'oref');
                                        const srefConnected = getConnectedImageForInput(node.id, 'sref');
                                        return (
                                            <div className="flex flex-col gap-1.5 mb-2 relative" data-mj-instructions="true">
                                                {/* oref指令 */}
                                                <div className="relative flex items-center gap-1.5" data-mj-oref="true">
                                                    <div className={`input-point ${orefConnected ? 'connected' : ''} ${connectingTarget === node.id && connectingInputType === 'oref' ? 'active' : ''}`} 
                                                         title="oref输入" 
                                                         onMouseDown={(e) => { e.stopPropagation(); e.preventDefault(); setConnectingTarget(node.id); setConnectingInputType('oref'); }}
                                                         onMouseUp={(e) => handleNodeMouseUp(node.id, e, 'oref')}
                                                         data-input-type="oref"
                                                         style={{ position: 'absolute', top: '50%', left: '-0.25rem', transform: 'translateY(-50%)', width: '0.5rem', height: '0.5rem', marginRight: '0.25rem', zIndex: 20, cursor: 'crosshair' }}
                                                    />
                                                    <div className="flex items-center gap-1.5 flex-1 ml-2">
                                                        <span className={`text-[10px] font-medium ${theme === 'dark' ? 'text-zinc-400' : 'text-zinc-600'}`}>oref</span>
                                                        {orefConnected && (
                                                            <div className="w-1.5 h-1.5 rounded-full bg-green-500"></div>
                                                        )}
                                                    </div>
                                                </div>
                                                
                                                {/* ow指令 */}
                                                <div className="relative flex items-center gap-1.5">
                                                    <div className="w-0.5rem h-0.5rem mr-0.25rem ml-2"></div>
                                                    <div className="flex items-center gap-1.5 flex-1">
                                                        <span className={`text-[10px] font-medium ${theme === 'dark' ? 'text-zinc-400' : 'text-zinc-600'}`}>ow</span>
                                                        {node.settings?.mjOw && node.settings.mjOw > 0 && (
                                                            <div className="w-1.5 h-1.5 rounded-full bg-green-500"></div>
                                                        )}
                                                    </div>
                                                    <input
                                                        type="number"
                                                        min="1"
                                                        max="1000"
                                                        placeholder="1-1000"
                                                        value={node.settings?.mjOw || ''}
                                                        onChange={(e) => {
                                                            const val = parseInt(e.target.value, 10);
                                                            if (isNaN(val) || val < 1) {
                                                                updateNodeSettings(node.id, { mjOw: '' });
                                                            } else if (val > 1000) {
                                                                updateNodeSettings(node.id, { mjOw: 1000 });
                                                            } else {
                                                                updateNodeSettings(node.id, { mjOw: val });
                                                            }
                                                        }}
                                                        onMouseDown={(e) => e.stopPropagation()}
                                                        className={`flex-1 px-2 py-1 rounded text-[10px] border outline-none focus:border-blue-500/50 ${
                                                            theme === 'dark'
                                                                ? 'bg-zinc-900/50 border-zinc-700 text-zinc-300 placeholder-zinc-600'
                                                                : 'bg-white border-zinc-300 text-zinc-800 placeholder-zinc-400'
                                                        }`}
                                                    />
                                                </div>
                                                
                                                {/* sref指令 */}
                                                <div className="relative flex items-center gap-1.5" data-mj-sref="true">
                                                    <div className={`input-point ${srefConnected ? 'connected' : ''} ${connectingTarget === node.id && connectingInputType === 'sref' ? 'active' : ''}`} 
                                                         title="sref输入" 
                                                         onMouseDown={(e) => { e.stopPropagation(); e.preventDefault(); setConnectingTarget(node.id); setConnectingInputType('sref'); }}
                                                         onMouseUp={(e) => handleNodeMouseUp(node.id, e, 'sref')}
                                                         data-input-type="sref"
                                                         style={{ position: 'absolute', top: '50%', left: '-0.25rem', transform: 'translateY(-50%)', width: '0.5rem', height: '0.5rem', marginRight: '0.25rem', zIndex: 20, cursor: 'crosshair' }}
                                                    />
                                                    <div className="flex items-center gap-1.5 flex-1 ml-2">
                                                        <span className={`text-[10px] font-medium ${theme === 'dark' ? 'text-zinc-400' : 'text-zinc-600'}`}>sref</span>
                                                        {srefConnected && (
                                                            <div className="w-1.5 h-1.5 rounded-full bg-green-500"></div>
                                                        )}
                                                    </div>
                                                </div>
                                            </div>
                                        );
                                    })()}
                                    <div
                                        className={`mt-auto pt-2 flex items-center justify-between shrink-0 relative gap-2 border-t ${
                                            theme === 'dark' ? 'border-zinc-800/50' : 'border-zinc-200'
                                        }`}
                                    >
                                        <div className="relative flex-1 min-w-0">
                                            <button 
                                                title={apiConfigs.find((m) => m.id === node.settings?.model)?.provider}
                                                onClick={(e) => { e.stopPropagation(); setActiveDropdown(activeDropdown?.type === 'model' ? null : { nodeId: node.id, type: 'model' }); }} 
                                                className={`flex items-center gap-2 pl-1 pr-2 py-1 rounded text-[10px] transition-colors border w-full ${
                                                    theme === 'dark'
                                                        ? 'bg-zinc-800/50 hover:bg-zinc-800 text-zinc-300 border-zinc-700/50'
                                                        : 'bg-zinc-100 hover:bg-zinc-200 text-zinc-700 border-zinc-300'
                                                }`}
                                            >
                                                <span className={`w-2 h-2 rounded-full ${getStatusColor(node.settings?.model)}`}></span>
                                                <span className="truncate">{apiConfigs.find((m) => m.id === node.settings?.model)?.provider || 'Model'}</span>
                                            </button>
                                            {activeDropdown?.nodeId === node.id && activeDropdown.type === 'model' && (
                                                <div
                                                    className={`absolute bottom-full left-0 mb-1 w-48 rounded-lg shadow-xl p-1 z-[60] border ${
                                                        theme === 'dark'
                                                            ? 'bg-[#18181b] border-zinc-700'
                                                            : 'bg-white border-zinc-200'
                                                    }`}
                                                    onMouseDown={(e) => e.stopPropagation()}
                                                >
                                                    {apiConfigs
                                                        .filter((m) => m.type === (node.type === 'gen-image' ? 'Image' : 'Video'))
                                                        .map((m) => (
                                                            <button
                                                                key={m.id}
                                                                onClick={() => {
                                                                    const nextSettings = { model: m.id };
                                                                    if (m.id === 'grok-3') {
                                                                        nextSettings.ratio = '3:2';
                                                                        nextSettings.duration = '8s';
                                                                        nextSettings.resolution = '1080P';
                                                                    }
                                                                    updateNodeSettings(node.id, nextSettings);
                                                                    setActiveDropdown(null);
                                                                }}
                                                                className={`w-full flex items-center justify-between px-2 py-1.5 rounded text-left transition-colors ${
                                                                    theme === 'dark'
                                                                        ? 'hover:bg-zinc-800 text-zinc-300'
                                                                        : 'hover:bg-zinc-100 text-zinc-700'
                                                                }`}
                                                            >
                                                            <span className="text-xs font-medium">{m.provider}</span>
                                                            <div className={`w-1.5 h-1.5 rounded-full ${getStatusColor(m.id)}`}></div>
                                                        </button>
                                                    ))}
                                                </div>
                                            )}
                                        </div>

                                        {/* Midjourney版本选择器 */}
                                        {node.type === 'gen-image' && (() => {
                                            const currentModel = apiConfigs.find((m) => m.id === node.settings?.model);
                                            return currentModel && (currentModel.id.includes('mj') || currentModel.provider.toLowerCase().includes('midjourney'));
                                        })() && (
                                            <div className="relative flex-1 min-w-0">
                                                <button
                                                    title={MJ_VERSIONS.find(v => v.value === node.settings?.mjVersion)?.label || 'MJ V7'}
                                                    onClick={(e) => { e.stopPropagation(); setActiveDropdown(activeDropdown?.type === 'mjVersion' && activeDropdown.nodeId === node.id ? null : { nodeId: node.id, type: 'mjVersion' }); }}
                                                    className={`flex items-center gap-2 pl-1 pr-2 py-1 rounded text-[10px] transition-colors border w-full ${
                                                        theme === 'dark'
                                                            ? 'bg-zinc-800/50 hover:bg-zinc-800 text-zinc-300 border-zinc-700/50'
                                                            : 'bg-zinc-100 hover:bg-zinc-200 text-zinc-700 border-zinc-300'
                                                    }`}
                                                >
                                                    <span className="truncate">{MJ_VERSIONS.find(v => v.value === node.settings?.mjVersion)?.label || 'MJ V7'}</span>
                                                </button>
                                                {activeDropdown?.nodeId === node.id && activeDropdown.type === 'mjVersion' && (
                                                    <div
                                                        className={`absolute bottom-full left-0 mb-1 w-32 rounded-lg shadow-xl p-1 z-[60] border max-h-64 overflow-y-auto custom-scrollbar ${
                                                            theme === 'dark'
                                                                ? 'bg-[#18181b] border-zinc-700'
                                                                : 'bg-white border-zinc-200'
                                                        }`}
                                                        onMouseDown={(e) => e.stopPropagation()}
                                                    >
                                                        {MJ_VERSIONS.map((v) => (
                                                            <button
                                                                key={v.value}
                                                                onClick={() => {
                                                                    updateNodeSettings(node.id, { mjVersion: v.value });
                                                                    setActiveDropdown(null);
                                                                }}
                                                                className={`w-full flex items-center justify-between px-2 py-1.5 rounded text-left transition-colors ${
                                                                    theme === 'dark'
                                                                        ? 'hover:bg-zinc-800 text-zinc-300'
                                                                        : 'hover:bg-zinc-100 text-zinc-700'
                                                                } ${node.settings?.mjVersion === v.value ? (theme === 'dark' ? 'bg-zinc-800' : 'bg-zinc-100') : ''}`}
                                                            >
                                                                <span className="text-xs font-medium">{v.label}</span>
                                                                {node.settings?.mjVersion === v.value && (
                                                                    <svg className="w-3 h-3 text-green-500" fill="currentColor" viewBox="0 0 20 20">
                                                                        <path fillRule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clipRule="evenodd" />
                                                                    </svg>
                                                                )}
                                                            </button>
                                                        ))}
                                                    </div>
                                                )}
                                            </div>
                                        )}

                                        <div className="flex gap-1 shrink-0">
                                            <div className="relative">
                                                <button
                                                    onClick={e => { e.stopPropagation(); setActiveDropdown(activeDropdown?.type === 'ratio' && activeDropdown.nodeId === node.id ? null : { nodeId: node.id, type: 'ratio' }); }}
                                                    className={`flex items-center gap-1 px-2 py-1 rounded text-[10px] border ${
                                                        theme === 'dark'
                                                            ? 'bg-zinc-800/50 hover:bg-zinc-800 text-zinc-400 border-zinc-700/50'
                                                            : 'bg-zinc-100 hover:bg-zinc-200 text-zinc-600 border-zinc-300'
                                                    }`}
                                                >
                                                    {node.settings?.ratio || 'Auto'}
                                                </button>
                                                {activeDropdown?.nodeId === node.id && activeDropdown.type === 'ratio' && (
                                                    <div
                                                        className={`absolute bottom-full left-1/2 -translate-x-1/2 mb-1 w-20 rounded-lg shadow-xl p-1 z-[60] border ${
                                                            theme === 'dark'
                                                                ? 'bg-[#18181b] border-zinc-700'
                                                                : 'bg-white border-zinc-200'
                                                        }`}
                                                        onMouseDown={e => e.stopPropagation()}
                                                    >
                                                        {getRatiosForModel(node.settings?.model).map(r => (
                                                            <button
                                                                key={r}
                                                                onClick={() => {
                                                                    updateNodeSettings(node.id, { ratio: r });
                                                                    setActiveDropdown(null);
                                                                }}
                                                                className={`w-full text-center py-1 text-[10px] rounded ${
                                                                    theme === 'dark'
                                                                        ? 'text-zinc-300 hover:bg-zinc-800'
                                                                        : 'text-zinc-700 hover:bg-zinc-100'
                                                                }`}
                                                            >
                                                                {r}
                                                            </button>
                                                        ))}
                                                    </div>
                                                )}
                                            </div>

                                            {node.type === 'gen-video' && (
                                                <div className="relative">
                                                    <button
                                                        onClick={e => { e.stopPropagation(); setActiveDropdown(activeDropdown?.type === 'vres' && activeDropdown.nodeId === node.id ? null : { nodeId: node.id, type: 'vres' }); }}
                                                        className={`flex items-center gap-1 px-2 py-1 rounded text-[10px] border ${
                                                            theme === 'dark'
                                                                ? 'bg-zinc-800/50 hover:bg-zinc-800 text-zinc-400 border-zinc-700/50'
                                                                : 'bg-zinc-100 hover:bg-zinc-200 text-zinc-600 border-zinc-300'
                                                        }`}
                                                    >
                                                        {node.settings?.resolution || '1080P'}
                                                    </button>
                                                    {activeDropdown?.nodeId === node.id && activeDropdown.type === 'vres' && (
                                                        <div
                                                            className={`absolute bottom-full left-1/2 -translate-x-1/2 mb-1 w-24 rounded-lg shadow-xl p-1 z-[60] border ${
                                                                theme === 'dark'
                                                                    ? 'bg-[#18181b] border-zinc-700'
                                                                    : 'bg-white border-zinc-200'
                                                            }`}
                                                            onMouseDown={e => e.stopPropagation()}
                                                        >
                                                            {VIDEO_RES_OPTIONS.map(r => (
                                                                <button
                                                                    key={r}
                                                                    onClick={() => {
                                                                        updateNodeSettings(node.id, { resolution: r });
                                                                        setActiveDropdown(null);
                                                                    }}
                                                                    className={`w-full text-center py-1 text-[10px] rounded ${
                                                                        theme === 'dark'
                                                                            ? 'text-zinc-300 hover:bg-zinc-800'
                                                                            : 'text-zinc-700 hover:bg-zinc-100'
                                                                    }`}
                                                                >
                                                                    {r}
                                                                </button>
                                                            ))}
                                                        </div>
                                                    )}
                                                </div>
                                            )}

                                            {node.type === 'gen-image' && (() => {
                                                const currentModel = apiConfigs.find((m) => m.id === node.settings?.model);
                                                const isMidjourney = currentModel && (currentModel.id.includes('mj') || currentModel.provider.toLowerCase().includes('midjourney'));
                                                return !isMidjourney;
                                            })() ? (
                                                <div className="relative">
                                                    <button
                                                        onClick={e => { e.stopPropagation(); setActiveDropdown(activeDropdown?.type === 'res' && activeDropdown.nodeId === node.id ? null : { nodeId: node.id, type: 'res' }); }}
                                                        className={`flex items-center gap-1 px-2 py-1 rounded text-[10px] border ${
                                                            theme === 'dark'
                                                                ? 'bg-zinc-800/50 hover:bg-zinc-800 text-zinc-400 border-zinc-700/50'
                                                                : 'bg-zinc-100 hover:bg-zinc-200 text-zinc-600 border-zinc-300'
                                                        }`}
                                                    >
                                                        {node.settings?.resolution || 'Auto'}
                                                    </button>
                                                    {activeDropdown?.nodeId === node.id && activeDropdown.type === 'res' && (
                                                        <div
                                                            className={`absolute bottom-full right-0 mb-1 w-24 rounded-lg shadow-xl p-1 z-[60] border ${
                                                                theme === 'dark'
                                                                    ? 'bg-[#18181b] border-zinc-700'
                                                                    : 'bg-white border-zinc-200'
                                                            }`}
                                                            onMouseDown={e => e.stopPropagation()}
                                                        >
                                                            {RESOLUTIONS.map(r => (
                                                                <button
                                                                    key={r}
                                                                    onClick={() => {
                                                                        updateNodeSettings(node.id, { resolution: r });
                                                                        setActiveDropdown(null);
                                                                    }}
                                                                    className={`w-full text-center py-1 text-[10px] rounded ${
                                                                        theme === 'dark'
                                                                            ? 'text-zinc-300 hover:bg-zinc-800'
                                                                            : 'text-zinc-700 hover:bg-zinc-100'
                                                                    }`}
                                                                >
                                                                    {r}
                                                                </button>
                                                            ))}
                                                        </div>
                                                    )}
                                                </div>
                                            ) : (
                                                (() => {
                                                    const currentModel = apiConfigs.find((m) => m.id === node.settings?.model);
                                                    const isMidjourney = currentModel && (currentModel.id.includes('mj') || currentModel.provider.toLowerCase().includes('midjourney'));
                                                    return !isMidjourney ? (
                                                <div className="relative">
                                                            <button
                                                                onClick={e => { e.stopPropagation(); setActiveDropdown(activeDropdown?.type === 'duration' && activeDropdown.nodeId === node.id ? null : { nodeId: node.id, type: 'duration' }); }}
                                                                className={`flex items-center gap-1 px-2 py-1 rounded text-[10px] border ${
                                                                    theme === 'dark'
                                                                        ? 'bg-zinc-800/50 hover:bg-zinc-800 text-zinc-400 border-zinc-700/50'
                                                                        : 'bg-zinc-100 hover:bg-zinc-200 text-zinc-600 border-zinc-300'
                                                                }`}
                                                            >
                                                        {node.settings?.duration || '5s'}
                                                    </button>
                                                    {activeDropdown?.nodeId === node.id && activeDropdown.type === 'duration' && (
                                                                <div
                                                                    className={`absolute bottom-full left-1/2 -translate-x-1/2 mb-1 w-20 rounded-lg shadow-xl p-1 z-[60] border ${
                                                                        theme === 'dark'
                                                                            ? 'bg-[#18181b] border-zinc-700'
                                                                            : 'bg-white border-zinc-200'
                                                                    }`}
                                                                    onMouseDown={e => e.stopPropagation()}
                                                                >
                                                                    {(apiConfigs.find(c => c.id === node.settings?.model)?.durations || ['5s', '10s']).map(d => (
                                                                        <button
                                                                            key={d}
                                                                            onClick={() => {
                                                                                updateNodeSettings(node.id, { duration: d });
                                                                                setActiveDropdown(null);
                                                                            }}
                                                                            className={`w-full text-center py-1 text-[10px] rounded ${
                                                                                theme === 'dark'
                                                                                    ? 'text-zinc-300 hover:bg-zinc-800'
                                                                                    : 'text-zinc-700 hover:bg-zinc-100'
                                                                            }`}
                                                                        >
                                                                            {d}
                                                                        </button>
                                                                    ))}
                                                        </div>
                                                    )}
                                                </div>
                                                    ) : null;
                                                })()
                                            )}
                                        </div>
                                        <button onClick={() => startGeneration(node.type === 'gen-image' ? node.settings?.prompt || '' : node.settings?.videoPrompt || '', node.type === 'gen-image' ? 'image' : 'video', connectedImages, node.id)} className="bg-blue-600 hover:bg-blue-500 text-white p-1.5 rounded-md shadow-lg active:scale-95 transition-transform shrink-0" title="生成">
                                            <Play size={12} fill="currentColor" />
                                        </button>
                                    </div>
                                </div>
                                );
                            })()}
                        </div>
                    </div>
                );
            };

            return (
                <div
                    className={`w-full h-screen font-sans overflow-hidden select-none flex flex-col transition-colors duration-300 ${
                        theme === 'dark' ? 'bg-[#09090b] text-white' : 'bg-zinc-100 text-zinc-900'
                    }`}
                    onClick={() => { 
                        if(historyContextMenu.visible) setHistoryContextMenu(prev => ({ ...prev, visible: false }));
                        if(frameContextMenu.visible) setFrameContextMenu(prev => ({ ...prev, visible: false }));
                    }}
                >
                    {/* Top Bar */}
                    <div
                        className={`h-12 flex items-center justify-between px-4 z-50 shrink-0 border-b transition-colors duration-300 ${
                            theme === 'dark' ? 'bg-[#09090b] border-zinc-800' : 'bg-white border-zinc-200'
                        }`}
                    >
                        <div className="flex items-center gap-3">
                            <div className="w-7 h-7 bg-gradient-to-br from-blue-600 to-indigo-600 rounded-md flex items-center justify-center">
                                <Layers size={16} className="text-white" />
                            </div>
                            <span
                                className={`font-bold text-sm tracking-wide ${
                                    theme === 'dark' ? 'text-zinc-200' : 'text-zinc-800'
                                }`}
                            >
                                Tapnow Studio
                            </span>
                        </div>
                        <div className="flex items-center gap-2">
                            <button
                                onClick={handleToggleTheme}
                                className={`flex items-center gap-1 px-3 py-1.5 rounded-lg text-xs font-medium transition-colors border ${
                                    theme === 'dark'
                                        ? 'bg-zinc-900 border-zinc-700 text-zinc-200 hover:bg-zinc-800'
                                        : 'bg-zinc-100 border-zinc-300 text-zinc-700 hover:bg-zinc-200'
                                }`}
                                title="切换明暗主题"
                            >
                                {theme === 'dark' ? (
                                    <>
                                        <Sun size={14} className="text-amber-400" />
                                        <span>亮色</span>
                                    </>
                                ) : (
                                    <>
                                        <Moon size={14} className="text-blue-500" />
                                        <span>暗色</span>
                                    </>
                                )}
                            </button>
                            <Button variant="ghost" onClick={() => { setNodes([]); setConnections([]); }}>清空</Button>
                            <Button variant="secondary" icon={Settings} onClick={() => setSettingsOpen(true)}>API 设置</Button>
                        </div>
                    </div>

                    <div className={`flex-1 relative overflow-hidden flex transition-colors duration-300 ${
                        theme === 'dark' ? 'bg-[#09090b]' : 'bg-zinc-100'
                    }`}>
                        {/* Sidebar */}
                        <div
                            className={`w-14 border-r flex flex-col items-center py-3 gap-3 z-40 shrink-0 transition-colors duration-300 ${
                                theme === 'dark' ? 'bg-[#09090b] border-zinc-800' : 'bg-white border-zinc-200'
                            }`}
                        >
                            {[ { id: 'select', icon: MousePointer2 }, { id: 'history', icon: History } ].map((tool) => (
                                <button
                                    key={tool.id}
                                    onClick={() => { setActiveTool(tool.id); if (tool.id === 'history') setHistoryOpen(!historyOpen); }}
                                    className={`p-2.5 rounded-lg transition-all ${
                                        activeTool === tool.id
                                            ? theme === 'dark'
                                                ? 'bg-zinc-800 text-white'
                                                : 'bg-zinc-200 text-zinc-900'
                                            : theme === 'dark'
                                                ? 'text-zinc-500 hover:text-zinc-300'
                                                : 'text-zinc-500 hover:text-zinc-800'
                                    }`}
                                >
                                    <tool.icon size={18} />
                                </button>
                            ))}
                            <div className="flex-1"></div>
                            <button
                                onClick={() => setIsChatOpen(!isChatOpen)}
                                className={`p-2.5 rounded-lg transition-all mb-2 ${
                                    isChatOpen
                                        ? 'bg-blue-600 text-white'
                                        : theme === 'dark'
                                            ? 'text-zinc-500 hover:text-zinc-300'
                                            : 'text-zinc-500 hover:text-zinc-800'
                                }`}
                                title="AI 对话"
                            >
                                <MessageSquare size={18} />
                            </button>
                        </div>

                        {/* History Panel */}
                        {historyOpen && (
                            <div
                                className={`w-72 z-30 flex flex-col animate-in slide-in-from-left border-r transition-colors duration-300 ${
                                    theme === 'dark' ? 'bg-[#121214] border-zinc-800' : 'bg-zinc-50 border-zinc-200'
                                }`}
                            >
                                <div
                                    className={`p-3 border-b flex justify-between items-center ${
                                        theme === 'dark' ? 'border-zinc-800' : 'border-zinc-200'
                                    }`}
                                >
                                    <h3
                                        className={`font-bold text-xs ${
                                            theme === 'dark' ? 'text-zinc-300' : 'text-zinc-700'
                                        }`}
                                    >
                                        生成历史
                                    </h3>
                                    <div className="flex items-center gap-2">
                                        <button
                                            onClick={() => {
                                                setBatchModalOpen(true);
                                                setBatchSelectedIds(new Set());
                                            }}
                                            className={`p-1.5 rounded transition-colors ${
                                                theme === 'dark'
                                                    ? 'text-zinc-400 hover:text-zinc-200 hover:bg-zinc-800'
                                                    : 'text-zinc-500 hover:text-zinc-700 hover:bg-zinc-200'
                                            }`}
                                            title="批量管理"
                                        >
                                            <LayoutGrid size={14} />
                                        </button>
                                        <button onClick={() => setHistoryOpen(false)}>
                                            <X
                                                size={12}
                                                className={theme === 'dark' ? 'text-zinc-500' : 'text-zinc-400'}
                                            />
                                        </button>
                                    </div>
                                </div>
                                <div className="flex-1 overflow-y-auto custom-scrollbar p-3 space-y-3">
                                    {history.map((item) => (
                                        <div
                                            key={item.id}
                                            className={`group rounded-lg overflow-hidden border relative cursor-pointer hover:border-blue-500/50 transition-colors ${
                                                theme === 'dark' ? 'bg-zinc-900 border-zinc-800' : 'bg-white border-zinc-200'
                                            }`}
                                             onClick={() => {
                                                 if (item.url) {
                                                     // 确保传递完整的item信息，包括mjImages和selectedMjImageIndex
                                                     // 如果有多张图片，使用当前选中的索引，否则使用0
                                                     const currentIndex = item.mjImages && item.mjImages.length > 1 
                                                         ? (item.selectedMjImageIndex !== undefined ? item.selectedMjImageIndex : 0)
                                                         : 0;
                                                     setLightboxItem({
                                                         ...item,
                                                         url: item.mjImages && item.mjImages.length > 1 
                                                             ? item.mjImages[currentIndex] 
                                                             : item.url,
                                                         selectedMjImageIndex: currentIndex
                                                     });
                                                 }
                                             }}
                                             onContextMenu={(e) => handleHistoryRightClick(e, item)}>
                                            <div className={`bg-black relative ${
                                                ((item.mjImages && (item.mjImages.length === 4 || item.mjImages.length > 1)) || (item.mjNeedsSplit && item.apiConfig?.modelId?.includes('mj')))
                                                    ? (() => {
                                                        // 根据比例调整容器宽高比
                                                        const ratio = item.mjRatio || '1:1';
                                                        if (ratio === '16:9') return 'aspect-video';
                                                        if (ratio === '9:16') return 'aspect-[9/16]';
                                                        if (ratio === '4:3') return 'aspect-[4/3]';
                                                        if (ratio === '3:4') return 'aspect-[3/4]';
                                                        if (ratio === '21:9') return 'aspect-[21/9]';
                                                        return 'aspect-square'; // 默认1:1
                                                    })()
                                                    : 'aspect-video'
                                            }`}>
                                                {item.status === 'completed' ? (
                                                    // Midjourney或即梦返回多张图的情况（2x2网格显示4张，或1x2显示2张）
                                                    item.mjImages && (item.mjImages.length === 4 || item.mjImages.length > 1) ? (
                                                        <div className={`w-full h-full grid gap-0.5 p-0.5 ${item.mjImages.length === 4 ? 'grid-cols-2 grid-rows-2' : 'grid-cols-2'}`}>
                                                            {item.mjImages.map((imgUrl, idx) => {
                                                                const imgInfo = item.mjImageInfo && item.mjImageInfo[idx];
                                                                return (
                                                                    <div
                                                                        key={idx}
                                                                        onClick={(e) => {
                                                                            e.stopPropagation();
                                                                            // 更新当前选中的图片
                                                                            setHistory((prev) => prev.map((hItem) => 
                                                                                hItem.id === item.id 
                                                                                    ? { ...hItem, url: imgUrl, selectedMjImageIndex: idx } 
                                                                                    : hItem
                                                                            ));
                                                                            // 显示选中的图片，确保传递完整的item信息，并更新lightboxItem
                                                                            const updatedItem = { 
                                                                                ...item, 
                                                                                url: imgUrl,
                                                                                selectedMjImageIndex: idx
                                                                            };
                                                                            setLightboxItem(updatedItem);
                                                                        }}
                                                                        onContextMenu={(e) => handleHistoryRightClick(e, item, imgUrl, idx)}
                                                                        className={`relative w-full h-full cursor-pointer border-2 transition-all overflow-hidden ${
                                                                            item.selectedMjImageIndex === idx && lightboxItem && lightboxItem.id === item.id
                                                                                ? 'border-blue-500 scale-95'
                                                                                : 'border-transparent hover:border-blue-500/50'
                                                                        }`}
                                                                    >
                                                                        <img 
                                                                            src={imgUrl} 
                                                                            className="w-full h-full object-contain" 
                                                                            alt={`生成图 ${idx + 1}`}
                                                                            onError={(e) => {
                                                                                console.error(`图片 ${idx + 1} 加载失败`);
                                                                                e.target.style.display = 'none';
                                                                            }}
                                                                            onLoad={() => {
                                                                                // 图片加载成功，确保显示
                                                                            }}
                                                                        />
                                                                        {item.selectedMjImageIndex === idx && lightboxItem && lightboxItem.id === item.id && (
                                                                            <div className="absolute top-1 right-1 w-3 h-3 bg-blue-500 rounded-full flex items-center justify-center z-10">
                                                                                <svg className="w-2 h-2 text-white" fill="currentColor" viewBox="0 0 20 20">
                                                                                    <path fillRule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clipRule="evenodd" />
                                                                                </svg>
                                                                            </div>
                                                                        )}
                                                                    </div>
                                                                );
                                                            })}
                                                        </div>
                                                    ) : (
                                                        // 普通单张图或视频，或者Midjourney原图（等待切割）
                                                        item.type === 'image' ? (
                                                            <img 
                                                                src={item.url || item.mjOriginalUrl} 
                                                                className="w-full h-full object-cover" 
                                                                alt={item.prompt || '生成的图片'}
                                                                onError={(e) => {
                                                                    console.error('图片加载失败:', item.url || item.mjOriginalUrl);
                                                                    e.target.style.display = 'none';
                                                                }}
                                                            />
                                                        ) : (
                                                            <video 
                                                                src={item.url} 
                                                                className="w-full h-full object-cover" 
                                                                muted 
                                                                loop 
                                                                playsInline
                                                                onError={(e) => {
                                                                    console.error('视频加载失败:', item.url);
                                                                }}
                                                            />
                                                        )
                                                    )
                                                ) : (
                                                    <div className="w-full h-full flex items-center justify-center">
                                                        <Loader2 className="animate-spin text-zinc-600" />
                                                    </div>
                                                )}
                                                <div className="absolute bottom-0 left-0 right-0 h-1 bg-zinc-800">
                                                    <div className="h-full bg-blue-500 transition-all" style={{ width: `${item.progress}%` }}></div>
                                                </div>
                                            </div>
                                            <div className="p-2">
                                                <div className="flex justify-between items-start gap-2">
                                                    <p
                                                        className={`text-[10px] line-clamp-1 flex-1 ${
                                                            theme === 'dark' ? 'text-zinc-400' : 'text-zinc-600'
                                                        }`}
                                                    >
                                                        {item.prompt}
                                                    </p>
                                                    {/* Delete Button */}
                                                    <button 
                                                        onClick={(e) => { e.stopPropagation(); deleteHistoryItem(item.id); }} 
                                                        className={`shrink-0 p-0.5 mr-1 ${
                                                            theme === 'dark'
                                                                ? 'text-zinc-500 hover:text-red-500'
                                                                : 'text-zinc-400 hover:text-red-500'
                                                        }`} 
                                                        title="删除"
                                                    >
                                                        <Trash2 size={12} />
                                                    </button>
                                                    {item.type === 'video' && (item.status === 'generating' || item.status === 'failed') && (
                                                        <button onClick={(e) => { 
                                                                e.stopPropagation(); 
                                                                if (item.apiConfig) {
                                                                    setHistory(prev => prev.map(h => h.id === item.id ? { ...h, status: 'generating', errorMsg: null, progress: 5 } : h));
                                                                    if (item.modelName.includes('veo')) pollVeoJob(item.remoteTaskId, item.id, item.apiConfig.baseUrl, item.apiConfig.apiKey, item.width, item.height);
                                                                    else pollSoraJob(item.remoteTaskId, item.id, item.apiConfig.baseUrl, item.apiConfig.apiKey, item.width, item.height, item.apiConfig.modelId || '');
                                                                }
                                                            }} 
                                                            className={`shrink-0 p-0.5 ${
                                                                theme === 'dark'
                                                                    ? 'text-zinc-500 hover:text-white'
                                                                    : 'text-zinc-400 hover:text-zinc-900'
                                                            }`} 
                                                            title="刷新状态"
                                                        >
                                                            <RefreshCw size={12} />
                                                        </button>
                                                    )}
                                                </div>
                                                {item.status === 'failed' && item.errorMsg && (
                                                    <p className="text-[9px] text-red-500 mt-1 break-words whitespace-pre-wrap">
                                                        {item.errorMsg.split('\n').map((line, idx) => (
                                                            <span key={idx}>
                                                                {line}
                                                                {idx < item.errorMsg.split('\n').length - 1 && <br />}
                                                            </span>
                                                        ))}
                                                    </p>
                                                )}
                                                {item.status === 'generating' && (
                                                    <p className="text-[9px] text-blue-500 mt-1">
                                                        {item.errorMsg || '生成中...'}
                                                    </p>
                                                )}
                                            </div>
                                            <div className="flex items-center justify-between px-3 py-2 text-[11px]">
                                                <div className="flex flex-col">
                                                    <span className={theme === 'dark' ? 'text-zinc-300' : 'text-zinc-700'}>
                                                        {item.prompt?.slice(0, 40) || 'Untitled'}
                                                        {item.prompt && item.prompt.length > 40 ? '…' : ''}
                                                    </span>
                                                    <span className={theme === 'dark' ? 'text-zinc-500' : 'text-zinc-400'}>
                                                        {item.time} · {item.modelName}
                                                        {typeof item.durationMs === 'number' && item.durationMs > 0 && (
                                                            <> · 用时 {(item.durationMs / 1000).toFixed(1)}s</>
                                                        )}
                                                    </span>
                                                </div>
                                            </div>
                                        </div>
                                    ))}
                                </div>
                            </div>
                        )}

                        {/* Main Canvas Area */}
                        <div className="flex-1 relative overflow-hidden flex">
                             <div ref={canvasRef} id="canvas-bg" className="flex-1 h-full cursor-default relative"
                                onWheel={handleWheel} onMouseDown={handleMouseDown} onMouseMove={handleMouseMove} onMouseUp={handleMouseUp} onClick={handleBackgroundClick} onDoubleClick={handleDoubleClick}
                                style={{ 
                                    backgroundImage: theme === 'dark' 
                                        ? 'radial-gradient(#27272a 1px, transparent 1px)' 
                                        : 'radial-gradient(rgba(0, 0, 0, 0.08) 0.5px, transparent 0.5px)', 
                                    backgroundSize: `${20 * view.zoom}px ${20 * view.zoom}px`, 
                                    backgroundPosition: `${view.x}px ${view.y}px`,
                                    WebkitFontSmoothing: 'antialiased',
                                    MozOsxFontSmoothing: 'grayscale',
                                    textRendering: 'optimizeLegibility',
                                    transform: 'translateZ(0)',
                                    backfaceVisibility: 'hidden'
                                }}>
                                <div className="absolute origin-top-left will-change-transform" style={{ 
                                    transform: `translate3d(${view.x}px, ${view.y}px, 0) scale(${view.zoom})`, 
                                    width: VIRTUAL_CANVAS_WIDTH, 
                                    height: VIRTUAL_CANVAS_HEIGHT,
                                    WebkitFontSmoothing: 'antialiased',
                                    MozOsxFontSmoothing: 'grayscale',
                                    textRendering: 'optimizeLegibility',
                                    transformOrigin: 'top left',
                                    imageRendering: view.zoom >= 1 ? 'auto' : 'crisp-edges'
                                }}>
                                    {renderConnections()}
                                    {nodes.map((node) => renderNode(node))}
                                </div>
                                
                                {/* 框选框 */}
                                {selectionBox && (
                                    <div
                                        className="absolute border-2 border-blue-500 bg-blue-500/10 pointer-events-none z-50"
                                        style={{
                                            left: Math.min(selectionBox.startX, selectionBox.endX),
                                            top: Math.min(selectionBox.startY, selectionBox.endY),
                                            width: Math.abs(selectionBox.endX - selectionBox.startX),
                                            height: Math.abs(selectionBox.endY - selectionBox.startY),
                                        }}
                                    />
                                )}
                            </div>

                            {/* Chat Sidebar Panel */}
                            <div
                                className={`fixed right-0 top-12 bottom-0 border-l shadow-2xl flex flex-col z-50 transition-transform duration-300 ease-in-out ${
                                    theme === 'dark' ? 'bg-[#121214] border-zinc-800' : 'bg-white border-zinc-200'
                                } ${isChatOpen ? 'translate-x-0' : 'translate-x-full'}`}
                                style={{ width: chatWidth }}
                            >
                                <div
                                    className={`absolute left-0 top-0 bottom-0 w-1.5 cursor-ew-resize transition-colors z-50 flex items-center justify-center group ${
                                        theme === 'dark' ? 'hover:bg-blue-600/50' : 'hover:bg-blue-400/30'
                                    }`}
                                    onMouseDown={handleChatResizeStart}
                                >
                                    <div
                                        className={`h-8 w-1 rounded transition-colors ${
                                            theme === 'dark'
                                                ? 'bg-zinc-700 group-hover:bg-blue-500'
                                                : 'bg-zinc-300 group-hover:bg-blue-500'
                                        }`}
                                    ></div>
                                </div>
                                <div
                                    className={`h-12 flex items-center justify-between px-3 shrink-0 border-b ${
                                        theme === 'dark' ? 'border-zinc-800' : 'border-zinc-200'
                                    }`}
                                >
                                    <div className="flex items-center gap-2 overflow-hidden">
                                        <div className="relative">
                                            <select
                                                value={chatModel}
                                                onChange={(e) => setChatModel(e.target.value)}
                                                className={`text-xs border rounded pl-2 pr-6 py-1 appearance-none outline-none focus:border-blue-500 cursor-pointer max-w-[180px] truncate ${
                                                    theme === 'dark'
                                                        ? 'bg-zinc-800 text-zinc-300 border-zinc-700'
                                                        : 'bg-white text-zinc-800 border-zinc-300'
                                                }`}
                                            >
                                                {apiConfigs.filter(c => c.type === 'Chat').map(c => <option key={c.id} value={c.id}>{c.provider} ({c.modelName})</option>)}
                                            </select>
                                            <div className="absolute right-2 top-1/2 -translate-y-1/2 pointer-events-none"><div className={`w-1.5 h-1.5 rounded-full ${getStatusColor(chatModel)}`}></div></div>
                                        </div>
                                    </div>
                                    <div className="flex items-center gap-1">
                                        <button
                                            onClick={createNewChat}
                                            className={`p-1.5 rounded ${
                                                theme === 'dark'
                                                    ? 'text-zinc-400 hover:text-white hover:bg-zinc-800'
                                                    : 'text-zinc-500 hover:text-zinc-900 hover:bg-zinc-100'
                                            }`}
                                            title="新对话"
                                        >
                                            <Plus size={16} />
                                        </button>
                                        {chatSessions.length > 1 && (
                                            <div className="relative">
                                                <button
                                                    onClick={() => setChatSessionDropdownOpen(!chatSessionDropdownOpen)}
                                                    className={`p-1.5 rounded ${
                                                        theme === 'dark'
                                                        ? 'text-zinc-400 hover:text-white hover:bg-zinc-800'
                                                            : 'text-zinc-500 hover:text-zinc-900 hover:bg-zinc-100'
                                                    }`}
                                                >
                                                    <History size={16} />
                                                </button>
                                                {chatSessionDropdownOpen && (
                                                    <div
                                                        className={`absolute right-0 top-full mt-1 w-48 rounded-lg shadow-xl py-1 z-50 border ${
                                                            theme === 'dark'
                                                                ? 'bg-[#18181b] border-zinc-700'
                                                                : 'bg-white border-zinc-200'
                                                        }`}
                                                        onMouseLeave={() => setChatSessionDropdownOpen(false)}
                                                    >
                                                        {chatSessions.map(s => (
                                                            <div
                                                                key={s.id}
                                                                className={`flex items-center justify-between px-3 py-2 text-xs cursor-pointer ${
                                                                    currentChatId === s.id
                                                                        ? theme === 'dark'
                                                                            ? 'bg-zinc-800 text-white'
                                                                            : 'bg-zinc-100 text-zinc-900'
                                                                        : theme === 'dark'
                                                                            ? 'text-zinc-400 hover:bg-zinc-800/50'
                                                                            : 'text-zinc-500 hover:bg-zinc-100'
                                                                }`}
                                                                onClick={() => {
                                                                    setCurrentChatId(s.id);
                                                                    setChatSessionDropdownOpen(false);
                                                                }}
                                                            >
                                                                <span className="truncate flex-1">{s.title}</span>
                                                                <button
                                                                    onClick={(e) => {
                                                                        e.stopPropagation();
                                                                        deleteChatSession(e, s.id);
                                                                    }}
                                                                    className={`p-1 ${
                                                                        theme === 'dark'
                                                                            ? 'text-zinc-600 hover:text-red-500'
                                                                            : 'text-zinc-400 hover:text-red-500'
                                                                    }`}
                                                                >
                                                                    <X size={10} />
                                                                </button>
                                                            </div>
                                                        ))}
                                                    </div>
                                                )}
                                            </div>
                                        )}
                                        <button
                                            onClick={() => setIsChatOpen(false)}
                                            className={`p-1.5 rounded ${
                                                theme === 'dark'
                                                    ? 'text-zinc-400 hover:text-white hover:bg-zinc-800'
                                                    : 'text-zinc-500 hover:text-zinc-900 hover:bg-zinc-100'
                                            }`}
                                        >
                                            <ChevronRight size={16} />
                                        </button>
                                    </div>
                                </div>
                                <div className="flex-1 overflow-y-auto custom-scrollbar p-4 space-y-4">
                                    {currentSession?.messages.map((msg) => (
                                        <div key={msg.id || msg.timestamp || `msg-${Math.random()}`} className={`flex gap-3 ${msg.role === 'user' ? 'flex-row-reverse' : ''}`}>
                                            <div className={`w-8 h-8 rounded-full flex items-center justify-center shrink-0 ${msg.role === 'user' ? 'bg-blue-600' : 'bg-green-600'}`}>{msg.role === 'user' ? <User size={16} className="text-white" /> : <Bot size={16} className="text-white" />}</div>
                                            <div className={`flex flex-col gap-1 max-w-[85%] ${msg.role === 'user' ? 'items-end' : 'items-start'}`}>
                                                {msg.files && msg.files.length > 0 && (
                                                    <div className={`flex flex-wrap gap-2 mb-1 ${msg.role === 'user' ? 'justify-end' : 'justify-start'}`}>
                                                        {msg.files.map((f, i) => (
                                                            <div
                                                                key={i}
                                                                className={`rounded p-1 border flex items-center gap-1 ${
                                                                    theme === 'dark'
                                                                        ? 'bg-zinc-800 border-zinc-700'
                                                                        : 'bg-zinc-100 border-zinc-300'
                                                                }`}
                                                            >
                                                                {f.isImage ? (
                                                                    <img src={f.content} className="w-16 h-16 object-cover rounded" alt={f.name} />
                                                                ) : f.isVideo ? (
                                                                    <video
                                                                        src={f.content}
                                                                        controls
                                                                        className={`max-w-full rounded-lg bg-black max-h-[300px] border ${
                                                                            theme === 'dark' ? 'border-zinc-700' : 'border-zinc-300'
                                                                        }`}
                                                                        playsInline
                                                                    />
                                                                ) : f.isAudio ? (
                                                                    <div
                                                                        className={`w-12 h-12 rounded flex flex-col items-center justify-center ${
                                                                            theme === 'dark'
                                                                                ? 'bg-zinc-800 border border-zinc-700 text-zinc-400'
                                                                                : 'bg-zinc-100 border border-zinc-300 text-zinc-500'
                                                                        }`}
                                                                    >
                                                                        <FileAudio size={16} />
                                                                        <span className="text-[8px] mt-1">音频</span>
                                                                    </div>
                                                                ) : f.isPDF ? (
                                                                    <div
                                                                        className={`w-12 h-12 rounded flex flex-col items-center justify-center ${
                                                                            theme === 'dark'
                                                                                ? 'bg-zinc-800 border border-zinc-700 text-zinc-400'
                                                                                : 'bg-zinc-100 border border-zinc-300 text-zinc-500'
                                                                        }`}
                                                                    >
                                                                        <FileText size={16} />
                                                                        <span className="text-[8px] mt-1">PDF</span>
                                                                    </div>
                                                                ) : f.isDoc ? (
                                                                    <div
                                                                        className={`w-12 h-12 rounded flex flex-col items-center justify-center ${
                                                                            theme === 'dark'
                                                                                ? 'bg-zinc-800 border border-zinc-700 text-zinc-400'
                                                                                : 'bg-zinc-100 border border-zinc-300 text-zinc-500'
                                                                        }`}
                                                                    >
                                                                        <FileText size={16} />
                                                                        <span className="text-[8px] mt-1">DOC</span>
                                                                    </div>
                                                                ) : f.isExcel ? (
                                                                    <div
                                                                        className={`w-12 h-12 rounded flex flex-col items-center justify-center ${
                                                                            theme === 'dark'
                                                                                ? 'bg-zinc-800 border border-zinc-700 text-zinc-400'
                                                                                : 'bg-zinc-100 border border-zinc-300 text-zinc-500'
                                                                        }`}
                                                                    >
                                                                        <FileText size={16} />
                                                                        <span className="text-[8px] mt-1">XLS</span>
                                                                    </div>
                                                                ) : (
                                                                    <div
                                                                        className={`w-12 h-12 rounded flex flex-col items-center justify-center ${
                                                                            theme === 'dark'
                                                                                ? 'bg-zinc-800 border border-zinc-700 text-zinc-400'
                                                                                : 'bg-zinc-100 border border-zinc-300 text-zinc-500'
                                                                        }`}
                                                                    >
                                                                        <FileText size={16} />
                                                                        <span className="text-[8px] mt-1 max-w-full truncate px-1">
                                                                            {f.fileExt || f.name.split('.').pop() || '文件'}
                                                                        </span>
                                                                    </div>
                                                                )}
                                                            </div>
                                                        ))}
                                                    </div>
                                                )}
                                                {(msg.content || (msg.files && msg.files.length > 0)) && (
                                                    <div
                                                        className={`rounded-2xl px-4 py-2 text-sm select-text break-words whitespace-pre-wrap ${
                                                            msg.role === 'user'
                                                                ? theme === 'dark'
                                                                    ? 'bg-zinc-800 text-white rounded-tr-none'
                                                                    : 'bg-zinc-300 text-zinc-900 rounded-tr-none'
                                                                : theme === 'dark'
                                                                    ? 'bg-zinc-800/50 text-zinc-300 rounded-tl-none border border-zinc-800'
                                                                    : 'bg-zinc-100 text-zinc-800 rounded-tl-none border border-zinc-200'
                                                        }`}
                                                    >
                                                        {msg.isError ? (
                                                            <span className="text-red-500">{msg.content}</span>
                                                        ) : msg.content ? (
                                                            <div className="markdown-body" dangerouslySetInnerHTML={{ __html: marked.parse(msg.content) }}></div>
                                                        ) : null}
                                                    </div>
                                                )}
                                            </div>
                                        </div>
                                    ))}
                                    {isChatSending && (
                                        <div className="flex gap-3">
                                            <div className="w-8 h-8 rounded-full bg-green-600 flex items-center justify-center shrink-0">
                                                <Bot size={16} className="text-white" />
                                            </div>
                                            <div
                                                className={`rounded-2xl rounded-tl-none px-4 py-2 border flex items-center ${
                                                    theme === 'dark'
                                                        ? 'bg-zinc-800/50 border-zinc-800'
                                                        : 'bg-zinc-100 border-zinc-200'
                                                }`}
                                            >
                                                <div className="flex gap-1">
                                                    <div className="w-1.5 h-1.5 bg-zinc-500 rounded-full animate-bounce" style={{ animationDelay: '0s' }}></div>
                                                    <div className="w-1.5 h-1.5 bg-zinc-500 rounded-full animate-bounce" style={{ animationDelay: '0.2s' }}></div>
                                                    <div className="w-1.5 h-1.5 bg-zinc-500 rounded-full animate-bounce" style={{ animationDelay: '0.4s' }}></div>
                                                </div>
                                            </div>
                                        </div>
                                    )}
                                    <div ref={chatEndRef} />
                                </div>
                                <div
                                    className={`p-3 border-t ${
                                        theme === 'dark' ? 'border-zinc-800 bg-[#121214]' : 'border-zinc-200 bg-zinc-50'
                                    }`}
                                >
                                    {chatFiles.length > 0 && (
                                        <div className="flex gap-2 overflow-x-auto pb-2 mb-2 custom-scrollbar">
                                            {chatFiles.map((f, i) => (
                                                <div key={i} className="relative group shrink-0">
                                                    {f.isImage ? (
                                                        <img
                                                            src={f.content}
                                                            className={`w-12 h-12 object-cover rounded border ${
                                                                theme === 'dark' ? 'border-zinc-700' : 'border-zinc-300'
                                                            }`}
                                                            alt={f.name}
                                                        />
                                                    ) : f.isVideo ? (
                                                        <video
                                                            src={f.content}
                                                            className={`w-16 h-12 object-cover rounded border bg-black ${
                                                                theme === 'dark' ? 'border-zinc-700' : 'border-zinc-300'
                                                            }`}
                                                            muted
                                                            playsInline
                                                        />
                                                    ) : f.isAudio ? (
                                                        <div
                                                            className={`w-12 h-12 rounded flex flex-col items-center justify-center ${
                                                                theme === 'dark'
                                                                    ? 'bg-zinc-800 border border-zinc-700 text-zinc-400'
                                                                    : 'bg-zinc-100 border border-zinc-300 text-zinc-500'
                                                            }`}
                                                        >
                                                            <FileAudio size={16} />
                                                            <span className="text-[8px] mt-1">音频</span>
                                                        </div>
                                                    ) : f.isPDF ? (
                                                        <div
                                                            className={`w-12 h-12 rounded flex flex-col items-center justify-center ${
                                                                theme === 'dark'
                                                                    ? 'bg-zinc-800 border border-zinc-700 text-zinc-400'
                                                                    : 'bg-zinc-100 border border-zinc-300 text-zinc-500'
                                                            }`}
                                                        >
                                                            <FileText size={16} />
                                                            <span className="text-[8px] mt-1">PDF</span>
                                                        </div>
                                                    ) : f.isDoc ? (
                                                        <div
                                                            className={`w-12 h-12 rounded flex flex-col items-center justify-center ${
                                                                theme === 'dark'
                                                                    ? 'bg-zinc-800 border border-zinc-700 text-zinc-400'
                                                                    : 'bg-zinc-100 border border-zinc-300 text-zinc-500'
                                                            }`}
                                                        >
                                                            <FileText size={16} />
                                                            <span className="text-[8px] mt-1">DOC</span>
                                                        </div>
                                                    ) : f.isExcel ? (
                                                        <div
                                                            className={`w-12 h-12 rounded flex flex-col items-center justify-center ${
                                                                theme === 'dark'
                                                                    ? 'bg-zinc-800 border border-zinc-700 text-zinc-400'
                                                                    : 'bg-zinc-100 border border-zinc-300 text-zinc-500'
                                                            }`}
                                                        >
                                                            <FileText size={16} />
                                                            <span className="text-[8px] mt-1">XLS</span>
                                                        </div>
                                                    ) : (
                                                        <div
                                                            className={`w-12 h-12 rounded flex flex-col items-center justify-center ${
                                                                theme === 'dark'
                                                                    ? 'bg-zinc-800 border border-zinc-700 text-zinc-400'
                                                                    : 'bg-zinc-100 border border-zinc-300 text-zinc-500'
                                                            }`}
                                                        >
                                                            <FileText size={16} />
                                                            <span className="text-[8px] mt-1 max-w-full truncate px-1">
                                                                {f.fileExt || f.name.split('.').pop() || '文件'}
                                                            </span>
                                                        </div>
                                                    )}
                                                    <button
                                                        onClick={() => removeChatFile(i)}
                                                        className={`absolute -top-1 -right-1 rounded-full p-0.5 border opacity-0 group-hover:opacity-100 transition-opacity ${
                                                            theme === 'dark'
                                                                ? 'bg-zinc-900 text-zinc-400 hover:text-white border-zinc-700'
                                                                : 'bg-white text-zinc-500 hover:text-zinc-900 border-zinc-300'
                                                        }`}
                                                    >
                                                        <X size={10} />
                                                    </button>
                                                </div>
                                            ))}
                                        </div>
                                    )}
                                    <div
                                        className={`relative rounded-xl flex items-end p-2 focus-within:border-blue-500/50 transition-colors border ${
                                            theme === 'dark'
                                                ? 'bg-zinc-800/50 border-zinc-700'
                                                : 'bg-white border-zinc-300'
                                        }`}
                                    >
                                        <label
                                            className={`p-2 cursor-pointer transition-colors ${
                                                theme === 'dark'
                                                    ? 'text-zinc-400 hover:text-white'
                                                    : 'text-zinc-500 hover:text-zinc-900'
                                            }`}
                                            title="上传文件"
                                        >
                                            <Paperclip size={18} />
                                            <input type="file" multiple className="hidden" onChange={handleChatFileUpload} accept="image/*,video/*,audio/*,.pdf,.doc,.docx,.xls,.xlsx,.ppt,.pptx,.txt,.md,.js,.py,.html,.css,.json,.csv" />
                                        </label>
                                        <textarea
                                            value={chatInput}
                                            onChange={(e) => setChatInput(e.target.value)}
                                            onKeyDown={(e) => { if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); sendChatMessage(); } }}
                                            placeholder="发送消息..."
                                            className={`w-full bg-transparent text-sm resize-none outline-none max-h-32 py-2 px-1 custom-scrollbar ${
                                                theme === 'dark'
                                                    ? 'text-white placeholder-zinc-500'
                                                    : 'text-zinc-800 placeholder-zinc-400'
                                            }`}
                                            rows={1}
                                            style={{ minHeight: '36px' }}
                                        />
                                        <button
                                            onClick={sendChatMessage}
                                            disabled={(!chatInput.trim() && chatFiles.length === 0) || isChatSending}
                                            className={`p-2 rounded-lg transition-all mb-0.5 ${
                                                (!chatInput.trim() && chatFiles.length === 0) || isChatSending
                                                    ? 'opacity-50 bg-transparent text-zinc-400'
                                                    : 'bg-blue-600 text-white hover:bg-blue-500'
                                            }`}
                                        >
                                            <Send size={16} />
                                        </button>
                                    </div>
                                    <div className={`text-[10px] text-center mt-2 ${theme === 'dark' ? 'text-zinc-600' : 'text-zinc-500'}`}>
                                        支持 MP4/MP3/PDF/Doc/Excel/Code 等格式 • Enter 发送
                                    </div>
                                </div>
                            </div>

                            {contextMenu.visible && (
                                <div
                                    className={`fixed z-50 w-40 rounded-lg shadow-xl border ${
                                        theme === 'dark' ? 'bg-[#18181b] border-zinc-800' : 'bg-white border-zinc-200'
                                    }`}
                                    style={{ left: contextMenu.x, top: contextMenu.y, transform: 'translate(-50%, -50%)' }}
                                    onMouseLeave={() => setContextMenu(prev => ({ ...prev, visible: false }))}
                                >
                                    <div className="p-1">
                                        {[
                                            { type: 'input-image', label: '图片输入' },
                                            { type: 'video-input', label: '视频输入' },
                                            { type: 'video-analyze', label: '视频拆解 / 提示词反推' },
                                            { type: 'gen-image', label: 'AI 绘图' },
                                            { type: 'gen-video', label: 'AI 视频' },
                                            { type: 'image-compare', label: '图像对比' },
                                            { type: 'preview', label: '预览窗口' },
                                        ].map(item => (
                                            <button
                                                key={item.type}
                                                className={`w-full text-left px-3 py-2 text-xs rounded transition-colors ${
                                                    theme === 'dark'
                                                        ? 'text-zinc-300 hover:bg-zinc-800'
                                                        : 'text-zinc-700 hover:bg-zinc-100'
                                                }`}
                                                onClick={() => addNode(item.type, contextMenu.worldX, contextMenu.worldY, contextMenu.sourceNodeId, undefined, undefined, contextMenu.targetNodeId, contextMenu.inputType)}
                                            >
                                                {item.label}
                                            </button>
                                        ))}
                                    </div>
                                </div>
                            )}

                            {historyContextMenu.visible && (
                                <div
                                    className={`fixed z-[100] w-48 rounded-lg shadow-2xl py-1 animate-in fade-in duration-100 border ${
                                        theme === 'dark' ? 'bg-[#18181b] border-zinc-700' : 'bg-white border-zinc-200'
                                    }`}
                                    style={{ left: historyContextMenu.x, top: historyContextMenu.y }}
                                >
                                    <div
                                        className={`px-3 py-1.5 text-[10px] font-medium border-b mb-1 ${
                                            theme === 'dark' ? 'text-zinc-500 border-zinc-800' : 'text-zinc-500 border-zinc-200'
                                        }`}
                                    >
                                        操作
                                    </div>
                                    <button
                                        className={`w-full text-left px-3 py-2 text-xs flex items-center gap-2 transition-colors ${
                                            theme === 'dark'
                                                ? 'text-zinc-300 hover:bg-zinc-800'
                                                : 'text-zinc-700 hover:bg-zinc-100'
                                        }`}
                                        onClick={sendHistoryToChat}
                                    >
                                        <MessageSquare size={14} className="text-purple-500" /> 发送到当前对话
                                    </button>
                                    <button
                                        className={`w-full text-left px-3 py-2 text-xs flex items-center gap-2 transition-colors ${
                                            theme === 'dark'
                                                ? 'text-zinc-300 hover:bg-zinc-800'
                                                : 'text-zinc-700 hover:bg-zinc-100'
                                        }`}
                                        onClick={sendHistoryToCanvas}
                                    >
                                        <CopyPlus size={14} className="text-blue-500" /> 发送到画布
                                    </button>
                                    <button
                                        className={`w-full text-left px-3 py-2 text-xs flex items-center gap-2 transition-colors ${
                                            theme === 'dark'
                                                ? 'text-zinc-300 hover:bg-zinc-800'
                                                : 'text-zinc-700 hover:bg-zinc-100'
                                        }`}
                                        onClick={() => {
                                            const item = historyContextMenu.item;
                                            if (!item?.url) return;
                                            // 找到所有预览节点，默认更新最近创建的一个
                                            setNodes(prev => {
                                                const previews = prev.filter(n => n.type === 'preview');
                                                if (!previews.length) return prev;
                                                const targetId = previews[previews.length - 1].id;
                                                return prev.map(n => 
                                                    n.id === targetId
                                                        ? { ...n, content: item.url, previewType: item.type === 'video' ? 'video' : 'image' }
                                                        : n
                                                );
                                            });
                                            setHistoryContextMenu({ visible: false, x: 0, y: 0, item: null });
                                        }}
                                    >
                                        <Maximize2 size={14} className="text-emerald-500" /> 发送到预览窗口
                                    </button>
                                    {/* 拓展图片功能已移除 */}
                                    <button
                                        className={`w-full text-left px-3 py-2 text-xs flex items-center gap-2 transition-colors ${
                                            theme === 'dark'
                                                ? 'text-zinc-300 hover:bg-zinc-800'
                                                : 'text-zinc-700 hover:bg-zinc-100'
                                        }`}
                                        onClick={applyHistoryToSelectedNode}
                                    >
                                        <ArrowRightSquare size={14} className={selectedNodeId ? 'text-green-500' : 'text-zinc-400'} /> 应用到选中节点
                                    </button>
                                </div>
                            )}

                            {frameContextMenu.visible && (
                                <div
                                    className={`fixed z-[110] w-48 rounded-lg shadow-2xl py-1 animate-in fade-in duration-100 border ${
                                        theme === 'dark' ? 'bg-[#18181b] border-zinc-700' : 'bg-white border-zinc-200'
                                    }`}
                                    style={{ left: frameContextMenu.x, top: frameContextMenu.y }}
                                >
                                    <div
                                        className={`px-3 py-1.5 text-[10px] font-medium border-b mb-1 ${
                                            theme === 'dark' ? 'text-zinc-500 border-zinc-800' : 'text-zinc-500 border-zinc-200'
                                        }`}
                                    >
                                        操作
                                    </div>
                                    <button
                                        className={`w-full text-left px-3 py-2 text-xs flex items-center gap-2 transition-colors ${
                                            theme === 'dark'
                                                ? 'text-zinc-300 hover:bg-zinc-800'
                                                : 'text-zinc-700 hover:bg-zinc-100'
                                        }`}
                                        onClick={sendFrameToChat}
                                    >
                                        <MessageSquare size={14} className="text-purple-500" /> 发送到当前对话
                                    </button>
                                    <button
                                        className={`w-full text-left px-3 py-2 text-xs flex items-center gap-2 transition-colors ${
                                            theme === 'dark'
                                                ? 'text-zinc-300 hover:bg-zinc-800'
                                                : 'text-zinc-700 hover:bg-zinc-100'
                                        }`}
                                        onClick={sendFrameToCanvas}
                                    >
                                        <CopyPlus size={14} className="text-blue-500" /> 发送到画布
                                    </button>
                                    <button
                                        className={`w-full text-left px-3 py-2 text-xs flex items-center gap-2 transition-colors ${
                                            theme === 'dark'
                                                ? 'text-zinc-300 hover:bg-zinc-800'
                                                : 'text-zinc-700 hover:bg-zinc-100'
                                        }`}
                                        onClick={sendFrameToPreview}
                                    >
                                        <Maximize2 size={14} className="text-emerald-500" /> 发送到预览窗口
                                    </button>
                                    <button
                                        className={`w-full text-left px-3 py-2 text-xs flex items-center gap-2 transition-colors ${
                                            theme === 'dark'
                                                ? 'text-zinc-300 hover:bg-zinc-800'
                                                : 'text-zinc-700 hover:bg-zinc-100'
                                        }`}
                                        onClick={applyFrameToSelectedNode}
                                    >
                                        <ArrowRightSquare size={14} className={selectedNodeId ? 'text-green-500' : 'text-zinc-400'} /> 应用到选中节点
                                    </button>
                                </div>
                            )}

                            <Lightbox 
                                item={lightboxItem} 
                                onClose={() => setLightboxItem(null)}
                                onNavigate={(newIndex) => {
                                    if (lightboxItem && lightboxItem.mjImages && lightboxItem.mjImages.length > newIndex && newIndex >= 0) {
                                        // 确保newIndex在有效范围内
                                        const validIndex = Math.max(0, Math.min(newIndex, lightboxItem.mjImages.length - 1));
                                        // 更新历史记录中的selectedMjImageIndex（只更新当前lightboxItem对应的历史项）
                                        setHistory((prev) => prev.map((hItem) => 
                                            hItem.id === lightboxItem.id 
                                                ? { ...hItem, url: lightboxItem.mjImages[validIndex], selectedMjImageIndex: validIndex } 
                                                : hItem
                                        ));
                                        // 更新lightboxItem显示
                                        setLightboxItem({ 
                                            ...lightboxItem, 
                                            url: lightboxItem.mjImages[validIndex],
                                            selectedMjImageIndex: validIndex
                                        });
                                    }
                                }}
                            />

                            <Modal isOpen={settingsOpen} onClose={() => setSettingsOpen(false)} title="模型接口配置" theme={theme}>
                                <div className="p-4 space-y-3">
                                    <div className="mb-2">
                                        <label className={`text-[10px] font-medium uppercase tracking-wider ${theme === 'dark' ? 'text-zinc-500' : 'text-zinc-600'}`}>Global API Key（可选，全局默认 Key）</label>
                                        <div className="mt-1 flex gap-2">
                                            <input
                                                type="password"
                                                value={globalApiKey}
                                                onChange={(e) => setGlobalApiKey(e.target.value)}
                                                className={`flex-1 rounded px-2 py-1 text-xs outline-none focus:border-blue-600/50 border ${
                                                    theme === 'dark'
                                                        ? 'bg-zinc-900 border-zinc-800 text-zinc-300'
                                                        : 'bg-white border-zinc-300 text-zinc-900'
                                                }`}
                                                placeholder="如果不想每个模型单独填 Key，可以在这里填一个全局 Key"
                                            />
                                    </div>
                                    </div>
                                    <div className="mb-2">
                                        <div className="flex items-center justify-between">
                                            <div className="flex-1">
                                                <label className={`text-[10px] font-medium uppercase tracking-wider ${theme === 'dark' ? 'text-zinc-500' : 'text-zinc-600'}`}>
                                                    即梦图生图使用本地文件
                                                </label>
                                                <p className={`text-[10px] mt-0.5 ${theme === 'dark' ? 'text-zinc-600' : 'text-zinc-500'}`}>
                                                    启用后，即梦模型的图生图功能将强制使用本地文件（FormData），URL图片会自动下载转换为本地文件
                                                </p>
                                            </div>
                                            <label className="relative inline-flex items-center cursor-pointer ml-3">
                                                <input
                                                    type="checkbox"
                                                    checked={jimengUseLocalFile}
                                                    onChange={(e) => {
                                                        const newValue = e.target.checked;
                                                        setJimengUseLocalFile(newValue);
                                                        localStorage.setItem('tapnow_jimeng_use_local_file', String(newValue));
                                                    }}
                                                    className="sr-only peer"
                                                />
                                                <div className={`w-11 h-6 rounded-full peer peer-focus:outline-none peer-focus:ring-2 peer-focus:ring-blue-500/50 ${
                                                    jimengUseLocalFile
                                                        ? 'bg-blue-600'
                                                        : theme === 'dark'
                                                            ? 'bg-zinc-700'
                                                            : 'bg-zinc-300'
                                                } peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:rounded-full after:h-5 after:w-5 after:transition-all`}></div>
                                            </label>
                                        </div>
                                    </div>
                                    <div className="flex justify-between items-center mb-2">
                                        <span className={`text-xs ${theme === 'dark' ? 'text-zinc-400' : 'text-zinc-500'}`}>管理您的第三方模型接口。</span>
                                        <Button className="h-7 text-xs px-3 bg-blue-600 hover:bg-blue-500" onClick={addNewModel}><Plus size={14} className="mr-1" /> 添加模型</Button>
                                    </div>
                                    <div className="space-y-3 max-h-[50vh] overflow-y-auto custom-scrollbar pr-1">
                                        {apiConfigs.map((api) => (
                                            <div
                                                key={api.id}
                                                className={`p-3 rounded-lg border relative group ${
                                                    theme === 'dark' ? 'bg-[#18181b] border-zinc-800' : 'bg-zinc-50 border-zinc-200'
                                                }`}
                                            >
                                                {api.isCustom && (
                                                    <button
                                                        onClick={() => deleteApiConfig(api.id)}
                                                        className={`absolute top-2 right-2 opacity-0 group-hover:opacity-100 transition-opacity ${
                                                            theme === 'dark'
                                                                ? 'text-zinc-600 hover:text-red-500'
                                                                : 'text-zinc-400 hover:text-red-500'
                                                        }`}
                                                    >
                                                        <Trash2 size={12} />
                                                    </button>
                                                )}
                                                <div className="flex items-center gap-2 mb-3">
                                                    <div className={`w-1.5 h-1.5 rounded-full ${getStatusColor(api.id)}`}></div>
                                                    <span className={`text-sm font-bold ${theme === 'dark' ? 'text-white' : 'text-zinc-900'}`}>{api.provider}</span>
                                                    <span
                                                        className={`text-[9px] font-mono px-1.5 py-0.5 rounded ml-auto border ${
                                                            theme === 'dark'
                                                                ? 'bg-zinc-900 text-zinc-500 border-zinc-800'
                                                                : 'bg-white text-zinc-500 border-zinc-200'
                                                        }`}
                                                    >
                                                        {api.type}
                                                    </span>
                                                </div>
                                                <div className="space-y-2 pl-1">
                                                    {[
                                                        { key: 'modelName', label: 'Model ID', type: 'text', placeholder: 'model-id' },
                                                        { 
                                                            key: 'key', 
                                                            label: (api.id.includes('jimeng') || api.provider?.includes('Jimeng')) ? 'Session ID' : 'API Key', 
                                                            type: 'password', 
                                                            placeholder: (api.id.includes('jimeng') || api.provider?.includes('Jimeng')) ? '粘贴Session ID...' : 'sk-...' 
                                                        },
                                                        { key: 'url', label: 'Base URL', type: 'text', placeholder: 'https://...' },
                                                    ].map((field) => (
                                                        <div key={field.key} className="grid grid-cols-4 items-center gap-2">
                                                            <label className={`text-[10px] font-medium uppercase tracking-wider text-right ${theme === 'dark' ? 'text-zinc-500' : 'text-zinc-600'}`}>
                                                                {field.label}
                                                            </label>
                                                            <input
                                                                type={field.type}
                                                                value={api[field.key]}
                                                                onChange={(e) => {
                                                                    const newValue = e.target.value;
                                                                    updateApiConfig(api.id, { [field.key]: newValue });
                                                                    
                                                                    // 如果是jimeng模型的Session ID字段，首次粘贴后自动保存到localStorage
                                                                    if (field.key === 'key' && (api.id.includes('jimeng') || api.provider?.includes('Jimeng')) && newValue && newValue.trim().length > 0) {
                                                                        const savedSessionId = localStorage.getItem('tapnow_jimeng_session_id');
                                                                        // 如果localStorage中没有保存的Session ID，或者当前值不同，则保存
                                                                        if (!savedSessionId || savedSessionId !== newValue.trim()) {
                                                                            localStorage.setItem('tapnow_jimeng_session_id', newValue.trim());
                                                                            // 同时更新所有jimeng模型的Session ID
                                                                            setApiConfigs((prev) => prev.map((c) => 
                                                                                (c.id.includes('jimeng') || c.provider?.includes('Jimeng')) && c.key !== newValue.trim()
                                                                                    ? { ...c, key: newValue.trim() }
                                                                                    : c
                                                                            ));
                                                                        }
                                                                    }
                                                                }}
                                                                className={`col-span-3 w-full rounded px-2 py-1 text-xs outline-none focus:border-blue-600/50 border ${
                                                                    theme === 'dark'
                                                                        ? 'bg-zinc-900 border-zinc-800 text-zinc-300'
                                                                        : 'bg-white border-zinc-300 text-zinc-900'
                                                                }`}
                                                                placeholder={field.placeholder}
                                                            />
                                                </div>
                                                    ))}
                                                </div>
                                                <div className={`mt-3 pt-2 border-t flex justify-end ${theme === 'dark' ? 'border-zinc-800/50' : 'border-zinc-200'}`}>
                                                    <button
                                                        onClick={() => testApiConnection(api.id)}
                                                        disabled={apiTesting === api.id}
                                                        className={`flex items-center gap-1.5 px-2 py-1 rounded text-[10px] font-medium transition-all ${
                                                            apiStatus[api.id] === 'success'
                                                                ? 'bg-green-500/10 text-green-500'
                                                                : theme === 'dark'
                                                                    ? 'bg-zinc-800 text-zinc-400 hover:text-white hover:bg-zinc-700'
                                                                    : 'bg-zinc-100 text-zinc-600 hover:text-zinc-900 hover:bg-zinc-200'
                                                        }`}
                                                    >
                                                        {apiTesting === api.id ? (
                                                            <>
                                                                <Loader2 size={10} className="animate-spin" /> 测试中...
                                                            </>
                                                        ) : apiStatus[api.id] === 'success' ? (
                                                            <>
                                                                <CheckCircle2 size={10} /> 正常
                                                            </>
                                                        ) : (
                                                            <>
                                                                <LinkIcon size={10} /> 测试连接
                                                            </>
                                                        )}
                                                    </button>
                                                </div>
                                            </div>
                                        ))}
                                    </div>
                                    <div className={`pt-2 flex justify-end gap-2 border-t mt-3 ${theme === 'dark' ? 'border-zinc-800' : 'border-zinc-200'}`}>
                                        <Button variant="secondary" onClick={() => setSettingsOpen(false)}>关闭</Button>
                                    </div>
                                </div>
                            </Modal>
                        </div>

                        {/* 批量素材管理模态框 */}
                        {batchModalOpen && (
                            <div className="fixed inset-0 z-50 flex items-center justify-center">
                                <div 
                                    className="absolute inset-0 bg-black/50 backdrop-blur-sm"
                                    onClick={() => {
                                        setBatchModalOpen(false);
                                        setBatchSelectedIds(new Set());
                                    }}
                                />
                                <div className={`relative w-[90vw] h-[85vh] max-w-7xl rounded-lg shadow-2xl flex flex-col ${
                                    theme === 'dark' ? 'bg-[#121214] border border-zinc-800' : 'bg-white border border-zinc-200'
                                }`}>
                                    {/* 顶部栏 */}
                                    <div className={`p-4 border-b flex items-center justify-between ${
                                        theme === 'dark' ? 'border-zinc-800' : 'border-zinc-200'
                                    }`}>
                                        <div className="flex items-center gap-4">
                                            <h2 className={`text-lg font-bold ${
                                                theme === 'dark' ? 'text-zinc-100' : 'text-zinc-900'
                                            }`}>
                                                批量素材管理
                                            </h2>
                                            <span className={`text-sm ${
                                                theme === 'dark' ? 'text-zinc-400' : 'text-zinc-600'
                                            }`}>
                                                已选中 {batchSelectedIds.size} 项
                                            </span>
                                        </div>
                                        <div className="flex items-center gap-2">
                                            <button
                                                onClick={() => {
                                                    if (batchSelectedIds.size === history.length) {
                                                        setBatchSelectedIds(new Set());
                                                    } else {
                                                        setBatchSelectedIds(new Set(history.map(item => item.id)));
                                                    }
                                                }}
                                                className={`px-3 py-1.5 text-xs rounded transition-colors ${
                                                    theme === 'dark'
                                                        ? 'bg-zinc-800 text-zinc-300 hover:bg-zinc-700'
                                                        : 'bg-zinc-100 text-zinc-700 hover:bg-zinc-200'
                                                }`}
                                            >
                                                {batchSelectedIds.size === history.length ? '取消全选' : '全选'}
                                            </button>
                                            <button
                                                onClick={() => {
                                                    if (batchSelectedIds.size === 0) return;
                                                    if (confirm(`确定要删除选中的 ${batchSelectedIds.size} 项吗？`)) {
                                                        setHistory(prev => {
                                                            const filtered = prev.filter(item => !batchSelectedIds.has(item.id));
                                                            // 立即保存到 localStorage，不等待防抖
                                                            try {
                                                                localStorage.setItem('tapnow_history', JSON.stringify(filtered));
                                                            } catch (e) {
                                                                console.error('立即保存历史记录失败:', e);
                                                            }
                                                            return filtered;
                                                        });
                                                        setBatchSelectedIds(new Set());
                                                    }
                                                }}
                                                disabled={batchSelectedIds.size === 0}
                                                className={`px-3 py-1.5 text-xs rounded transition-colors flex items-center gap-1.5 ${
                                                    batchSelectedIds.size === 0
                                                        ? theme === 'dark'
                                                            ? 'bg-zinc-800/50 text-zinc-600 cursor-not-allowed'
                                                            : 'bg-zinc-100 text-zinc-400 cursor-not-allowed'
                                                        : 'bg-red-600 text-white hover:bg-red-700'
                                                }`}
                                            >
                                                <Trash2 size={14} />
                                                批量删除
                                            </button>
                                            <button
                                                onClick={async () => {
                                                    if (batchSelectedIds.size === 0) return;
                                                    const selectedItems = history.filter(item => batchSelectedIds.has(item.id) && item.url);
                                                    if (selectedItems.length === 0) {
                                                        alert('选中的项目中没有有效的素材');
                                                        return;
                                                    }
                                                    
                                                    // 获取画布中心坐标
                                                    const world = screenToWorld(window.innerWidth / 2, window.innerHeight / 2);
                                                    
                                                    // 计算起始位置（稍微偏移，避免重叠）
                                                    const startX = world.x;
                                                    const startY = world.y;
                                                    
                                                    // 批量添加到画布
                                                    selectedItems.forEach((item, index) => {
                                                        const offsetX = (index % 5) * 20; // 每行5个，横向偏移
                                                        const offsetY = Math.floor(index / 5) * 20; // 纵向偏移
                                                        
                                                        let content = item.url;
                                                        if (item.type === 'video' && !isVideoUrl(content)) {
                                                            content += (content.includes('?') ? '&' : '?') + 'force_video_display=true';
                                                        }
                                                        
                                                        // 根据类型添加节点
                                                        if (item.type === 'image') {
                                                            // 尝试获取图片尺寸
                                                            (async () => {
                                                                try {
                                                                    const dims = await getImageDimensions(content);
                                                                    addNode('input-image', startX + offsetX, startY + offsetY, null, content, dims);
                                                                } catch (e) {
                                                                    addNode('input-image', startX + offsetX, startY + offsetY, null, content);
                                                                }
                                                            })();
                                                        } else if (item.type === 'video') {
                                                            addNode('video-input', startX + offsetX, startY + offsetY, null, content);
                                                        }
                                                    });
                                                    
                                                    setBatchModalOpen(false);
                                                    setBatchSelectedIds(new Set());
                                                }}
                                                disabled={batchSelectedIds.size === 0}
                                                className={`px-3 py-1.5 text-xs rounded transition-colors flex items-center gap-1.5 ${
                                                    batchSelectedIds.size === 0
                                                        ? theme === 'dark'
                                                            ? 'bg-zinc-800/50 text-zinc-600 cursor-not-allowed'
                                                            : 'bg-zinc-100 text-zinc-400 cursor-not-allowed'
                                                        : 'bg-blue-600 text-white hover:bg-blue-700'
                                                }`}
                                            >
                                                <ArrowRightSquare size={14} />
                                                发送到画布
                                            </button>
                                            <button
                                                onClick={() => {
                                                    setBatchModalOpen(false);
                                                    setBatchSelectedIds(new Set());
                                                }}
                                                className={`p-1.5 rounded transition-colors ${
                                                    theme === 'dark'
                                                        ? 'text-zinc-400 hover:text-zinc-200 hover:bg-zinc-800'
                                                        : 'text-zinc-500 hover:text-zinc-700 hover:bg-zinc-200'
                                                }`}
                                            >
                                                <X size={18} />
                                            </button>
                                        </div>
                                    </div>
                                    
                                    {/* 内容区 - 网格布局 */}
                                    <div className="flex-1 overflow-y-auto custom-scrollbar p-4">
                                        <div className="grid grid-cols-4 gap-4">
                                            {history.map((item) => {
                                                const isSelected = batchSelectedIds.has(item.id);
                                                const displayUrl = item.mjImages && item.mjImages.length > 1 
                                                    ? (item.mjImages[item.selectedMjImageIndex || 0] || item.mjImages[0])
                                                    : item.url;
                                                
                                                return (
                                                    <div
                                                        key={item.id}
                                                        onClick={() => {
                                                            const newSet = new Set(batchSelectedIds);
                                                            if (isSelected) {
                                                                newSet.delete(item.id);
                                                            } else {
                                                                newSet.add(item.id);
                                                            }
                                                            setBatchSelectedIds(newSet);
                                                        }}
                                                        onDoubleClick={(e) => {
                                                            e.stopPropagation();
                                                            // 准备要显示的item，确保包含正确的url和selectedMjImageIndex
                                                            const displayItem = {
                                                                ...item,
                                                                url: displayUrl,
                                                                selectedMjImageIndex: item.mjImages && item.mjImages.length > 1 
                                                                    ? (item.selectedMjImageIndex || 0)
                                                                    : undefined
                                                            };
                                                            setLightboxItem(displayItem);
                                                        }}
                                                        className={`relative rounded-lg overflow-hidden border-2 cursor-pointer transition-all ${
                                                            isSelected
                                                                ? 'border-blue-500 shadow-lg shadow-blue-500/20'
                                                                : theme === 'dark'
                                                                    ? 'border-zinc-800 hover:border-zinc-700'
                                                                    : 'border-zinc-200 hover:border-zinc-300'
                                                        }`}
                                                    >
                                                        {/* 选中标记和查看按钮 */}
                                                        <div className="absolute top-2 right-2 z-10 flex items-center gap-1.5">
                                                            {isSelected && (
                                                                <div className="bg-blue-500 rounded-full p-1">
                                                                    <Check size={16} className="text-white" />
                                                                </div>
                                                            )}
                                                            {item.status === 'completed' && displayUrl && (
                                                                <button
                                                                    onClick={(e) => {
                                                                        e.stopPropagation();
                                                                        // 准备要显示的item，确保包含正确的url和selectedMjImageIndex
                                                                        const displayItem = {
                                                                            ...item,
                                                                            url: displayUrl,
                                                                            selectedMjImageIndex: item.mjImages && item.mjImages.length > 1 
                                                                                ? (item.selectedMjImageIndex || 0)
                                                                                : undefined
                                                                        };
                                                                        setLightboxItem(displayItem);
                                                                    }}
                                                                    className={`p-1.5 rounded-full transition-colors backdrop-blur-sm ${
                                                                        theme === 'dark'
                                                                            ? 'bg-black/60 text-white hover:bg-black/80'
                                                                            : 'bg-white/80 text-zinc-700 hover:bg-white'
                                                                    }`}
                                                                    title="查看大图 (双击也可查看)"
                                                                >
                                                                    <Maximize2 size={14} />
                                                                </button>
                                                            )}
                                                        </div>
                                                        
                                                        {/* 缩略图 */}
                                                        <div className={`relative ${
                                                            ((item.mjImages && (item.mjImages.length === 4 || item.mjImages.length > 1)) || (item.mjNeedsSplit && item.apiConfig?.modelId?.includes('mj')))
                                                                ? (() => {
                                                                    const ratio = item.mjRatio || '1:1';
                                                                    if (ratio === '16:9') return 'aspect-video';
                                                                    if (ratio === '9:16') return 'aspect-[9/16]';
                                                                    if (ratio === '4:3') return 'aspect-[4/3]';
                                                                    if (ratio === '3:4') return 'aspect-[3/4]';
                                                                    if (ratio === '21:9') return 'aspect-[21/9]';
                                                                    return 'aspect-square';
                                                                })()
                                                                : 'aspect-video'
                                                        } ${theme === 'dark' ? 'bg-zinc-900' : 'bg-zinc-100'}`}>
                                                            {item.status === 'completed' && displayUrl ? (
                                                                item.type === 'video' || isVideoUrl(displayUrl) ? (
                                                                    <video
                                                                        src={displayUrl}
                                                                        className="w-full h-full object-contain"
                                                                        muted
                                                                        playsInline
                                                                    />
                                                                ) : (
                                                                    <img
                                                                        src={displayUrl}
                                                                        className="w-full h-full object-contain"
                                                                        alt="生成图"
                                                                        onError={(e) => {
                                                                            e.target.style.display = 'none';
                                                                        }}
                                                                    />
                                                                )
                                                            ) : (
                                                                <div className={`w-full h-full flex items-center justify-center ${
                                                                    theme === 'dark' ? 'text-zinc-600' : 'text-zinc-400'
                                                                }`}>
                                                                    {item.status === 'generating' ? (
                                                                        <Loader2 size={24} className="animate-spin" />
                                                                    ) : (
                                                                        <FileImage size={24} />
                                                                    )}
                                                                </div>
                                                            )}
                                                        </div>
                                                        
                                                        {/* 底部信息 */}
                                                        <div className={`p-2 text-xs ${
                                                            theme === 'dark' ? 'bg-zinc-900 text-zinc-300' : 'bg-zinc-50 text-zinc-700'
                                                        }`}>
                                                            <div className="truncate font-medium">{item.prompt || '未命名'}</div>
                                                            <div className="text-[10px] opacity-70 mt-0.5">
                                                                {item.modelName || '未知模型'} • {item.time}
                                                            </div>
                                                        </div>
                                                    </div>
                                                );
                                            })}
                                        </div>
                                    </div>
                                </div>
                            </div>
                        )}
                    </div>
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<TapnowApp />);
    </script>
</body>
</html>
